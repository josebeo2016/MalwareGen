#include "adbg_NtSetInformationThread.h"

#define SHOW_DEBUG_MESSAGES

typedef enum _THREAD_INFORMATION_CLASS {
	ThreadBasicInformation,
	ThreadTimes,
	ThreadPriority,
	ThreadBasePriority,
	ThreadAffinityMask,
	ThreadImpersonationToken,
	ThreadDescriptorTableEntry,
	ThreadEnableAlignmentFaultFixup,
	ThreadEventPair,
	ThreadQuerySetWin32StartAddress,
	ThreadZeroTlsCell,
	ThreadPerformanceCount,
	ThreadAmILastThread,
	ThreadIdealProcessor,
	ThreadPriorityBoost,
	ThreadSetTlsArrayAddress,
	ThreadIsIoPending,
	ThreadHideFromDebugger
} THREAD_INFORMATION_CLASS, *PTHREAD_INFORMATION_CLASS;

typedef NTSTATUS(__stdcall *_NtSetInformationThread)(_In_ HANDLE, _In_ THREAD_INFORMATION_CLASS, _In_ PVOID, _In_ ULONG);

// =======================================================================
// Memory Checks
// These checks focus on Windows structures containing information which 
// can reveal the presence of a debugger. 
// =======================================================================

/*
* // adbg_NtSetInformationThread()
*
* // How it works:
* Hides the main thread from the debugger. Any attempt to control
* the process after this call will end the debugging session.
*
* // Indication:
* ...
*
* // Bypass:
* ...
*/
void adbg_NtSetInformationThread(void)
{
	THREAD_INFORMATION_CLASS ThreadHideFromDebugger = THREAD_INFORMATION_CLASS::ThreadHideFromDebugger;

	// Get a handle to ntdll.dll so we can import NtSetInformationThread
	HMODULE hNtdll = LoadLibraryW(L"ntdll.dll");
	if (hNtdll == INVALID_HANDLE_VALUE || hNtdll == NULL)
	{
		goto CANT_CHECK;
	}

	// Dynamically acquire the addres of NtSetInformationThread and NtQueryInformationThread
	_NtSetInformationThread NtSetInformationThread = NULL;
	NtSetInformationThread = (_NtSetInformationThread)GetProcAddress(hNtdll, "NtSetInformationThread");

	if (NtSetInformationThread == NULL)
	{
		goto CANT_CHECK;
	}

	// There is nothing to check here after this call.
	NtSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, 0, 0);

CANT_CHECK:
	_asm
	{
		nop;
	}
}
