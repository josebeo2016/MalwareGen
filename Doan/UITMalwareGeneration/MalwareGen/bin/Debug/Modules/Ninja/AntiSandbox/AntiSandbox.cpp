#include "AntiSandbox.h"


/*
Timing Attack
*/
void WaitForSingleObject(UINT delayInMilliSeconds)
{
	HANDLE hEvent;

	// Create a nonsignaled event
	hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (hEvent == NULL)
		printf("CreateEvent error");
	else
	{
		// Wait until timeout 
		DWORD x = WaitForSingleObject(hEvent, delayInMilliSeconds);
	}

	// Malicious code goes here

}


void sleep_loop(UINT delayInMilliSeconds)
{
	/*
	This trick is about performing a low number of seconds to sleep but in a loop,
	the reason behind that sandboxes tries to avoid patching such sleeps because it
	could lead to race conditions and also because it is just negliable. However,
	when you do it in a loop, you can make it efficiant to cuz the sandboxe to reach
	its timeout.
	*/

	int delayInMilliSeconds_divided = delayInMilliSeconds / 1000;

	/* Example: we want to sleep 300 seeconds, then we can sleep
	0.3s for 1000 times which is like: 300 seconds = 5 minues */
	for (int i = 0; i < 1000; i++) {
		Sleep(delayInMilliSeconds_divided);
	}

	// Malicious code goes here
}

/*
Another timinig attack using the API IcmpSendEcho which takes a TimeOut
in milliseconds as a parameter, to wait for IPv4 ICMP packets replies.
First time observed: http://blog.talosintelligence.com/2017/09/avast-distributes-malware.html
*/
void IcmpSendEcho(UINT delayInMilliSeconds)
{

	HANDLE hIcmpFile;
	unsigned long DestinationAddress = INADDR_NONE;
	char SendData[32] = "Data Buffer";
	LPVOID ReplyBuffer = NULL;
	DWORD ReplySize = 0;
	const char ipaddr[] = "224.0.0.0";

	hIcmpFile = IcmpCreateFile();
	if (hIcmpFile == INVALID_HANDLE_VALUE) {
		printf("\tUnable to open handle.\n");
		printf("IcmpCreatefile returned error: %ld\n", GetLastError());
		goto failed;
	}

	ReplySize = sizeof(ICMP_ECHO_REPLY) + sizeof(SendData);
	ReplyBuffer = (VOID*)malloc(ReplySize);
	if (ReplyBuffer == NULL) {
		printf("\tUnable to allocate memory\n");
		goto failed;
	}


	IcmpSendEcho(hIcmpFile, DestinationAddress, SendData, sizeof(SendData), NULL, ReplyBuffer, ReplySize, delayInMilliSeconds);

failed:
	;
}

/*
General
*/

/*
Check if there is any mouse movement in the sandbox.
*/
void mouse_movement() {

	POINT positionA = {};
	POINT positionB = {};

	/* Retrieve the position of the mouse cursor, in screen coordinates */
	GetCursorPos(&positionA);

	/* Wait a moment */
	Sleep(5000);

	/* Retrieve the poition gain */
	GetCursorPos(&positionB);

	if ((positionA.x == positionB.x) && (positionA.y == positionB.y))
		/* Probably a sandbox, because mouse position did not change. */
		exit(1);

}

/*
This trick consists of getting information about total amount of space.
This can be used to expose a sandbox.
*/
void disk_size_getdiskfreespace()
{
	ULONGLONG minHardDiskSize = (80ULL * (1024ULL * (1024ULL * (1024ULL))));
	LPCSTR pszDrive = NULL;
	BOOL bStatus = FALSE;

	// 64 bits integer, low and high bytes
	ULARGE_INTEGER totalNumberOfBytes;

	// If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero).
	bStatus = GetDiskFreeSpaceEx(pszDrive, NULL, &totalNumberOfBytes, NULL);
	if (bStatus) {
		if (totalNumberOfBytes.QuadPart < minHardDiskSize)  // 80GB
			exit(1);
	}

}

/*
Sleep and check if time have been accelerated
*/
void accelerated_sleep()
{
	DWORD dwStart = 0, dwEnd = 0, dwDiff = 0;
	DWORD dwMillisecondsToSleep = 60 * 1000;

	/* Retrieves the number of milliseconds that have elapsed since the system was started */
	dwStart = GetTickCount();

	/* Let's sleep 1 minute so Sandbox is interested to patch that */
	Sleep(dwMillisecondsToSleep);

	/* Do it again */
	dwEnd = GetTickCount();

	/* If the Sleep function was patched*/
	dwDiff = dwEnd - dwStart;
	if (dwDiff > dwMillisecondsToSleep - 1000) // substracted 1s just to be sure
	{}
	else
		exit(1);
}

void loaded_dlls()
{
	/* Some vars */
	HMODULE hDll;

	/* Array of strings of blacklisted dlls */
	char* szDlls[] = {
		"avghookx.dll",		// AVG
		"avghooka.dll",		// AVG
		"snxhk.dll",		// Avast
		"sbiedll.dll",		// Sandboxie
		"dbghelp.dll",		// WindBG
		"api_log.dll",		// iDefense Lab
		"dir_watch.dll",	// iDefense Lab
		"pstorec.dll",		// SunBelt Sandbox
		"vmcheck.dll",		// Virtual PC
		"wpespy.dll"		// WPE Pro
	};

	WORD dwlength = sizeof(szDlls) / sizeof(szDlls[0]);
	for (int i = 0; i < dwlength; i++)
	{
		/* Check if process loaded modules contains the blacklisted dll */
		hDll = GetModuleHandle(szDlls[i]);
		if (hDll != NULL)
			exit(1);
	}
}

