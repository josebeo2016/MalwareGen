#include <windows.h>
#include <string>
#include <stdio.h>
#include <atlstr.h>
#include <stdlib.h> 
#include <time.h>

#include "Common/CryptoAPI/CryptoAPI.h"
#include "Common/PE/pe.h"

char *ReadFile(const char * file, DWORD &size)
{
	FILE *fFile;
	long lSize;
	char *buf = NULL;
	size_t result;

	fFile = fopen(file, "rb");
	if (fFile)
	{
		fseek(fFile, 0, SEEK_END);
		lSize = ftell(fFile);
		size = lSize;
		rewind(fFile);

		buf = (char*)calloc(lSize, 1);
		if (buf)
		{
			result = fread(buf, 1, lSize, fFile);
			if (result != lSize)
			{
				printf("Reading file failed.");
				free(buf);
				buf = NULL;
				size = 0;
			}
		}
		else
			printf("calloc failed.");
	}
	else
		printf("Can't open file, error %d.", GetLastError());

	return buf;
}

void WriteFile(const char *file, char* buf, DWORD size)
{
	FILE *fo = fopen(file, "wb");
	if (fo)
	{
		fwrite(buf, size, 1, fo);

		fclose(fo);
	}
}

int Id = 0;
BOOL WINAPI EnumNamesFunc(HMODULE hModule, LPCSTR lpType, LPSTR lpName, LONG_PTR lParam)
{
	if ((ULONG)lpName & 0xFFFF0000)
	{
		//cout << lpName;
	}
	else
	{
		Id = (int)((USHORT)lpName);
	}
	return TRUE;
}

std::string GetResource(char *PathExe)
{
	HRSRC hRes;
	HMODULE hSrcExe;
	HGLOBAL hData = NULL;
	std::string ret = "";

	//Load info about Icon of Exe File
	hSrcExe = LoadLibraryExA(PathExe, NULL, LOAD_LIBRARY_AS_IMAGE_RESOURCE);
	if (hSrcExe)
	{
		if (EnumResourceNamesA(hSrcExe, RT_MANIFEST, EnumNamesFunc, 0))
		{
			//printf("%s\n", std::to_string(Id).c_str());
			CString str;
			str.Format("#%d", Id);
			hRes = FindResource(hSrcExe, str, RT_MANIFEST);
			if (hRes)
			{
				hData = LoadResource(hSrcExe, hRes);
				ret = std::string((char*)hData);
			}
		}
		FreeLibrary(hSrcExe);
	}
	else
	{
		//GetLastErrorAsString("Load library Exe failed", GetLastError());
	}


	return ret;
}

BOOL ClearResource(char *PathExe)
{
	HANDLE hResource = BeginUpdateResourceA(PathExe, TRUE);
	if (hResource)
	{
		return EndUpdateResourceA(hResource, FALSE);
	}
	return FALSE;
}

BOOL SetResource(char *PathExe, std::string data)
{
	BOOL ret = FALSE;
	HANDLE hResource = BeginUpdateResourceA(PathExe, TRUE);
	if (hResource)
	{
		if (UpdateResourceA(hResource, RT_MANIFEST, MAKEINTRESOURCEA(1), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (void*)data.c_str(), data.length()))
			ret = EndUpdateResourceA(hResource, FALSE);
		if (!ret)
			printf("%d\n", GetLastError());
	}

	return ret;
}

int GetNumberOfSection(const void *pImg)
{
	const IMAGE_DOS_HEADER *pDos = (const IMAGE_DOS_HEADER*)pImg;
	char *pChDos = (char*)pImg;
	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)((char*)pChDos + pDos->e_lfanew);
	return pNTHead->FileHeader.NumberOfSections;
}

int GetSizeOfImage(const void *pImg)
{
	const IMAGE_DOS_HEADER *pDos = (const IMAGE_DOS_HEADER*)pImg;
	char *pChDos = (char*)pImg;
	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)((char*)pChDos + pDos->e_lfanew);
	return pNTHead->OptionalHeader.SizeOfImage;
}

int GetSectionIndexByName(const void *pImg, std::string name)
{
	const IMAGE_DOS_HEADER *pDos = (const IMAGE_DOS_HEADER*)pImg;
	char *pChDos = (char*)pImg;
	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)((char*)pChDos + pDos->e_lfanew);
	DWORD dwFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pSectHead = (IMAGE_SECTION_HEADER*)((char*)pNTHead + dwFullNTSize);

	for (int i = 0; i < pNTHead->FileHeader.NumberOfSections; i++)
	{
		if (std::string((char*)pSectHead[i].Name) == name)
			return i;
	}
}

void FixSizeOfImage(char *file)
{
	DWORD dwSize = 0;
	char *exe = ReadFile(file, dwSize);
	if (exe)
	{
		const IMAGE_DOS_HEADER *pDos = (const IMAGE_DOS_HEADER*)exe;
		char *pChDos = (char*)exe;
		IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)((char*)pChDos + pDos->e_lfanew);
		DWORD dwFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pNTHead->FileHeader.SizeOfOptionalHeader);
		IMAGE_SECTION_HEADER *pSectHead = (IMAGE_SECTION_HEADER*)((char*)pNTHead + dwFullNTSize);

		pNTHead->OptionalHeader.SizeOfImage = pSectHead[pNTHead->FileHeader.NumberOfSections - 1].VirtualAddress + Align(pSectHead[pNTHead->FileHeader.NumberOfSections - 1].Misc.VirtualSize, pNTHead->OptionalHeader.SectionAlignment);

		WriteFile(file, exe, dwSize);
	}
}

std::string RandomStr(const int len) {
	std::string ret = "";
	static const char alphanum[] =
		"abcdefghijklmnopqrstuvwxyz";
	
	for (int i = 0; i < len; ++i) {

		ret += alphanum[rand() % (sizeof(alphanum) - 1)];
	}
	return ret;
}

int main(int argc, char* argv[])
{
	char *input = NULL;
	char *output = NULL;
	char *filename = NULL;
	bool obfus = false;

	if (argc < 7)
		return 0;

	for (int i = 1; i < argc; ++i)
	{
		if (!strcmp(argv[i], "-input"))
			input = argv[++i];
		else if (!strcmp(argv[i], "-output"))
			output = argv[++i];
		else if (!strcmp(argv[i], "-filename"))
			filename = argv[++i];
		else if (!strcmp(argv[i], "-obfus"))
			obfus = true;
	}

	if (!(input && output))
		return 0;

	//char *filename = PathFindFileNameA(output);

	char *decryptor_buf = NULL;
	char CurrentPath[MAX_PATH];
	char DecryptorPath[MAX_PATH];
	char *in = NULL;
	char *out = NULL;

	GetCurrentDirectoryA(MAX_PATH, CurrentPath);
	//folder decryptor
	strcpy(DecryptorPath, CurrentPath);
	strcat(DecryptorPath, "\\Decryptor");
	strcat(DecryptorPath, "\\release_EncryptExe.exe");

	srand(time(NULL));

	std::string resource = GetResource((LPSTR)input);
	
	DWORD decryptor_size = 0;
	decryptor_buf = ReadFile(DecryptorPath, decryptor_size);
	if (decryptor_buf)
	{
		DWORD dwInSize = 0;
		in = ReadFile(input, dwInSize);
		if (in)
		{
			char *hashdata = hash(in, dwInSize);
			if (hashdata)
			{
				char *enc_in = (char*)AES_Encrypt((BYTE*)in, dwInSize, filename);
				if (enc_in)
				{
					char *buf = (char*)calloc(sizeof(SectionData) + dwInSize, 1);
					if (buf)
					{
						SectionData *sData = (SectionData*)buf;
						memcpy(sData->buf, enc_in, dwInSize);
						sData->buf_size = dwInSize;
						memcpy(sData->hashdata, hashdata, 32);

						//insert data
						char *out = InsertLastSection(decryptor_buf, decryptor_size, sData, ".udata");
						if (obfus)
						{
							srand(time(0));

							//expand section
							/*char *out1 = NULL;
							int IndexOfdataSection = GetSectionIndexByName(out, ".data");
							for (int i = 0; i < GetNumberOfSection(out); i++)
							{
								if (i != IndexOfdataSection)
								{
									int len_obfusdata = (rand() % 0x2000) + 0x1000;
									char *obfusdata = (char*)calloc(len_obfusdata, 1);
									if (obfusdata)
									{
										for (int j = 0; j < len_obfusdata; j++)
											obfusdata[j] = rand() % 0x100;
										//printf("%x\n", len_obfusdata);
										out1 = ExpandSection(out, decryptor_size, obfusdata, len_obfusdata, i);

										free(obfusdata);

										free(out);
										out = out1;
										out1 = NULL;

										if (!out)
											break;
									}
								}
							}*/

							//insert section obfuscate
							char *out1 = NULL;
							int numberOfofus = (rand() % 5) + (MAX_SECTIONS - GetNumberOfSection(out) - 4);
							for (int i = 0; i < numberOfofus; i++)
							{
								int len_obfusdata = (rand() % 0x2000) + 0x1000;
								char *obfusdata = (char*)calloc(len_obfusdata + sizeof(SectionData), 1);
								if (obfusdata)
								{
									SectionData *sObfusData = (SectionData*)obfusdata;
									sObfusData->buf_size = len_obfusdata;
									for (int j = 0; j < 32; j++)
										sObfusData->hashdata[j] = rand() % 0x100;

									for (int j = 0; j < len_obfusdata; j++)
										sObfusData->buf[j] = rand() % 0x100;

									std::string section_name = "." + RandomStr(5);

									out1 = InsertLastSection(out, decryptor_size, sObfusData, (char*)section_name.c_str());

									free(obfusdata);

									free(out);
									out = out1;
									out1 = NULL;

									if (!out)
										break;
								}
							}

							if (out)
							{
								int numberOfSection = GetNumberOfSection(out);
								char *output1 = (char*)out;
								char *output2 = NULL;
								//printf("Have %d sections\n", numberOfSection);
								for (int i = 0; i < numberOfSection; i++)
								{
									int new_index = rand() % numberOfSection;
									while (new_index == i)
									{
										new_index = rand() % numberOfSection;
									}
									//printf("move section %d to %d\n", i, new_index);
									char *output2 = MoveSection(output1, decryptor_size, i, rand() % numberOfSection);

									free(output1);
									output1 = output2;
									output2 = NULL;

									if (!output1)
										break;
								}

								//DWORD SizeOfImage = 0;
								if (output1)
								{
									//SizeOfImage = GetSizeOfImage(output1);
									//printf("%x\n", SizeOfImage);
									//WriteFile("[out].exe", output1, decryptor_size);
									WriteFile(output, output1, decryptor_size);
									free(output1);
								}

								//ClearResource(output);

								BOOL ret = SetResource(output, resource);

								//restore SizeOfImage
								FixSizeOfImage(output);
							}
						}
						else
						{
							if (out)
							{
								WriteFile(output, out, decryptor_size);
								free(out);
							}
						}



						free(buf);
					}

					free(enc_in);
				}

				free(hashdata);
			}

			free(in);
		}

		free(decryptor_buf);
	}
}
