#include "pe.h"

#ifdef _WIN64
#define POINTER_TYPE unsigned long long
#else
#define POINTER_TYPE unsigned long
#endif

struct PE
{
	DWORD size;
	char buf[1];
};

unsigned int NameHash(const char *szName)
{
	unsigned int ret = 0;
	for (int i = 0; szName[i] != 0; ++i)
	{
		//kernel32: ret * 3 + (szName[i] / 16) + (szName[i] % 16) * 16 + i;
		ret = ret * 3 + (szName[i] / 16) + (szName[i] % 16) * 16 + i;
	}

	return ret;
}


bool DoBaseReloc(unsigned char *codeBase, size_t codeSize, size_t delta, IMAGE_BASE_RELOCATION *pBaseReloc, int remainSize)
{
	bool ret = true;
	while (remainSize > 0 && ret)
	{
		WORD *arrRel = (WORD *)&pBaseReloc[1];
		int nRel = (pBaseReloc[0].SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
		char *dest = (char*)codeBase + pBaseReloc[0].VirtualAddress;

		if (dest < (char*)codeBase || (char*)codeBase + codeSize < dest)
		{
			ret = false;
		}
		else for (int i = 0; i < nRel; ++i)
		{
			DWORD *patchAddrHL;
#ifdef _WIN64
			ULONGLONG *patchAddr64;
#endif
			int offset = arrRel[i] & 0xfff;
			switch (arrRel[i] >> 12)
			{
			case IMAGE_REL_BASED_ABSOLUTE:
				// skip relocation
				break;

			case IMAGE_REL_BASED_HIGHLOW:
				// change complete 32 bit address
				patchAddrHL = (DWORD *)(dest + offset);
				*patchAddrHL += (DWORD)delta;
				break;

#ifdef _WIN64
			case IMAGE_REL_BASED_DIR64:
				patchAddr64 = (ULONGLONG *)(dest + offset);
				*patchAddr64 += delta;
				break;
#endif

			default:
				ret = false;
				break;
			}
		}

		if (ret)
		{
			remainSize -= pBaseReloc[0].SizeOfBlock;
			pBaseReloc = (IMAGE_BASE_RELOCATION *)((char*)pBaseReloc + pBaseReloc[0].SizeOfBlock);
		}
	}

	return ret;

}

bool DoImport(unsigned char *codeBase, IMAGE_IMPORT_DESCRIPTOR *pImportDesc)
{
	bool ret = true;

	while (pImportDesc[0].Name)
	{
		char *szLibName = (char*)codeBase + pImportDesc[0].Name;

		HMODULE hLib = LoadLibraryA(szLibName);

		if (!hLib)
		{
			ret = false;
			break;
		}

		POINTER_TYPE *thunkRef;
		FARPROC *funcRef;
		if (pImportDesc[0].OriginalFirstThunk) {
			thunkRef = (POINTER_TYPE *)(codeBase + pImportDesc[0].OriginalFirstThunk);
			funcRef = (FARPROC *)(codeBase + pImportDesc[0].FirstThunk);
		}
		else {
			// no hint table
			thunkRef = (POINTER_TYPE *)(codeBase + pImportDesc[0].FirstThunk);
			funcRef = (FARPROC *)(codeBase + pImportDesc[0].FirstThunk);
		}

		if (!thunkRef || !funcRef)
		{
			ret = false;
			break;
		}
		else for (; *thunkRef; thunkRef++, funcRef++)
		{
			if (IMAGE_SNAP_BY_ORDINAL(*thunkRef))
			{
				*funcRef = GetProcAddress(hLib, (LPCSTR)IMAGE_ORDINAL(*thunkRef));
			}
			else
			{
				PIMAGE_IMPORT_BY_NAME thunkData = (PIMAGE_IMPORT_BY_NAME)(codeBase + (*thunkRef));

				*funcRef = GetProcAddress(hLib, (LPCSTR)&thunkData->Name);
			}

			if (*funcRef == 0) {
				ret = false;
				break;
			}
		}

		pImportDesc++;
	}

	return ret;
}

FARPROC DoGetProcAddress(unsigned char *codeBase, PIMAGE_EXPORT_DIRECTORY pExport, unsigned int hName)
{
	void* ret = nullptr;

	WORD *pwExportOrd = (WORD*)(codeBase + pExport->AddressOfNameOrdinals);
	DWORD *pdwExportAddr = (DWORD*)(codeBase + pExport->AddressOfFunctions);
	DWORD *pdwExportName = (DWORD*)(codeBase + pExport->AddressOfNames);

	DWORD i, n = pExport->NumberOfNames;
	for (i = 0; i < n; ++i)
	{
		const char *pszExpFuncName = (char*)codeBase + pdwExportName[i];
		if (NameHash(pszExpFuncName) == hName)
		{
			ret = codeBase + pdwExportAddr[pwExportOrd[i]];
			break;
		}
	}

	return (FARPROC)ret;
}

bool PECheck(const void *pImg, int sztImg)
{
	bool ret = false;
	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)pImg;
	IMAGE_NT_HEADERS *pNT = (IMAGE_NT_HEADERS*)((char*)pImg + pDos->e_lfanew);

	WORD wMagic =
#ifndef _WIN64
		IMAGE_NT_OPTIONAL_HDR32_MAGIC;
#else
		IMAGE_NT_OPTIONAL_HDR64_MAGIC;
#endif

	WORD wMachine =
#ifndef _WIN64
		IMAGE_FILE_MACHINE_I386;
#else
		IMAGE_FILE_MACHINE_AMD64;
#endif
	if ((ULONG)pDos->e_lfanew + pNT->FileHeader.SizeOfOptionalHeader >= (ULONG)sztImg)
	{
		printf("Invalid PE Header size");
	}
	if (pNT->Signature != IMAGE_NT_SIGNATURE)
	{
		printf("Invalid PE Signature");
	}
	else if (pNT->OptionalHeader.Magic != wMagic
		|| pNT->FileHeader.Machine != wMachine)
	{
		printf("Invalid PE Machine");
	}
	else if (pNT->FileHeader.NumberOfSections >= 90)
	{
		printf("Number of PE Section %d >= %d", pNT->FileHeader.NumberOfSections, 90);
	}
	else if (pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size == 0)
	{
		printf("Not support image with no relocation yet!");
	}
	else
	{
		ret = true;
	}

	return ret;

}

HMODULE FixIntoMem(const void *pImg, int sztImg)
{
	HMODULE hMod = nullptr;

	const IMAGE_DOS_HEADER *pDos = (const IMAGE_DOS_HEADER*)pImg;
	char *pChOldDos = (char*)pDos;

	IMAGE_NT_HEADERS *pOldNTHead = (IMAGE_NT_HEADERS*)((char*)pImg + pDos->e_lfanew);
	DWORD dwFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pOldNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pOldSectHead = (IMAGE_SECTION_HEADER*)((char*)pOldNTHead + dwFullNTSize);

	if (pOldNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress == 0
		&& (pOldNTHead->FileHeader.Characteristics&IMAGE_FILE_RELOCS_STRIPPED)
		)
	{
		hMod = (HMODULE)pOldNTHead->OptionalHeader.ImageBase;
	}

	hMod = (HMODULE)VirtualAlloc(hMod, pOldNTHead->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (hMod == nullptr)
	{
		printf("Can't alloc memory: %d at %p", pOldNTHead->OptionalHeader.SizeOfImage, hMod);
	}
	else
	{
		IMAGE_DOS_HEADER *pNewDos = (IMAGE_DOS_HEADER*)hMod;
		char *pChNewDos = (char*)hMod;

		DWORD dwStubSize = dwFullNTSize + sizeof(IMAGE_SECTION_HEADER)*pOldNTHead->FileHeader.NumberOfSections;
		//copy dos
		memcpy(pChNewDos, pChOldDos, pDos->e_lfanew);

		IMAGE_NT_HEADERS *pNewNtHead = (IMAGE_NT_HEADERS*)(pChNewDos + pDos->e_lfanew);
		//copy NT head & section header
		memcpy(pNewNtHead, pOldNTHead, dwStubSize);

		//fix all section 
		int iSectionIndex = 0;

		for (iSectionIndex = 0;
			iSectionIndex < pOldNTHead->FileHeader.NumberOfSections;
			++iSectionIndex)
		{
			char *pNewSectData = pChNewDos + pOldSectHead[iSectionIndex].VirtualAddress;
			char *pOldSectData = pChOldDos + pOldSectHead[iSectionIndex].PointerToRawData;

			//check for valid section data
			if (pOldSectHead[iSectionIndex].SizeOfRawData
				&& pOldSectHead[iSectionIndex].PointerToRawData + pOldSectHead[iSectionIndex].SizeOfRawData > (ULONG)sztImg)
			{
				break;
			}

			DWORD dwRVASize = Align(pOldSectHead[iSectionIndex].Misc.VirtualSize, pOldNTHead->OptionalHeader.SectionAlignment);
			memcpy(pNewSectData, pOldSectData, pOldSectHead[iSectionIndex].SizeOfRawData);
		}

		if (iSectionIndex == pOldNTHead->FileHeader.NumberOfSections)
		{
		}
		else
		{
			VirtualFree(hMod, 0, MEM_RELEASE); hMod = nullptr;
		}
	}

	return (HMODULE)hMod;
}

bool Reloc(HMODULE hMod)
{
	bool ret = false;

	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
	unsigned char *pBase = (unsigned char*)pDos;

	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)((char*)pDos + pDos->e_lfanew);
	IMAGE_DATA_DIRECTORY imgDirRelocation = pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

	unsigned char *pOrgBase = (unsigned char*)pNTHead->OptionalHeader.ImageBase;
	if (pOrgBase == pBase)
	{
		ret = true;
	}
	else if (imgDirRelocation.VirtualAddress == 0)
	{
		ret = false;
	}
	else
	{
		size_t delta = pBase - pOrgBase;

		IMAGE_BASE_RELOCATION *pBaseReloc = (IMAGE_BASE_RELOCATION*)(pBase + imgDirRelocation.VirtualAddress);

		if (imgDirRelocation.VirtualAddress + imgDirRelocation.Size >= pNTHead->OptionalHeader.SizeOfImage)
		{
			ret = false;
		}
		else
		{
			ret = DoBaseReloc(pBase, pNTHead->OptionalHeader.SizeOfImage, delta, pBaseReloc, imgDirRelocation.Size);
		}
	}

	return ret;
}

bool Import(HMODULE hMod)
{
	bool ret = true;

	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
	unsigned char *pBase = (unsigned char*)hMod;

	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)(pBase + pDos->e_lfanew);
	IMAGE_DATA_DIRECTORY imgDirImport = pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];


	if (imgDirImport.VirtualAddress)
	{
		IMAGE_IMPORT_DESCRIPTOR *pImportDesc = (IMAGE_IMPORT_DESCRIPTOR*)(pBase + imgDirImport.VirtualAddress);
		if (imgDirImport.VirtualAddress + imgDirImport.Size >= pNTHead->OptionalHeader.SizeOfImage)
		{
			ret = false;
		}
		else
		{
			ret = DoImport(pBase, pImportDesc);
		}
	}

	return ret;
}

bool ExecuteTLS(HMODULE hMod)
{
	unsigned char *codeBase = (unsigned char *)hMod;
	PIMAGE_TLS_DIRECTORY tls;
	PIMAGE_TLS_CALLBACK* callback;

	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)codeBase;
	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)(codeBase + pDos->e_lfanew);
	PIMAGE_DATA_DIRECTORY directory = &pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
	if (directory->VirtualAddress == 0) {
		return true;
	}

	tls = (PIMAGE_TLS_DIRECTORY)(codeBase + directory->VirtualAddress);
	callback = (PIMAGE_TLS_CALLBACK *)tls->AddressOfCallBacks;
	if (callback) {
		while (*callback) {
			(*callback)((LPVOID)codeBase, DLL_PROCESS_ATTACH, NULL);
			callback++;
		}
	}
	return true;
}

HMODULE Load(LPVOID Param)
{
	PE *sPe = (PE*)Param;
	HMODULE hMod = FixIntoMem(sPe->buf, sPe->size);
	if (hMod
		&& Reloc(hMod)
		&& Import(hMod)
		&& ExecuteTLS(hMod))
	{
		IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
		IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)((char*)hMod + pDos->e_lfanew);

		char *pEntry = (char*)hMod + pNTHead->OptionalHeader.AddressOfEntryPoint;

		if ((pNTHead->FileHeader.Characteristics&IMAGE_FILE_DLL) == 0)
		{
			int(WINAPI *iExeMain)(void);
			*(char **)&iExeMain = pEntry;

			iExeMain();
		}
		else
		{
			bool(WINAPI *iDllMain)(void*, unsigned int, void*);
			*(char **)&iDllMain = pEntry;

			if (iDllMain(hMod, DLL_PROCESS_ATTACH, nullptr))
			{
				printf("LoadDll failed");
				Release(hMod);
			}
		}
	}

	return hMod;
}

FARPROC GetFuncAddress(HMODULE hMod, unsigned int hashProc)
{
	FARPROC ret = nullptr;

	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
	unsigned char *pBase = (unsigned char*)hMod;

	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)(pBase + pDos->e_lfanew);
	IMAGE_DATA_DIRECTORY imgDirImport = pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

	if (imgDirImport.VirtualAddress)
	{
		IMAGE_EXPORT_DIRECTORY *pExportDesc = (IMAGE_EXPORT_DIRECTORY*)(pBase + imgDirImport.VirtualAddress);
		if (imgDirImport.VirtualAddress + imgDirImport.Size >= pNTHead->OptionalHeader.SizeOfImage)
		{
		}
		else
		{
			ret = DoGetProcAddress(pBase, pExportDesc, hashProc);
		}
	}

	return ret;
}

FARPROC GetFuncAddress(HMODULE hMod, const char * szProc)
{
	return GetFuncAddress(hMod, NameHash(szProc));
}

bool HookExport(HMODULE hMod, FARPROC fpOrgFunc, FARPROC fpChangeTo)
{
	bool ret = false;
	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
	IMAGE_NT_HEADERS *pNt = (IMAGE_NT_HEADERS*)((char*)hMod + pDos->e_lfanew);

	IMAGE_EXPORT_DIRECTORY *pExport = (IMAGE_EXPORT_DIRECTORY*)((char*)hMod + pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	WORD *pwExportOrd = (WORD*)((char*)hMod + pExport->AddressOfNameOrdinals);
	DWORD *pdwExportAddr = (DWORD*)((char*)hMod + pExport->AddressOfFunctions);

	DWORD i, n = pExport->NumberOfFunctions;
	for (i = 0; i < n; ++i)
	{
		FARPROC fp = (FARPROC)(pdwExportAddr[pwExportOrd[i]] + (char*)hMod);
		if (fp == fpOrgFunc)
		{
			DWORD dwOldProtect = 0;
			if (VirtualProtect(&pdwExportAddr[pwExportOrd[i]], sizeof(pdwExportAddr[0]), PAGE_EXECUTE_READWRITE, &dwOldProtect))
			{
				pdwExportAddr[pwExportOrd[i]] = (char*)fpChangeTo - (char*)hMod;
				VirtualProtect(&pdwExportAddr[pwExportOrd[i]], sizeof(pdwExportAddr[0]), dwOldProtect, &dwOldProtect);
				ret = true;
			}
			break;
		}
	}

	return ret;
}

void Release(HMODULE hMod)
{
	if (hMod != nullptr)
	{
		IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
		IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)((char*)hMod + pDos->e_lfanew);

		char *pEntry = (char*)hMod + pNTHead->OptionalHeader.AddressOfEntryPoint;

		if ((pNTHead->FileHeader.Characteristics&IMAGE_FILE_DLL) == IMAGE_FILE_DLL)
		{
			bool(WINAPI *iDllMain)(void*, unsigned int, void*);
			*(char **)&iDllMain = pEntry;

			printf("Call DllMain");
			iDllMain(hMod, DLL_PROCESS_DETACH, 0);
		}

		VirtualFree(hMod, 0, MEM_RELEASE);
	}
}

char *InsertLastSection(const void *pImg, DWORD &sztImg, SectionData *sData, char *sectionname)
{
	DWORD HeaderSum = 0, CheckSum = 0;
	const IMAGE_DOS_HEADER *pOldDos = (const IMAGE_DOS_HEADER*)pImg;
	char *pChOldDos = (char*)pImg;
	IMAGE_NT_HEADERS *pOldNTHead = (IMAGE_NT_HEADERS*)((char*)pChOldDos + pOldDos->e_lfanew);

	char *pChNewDos = (char*)calloc(sztImg + Align(sData->buf_size + sizeof(SectionData), pOldNTHead->OptionalHeader.FileAlignment), 1);
	memcpy(pChNewDos, pChOldDos, sztImg);
	sztImg = sztImg + Align(sData->buf_size + sizeof(SectionData), pOldNTHead->OptionalHeader.FileAlignment);

	const IMAGE_DOS_HEADER *pNewDos = (const IMAGE_DOS_HEADER*)pChNewDos;

	IMAGE_NT_HEADERS *pNewNTHead = (IMAGE_NT_HEADERS*)((char*)pChNewDos + pNewDos->e_lfanew);
	DWORD dwNewFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pNewNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pNewSectHead = (IMAGE_SECTION_HEADER*)((char*)pNewNTHead + dwNewFullNTSize);


	pNewNTHead->FileHeader.NumberOfSections = pNewNTHead->FileHeader.NumberOfSections + 1;
	int iLastSectionIndex = pNewNTHead->FileHeader.NumberOfSections - 1;
	strcpy((char*)pNewSectHead[iLastSectionIndex].Name, sectionname);
	pNewSectHead[iLastSectionIndex].Misc.PhysicalAddress = sData->buf_size + sizeof(SectionData);
	pNewSectHead[iLastSectionIndex].Misc.VirtualSize =sData->buf_size + sizeof(SectionData);
	pNewSectHead[iLastSectionIndex].VirtualAddress = Align(pNewSectHead[iLastSectionIndex - 1].VirtualAddress + pNewSectHead[iLastSectionIndex - 1].Misc.VirtualSize, pNewNTHead->OptionalHeader.SectionAlignment);
	pNewSectHead[iLastSectionIndex].SizeOfRawData = Align(sData->buf_size + sizeof(SectionData), pNewNTHead->OptionalHeader.FileAlignment);
	pNewSectHead[iLastSectionIndex].PointerToRawData = Align(pNewSectHead[iLastSectionIndex - 1].PointerToRawData + pNewSectHead[iLastSectionIndex - 1].SizeOfRawData, pNewNTHead->OptionalHeader.FileAlignment);
	pNewSectHead[iLastSectionIndex].PointerToRelocations = 0;
	pNewSectHead[iLastSectionIndex].PointerToLinenumbers = 0;
	pNewSectHead[iLastSectionIndex].NumberOfRelocations = 0;
	pNewSectHead[iLastSectionIndex].NumberOfLinenumbers = 0;
	pNewSectHead[iLastSectionIndex].Characteristics = 0x40000000;

	pNewNTHead->OptionalHeader.SizeOfImage = Align(pNewNTHead->OptionalHeader.SizeOfImage + pNewSectHead[iLastSectionIndex].Misc.VirtualSize, pNewNTHead->OptionalHeader.SectionAlignment);
	//printf("%x\n", pNewNTHead->OptionalHeader.SizeOfImage);
	memcpy((void*)(pChNewDos + pNewSectHead[iLastSectionIndex].PointerToRawData), sData, sData->buf_size + sizeof(SectionData));

	//CheckSumMappedFile(pChNewDos, sztImg, &HeaderSum, &CheckSum);
	//pNewNTHead->OptionalHeader.CheckSum = CheckSum;

	return pChNewDos;
}

int FindSectionByVirAddr(DWORD virtual_address, IMAGE_NT_HEADERS *pNTHead, IMAGE_SECTION_HEADER *pSectHead)
{
	int ret = 0;
	for (int iSectionIndex = 0;
		iSectionIndex < pNTHead->FileHeader.NumberOfSections;
		++iSectionIndex)
	{
		if (virtual_address >= pSectHead[iSectionIndex].VirtualAddress
			&& virtual_address < (pSectHead[iSectionIndex].VirtualAddress + Align(pSectHead[iSectionIndex].Misc.VirtualSize, pNTHead->OptionalHeader.SectionAlignment)))
		{
			ret = iSectionIndex;
			break;
		}
	}

	return ret;
}

int FindSectionByName(std::string section_name, IMAGE_NT_HEADERS *pNTHead, IMAGE_SECTION_HEADER *pSectHead)
{
	int ret = 0;
	for (int iSectionIndex = 0;
		iSectionIndex < pNTHead->FileHeader.NumberOfSections;
		++iSectionIndex)
	{
		if (section_name == (std::string)(char*)pSectHead[iSectionIndex].Name)
		{
			ret = iSectionIndex;
			break;
		}
	}

	return ret;
}

std::string FindSectionNameByIndex(int index, IMAGE_NT_HEADERS *pNTHead, IMAGE_SECTION_HEADER *pSectHead)
{
	std::string ret = "";
	for (int iSectionIndex = 0;
		iSectionIndex < pNTHead->FileHeader.NumberOfSections;
		++iSectionIndex)
	{
		if (index == iSectionIndex)
		{
			ret = (std::string)(char*)pSectHead[iSectionIndex].Name;
			break;
		}
	}

	return ret;
}

void Move_FixSection(char *pChOldDos, char *pChNewDos, int old_index, int new_index)
{
	//old
	IMAGE_DOS_HEADER *pOldDos = (IMAGE_DOS_HEADER*)pChOldDos;
	IMAGE_NT_HEADERS *pOldNTHead = (IMAGE_NT_HEADERS*)((char*)pChOldDos + pOldDos->e_lfanew);
	DWORD dwOldFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pOldNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pOldSectHead = (IMAGE_SECTION_HEADER*)((char*)pOldNTHead + dwOldFullNTSize);

	//new
	IMAGE_DOS_HEADER *pNewDos = (IMAGE_DOS_HEADER*)pChNewDos;
	IMAGE_NT_HEADERS *pNewNTHead = (IMAGE_NT_HEADERS*)((char*)pChNewDos + pNewDos->e_lfanew);
	DWORD dwNewFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pNewNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pNewSectHead = (IMAGE_SECTION_HEADER*)((char*)pNewNTHead + dwNewFullNTSize);

	//fix
	if (old_index > new_index)
	{
		int iSectionIndex = 0;
		for (iSectionIndex = 0;
			iSectionIndex < pNewNTHead->FileHeader.NumberOfSections;
			++iSectionIndex)
		{
			if (iSectionIndex == new_index)
			{
				strcpy((char*)pNewSectHead[iSectionIndex].Name, (char*)pOldSectHead[old_index].Name);
				pNewSectHead[iSectionIndex].Misc.PhysicalAddress = pOldSectHead[old_index].Misc.PhysicalAddress;
				pNewSectHead[iSectionIndex].Misc.VirtualSize = pOldSectHead[old_index].Misc.PhysicalAddress;
				pNewSectHead[iSectionIndex].SizeOfRawData = pOldSectHead[old_index].SizeOfRawData;
				pNewSectHead[iSectionIndex].PointerToRelocations = pOldSectHead[old_index].PointerToRelocations;
				pNewSectHead[iSectionIndex].PointerToLinenumbers = pOldSectHead[old_index].PointerToLinenumbers;
				pNewSectHead[iSectionIndex].NumberOfRelocations = pOldSectHead[old_index].NumberOfRelocations;
				pNewSectHead[iSectionIndex].NumberOfLinenumbers = pOldSectHead[old_index].NumberOfLinenumbers;
				pNewSectHead[iSectionIndex].Characteristics = pOldSectHead[old_index].Characteristics;
				if (new_index > 0)
				{
					pNewSectHead[iSectionIndex].VirtualAddress = Align(pNewSectHead[iSectionIndex - 1].VirtualAddress + pNewSectHead[iSectionIndex - 1].Misc.VirtualSize, pNewNTHead->OptionalHeader.SectionAlignment);
					pNewSectHead[iSectionIndex].PointerToRawData = Align(pNewSectHead[iSectionIndex - 1].PointerToRawData + pNewSectHead[iSectionIndex - 1].SizeOfRawData, pNewNTHead->OptionalHeader.FileAlignment);
				}
				else
				{
					pNewSectHead[iSectionIndex].VirtualAddress = 0x1000;
					pNewSectHead[iSectionIndex].PointerToRawData = 0x400;
				}


				memset((void*)(pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData), 0, pNewSectHead[iSectionIndex].SizeOfRawData);
				memcpy((void*)(pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData), (void*)(pChOldDos + pOldSectHead[old_index].PointerToRawData), pNewSectHead[iSectionIndex].SizeOfRawData);
			}
			else if (iSectionIndex > new_index && iSectionIndex <= old_index)
			{
				strcpy((char*)pNewSectHead[iSectionIndex].Name, (char*)pOldSectHead[iSectionIndex - 1].Name);
				pNewSectHead[iSectionIndex].Misc.PhysicalAddress = pOldSectHead[iSectionIndex - 1].Misc.PhysicalAddress;
				pNewSectHead[iSectionIndex].Misc.VirtualSize = pOldSectHead[iSectionIndex - 1].Misc.PhysicalAddress;
				pNewSectHead[iSectionIndex].SizeOfRawData = pOldSectHead[iSectionIndex - 1].SizeOfRawData;
				pNewSectHead[iSectionIndex].PointerToRelocations = pOldSectHead[iSectionIndex - 1].PointerToRelocations;
				pNewSectHead[iSectionIndex].PointerToLinenumbers = pOldSectHead[iSectionIndex - 1].PointerToLinenumbers;
				pNewSectHead[iSectionIndex].NumberOfRelocations = pOldSectHead[iSectionIndex - 1].NumberOfRelocations;
				pNewSectHead[iSectionIndex].NumberOfLinenumbers = pOldSectHead[iSectionIndex - 1].NumberOfLinenumbers;
				pNewSectHead[iSectionIndex].Characteristics = pOldSectHead[iSectionIndex - 1].Characteristics;
				pNewSectHead[iSectionIndex].VirtualAddress = Align(pNewSectHead[iSectionIndex - 1].VirtualAddress + pNewSectHead[iSectionIndex - 1].Misc.VirtualSize, pNewNTHead->OptionalHeader.SectionAlignment);
				pNewSectHead[iSectionIndex].PointerToRawData = Align(pNewSectHead[iSectionIndex - 1].PointerToRawData + pNewSectHead[iSectionIndex - 1].SizeOfRawData, pNewNTHead->OptionalHeader.FileAlignment);

				memset((void*)(pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData), 0, pNewSectHead[iSectionIndex].SizeOfRawData);
				memcpy((void*)(pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData), (void*)(pChOldDos + pOldSectHead[iSectionIndex - 1].PointerToRawData), pNewSectHead[iSectionIndex].SizeOfRawData);
			}
			else if (iSectionIndex > old_index)
			{
				pNewSectHead[iSectionIndex].VirtualAddress = Align(pNewSectHead[iSectionIndex - 1].VirtualAddress + pNewSectHead[iSectionIndex - 1].Misc.VirtualSize, pNewNTHead->OptionalHeader.SectionAlignment);
				pNewSectHead[iSectionIndex].PointerToRawData = Align(pNewSectHead[iSectionIndex - 1].PointerToRawData + pNewSectHead[iSectionIndex - 1].SizeOfRawData, pNewNTHead->OptionalHeader.FileAlignment);

				memset((void*)(pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData), 0, pNewSectHead[iSectionIndex].SizeOfRawData);
				memcpy((void*)(pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData), (void*)(pChOldDos + pOldSectHead[iSectionIndex].PointerToRawData), pNewSectHead[iSectionIndex].SizeOfRawData);
			}
		}
	}
	else if (old_index < new_index)
	{
		int iSectionIndex = 0;
		for (iSectionIndex = 0;
			iSectionIndex < pNewNTHead->FileHeader.NumberOfSections;
			++iSectionIndex)
		{
			if (iSectionIndex == new_index)
			{
				strcpy((char*)pNewSectHead[iSectionIndex].Name, (char*)pOldSectHead[old_index].Name);
				pNewSectHead[iSectionIndex].Misc.PhysicalAddress = pOldSectHead[old_index].Misc.PhysicalAddress;
				pNewSectHead[iSectionIndex].Misc.VirtualSize = pOldSectHead[old_index].Misc.PhysicalAddress;
				pNewSectHead[iSectionIndex].SizeOfRawData = pOldSectHead[old_index].SizeOfRawData;
				pNewSectHead[iSectionIndex].PointerToRelocations = pOldSectHead[old_index].PointerToRelocations;
				pNewSectHead[iSectionIndex].PointerToLinenumbers = pOldSectHead[old_index].PointerToLinenumbers;
				pNewSectHead[iSectionIndex].NumberOfRelocations = pOldSectHead[old_index].NumberOfRelocations;
				pNewSectHead[iSectionIndex].NumberOfLinenumbers = pOldSectHead[old_index].NumberOfLinenumbers;
				pNewSectHead[iSectionIndex].Characteristics = pOldSectHead[old_index].Characteristics;
				if (new_index > 0)
				{
					pNewSectHead[iSectionIndex].VirtualAddress = Align(pNewSectHead[iSectionIndex - 1].VirtualAddress + pNewSectHead[iSectionIndex - 1].Misc.VirtualSize, pNewNTHead->OptionalHeader.SectionAlignment);
					pNewSectHead[iSectionIndex].PointerToRawData = Align(pNewSectHead[iSectionIndex - 1].PointerToRawData + pNewSectHead[iSectionIndex - 1].SizeOfRawData, pNewNTHead->OptionalHeader.FileAlignment);
				}
				else
				{
					pNewSectHead[iSectionIndex].VirtualAddress = 0x1000;
					pNewSectHead[iSectionIndex].PointerToRawData = 0x400;
				}


				memset((void*)(pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData), 0, pNewSectHead[iSectionIndex].SizeOfRawData);
				memcpy((void*)(pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData), (void*)(pChOldDos + pOldSectHead[old_index].PointerToRawData), pNewSectHead[iSectionIndex].SizeOfRawData);
			}
			else if (iSectionIndex >= old_index && iSectionIndex < new_index)
			{
				strcpy((char*)pNewSectHead[iSectionIndex].Name, (char*)pOldSectHead[iSectionIndex + 1].Name);
				pNewSectHead[iSectionIndex].Misc.PhysicalAddress = pOldSectHead[iSectionIndex + 1].Misc.PhysicalAddress;
				pNewSectHead[iSectionIndex].Misc.VirtualSize = pOldSectHead[iSectionIndex + 1].Misc.PhysicalAddress;
				pNewSectHead[iSectionIndex].SizeOfRawData = pOldSectHead[iSectionIndex + 1].SizeOfRawData;
				pNewSectHead[iSectionIndex].PointerToRelocations = pOldSectHead[iSectionIndex + 1].PointerToRelocations;
				pNewSectHead[iSectionIndex].PointerToLinenumbers = pOldSectHead[iSectionIndex + 1].PointerToLinenumbers;
				pNewSectHead[iSectionIndex].NumberOfRelocations = pOldSectHead[iSectionIndex + 1].NumberOfRelocations;
				pNewSectHead[iSectionIndex].NumberOfLinenumbers = pOldSectHead[iSectionIndex + 1].NumberOfLinenumbers;
				pNewSectHead[iSectionIndex].Characteristics = pOldSectHead[iSectionIndex + 1].Characteristics;
				if (iSectionIndex > 0)
				{
					pNewSectHead[iSectionIndex].VirtualAddress = Align(pNewSectHead[iSectionIndex - 1].VirtualAddress + pNewSectHead[iSectionIndex - 1].Misc.VirtualSize, pNewNTHead->OptionalHeader.SectionAlignment);
					pNewSectHead[iSectionIndex].PointerToRawData = Align(pNewSectHead[iSectionIndex - 1].PointerToRawData + pNewSectHead[iSectionIndex - 1].SizeOfRawData, pNewNTHead->OptionalHeader.FileAlignment);
				}
				else
				{
					pNewSectHead[iSectionIndex].VirtualAddress = 0x1000;
					pNewSectHead[iSectionIndex].PointerToRawData = 0x400;
				}

				memset((void*)(pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData), 0, pNewSectHead[iSectionIndex].SizeOfRawData);
				memcpy((void*)(pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData), (void*)(pChOldDos + pOldSectHead[iSectionIndex + 1].PointerToRawData), pNewSectHead[iSectionIndex].SizeOfRawData);
			}
			else if (iSectionIndex > new_index)
			{
				pNewSectHead[iSectionIndex].VirtualAddress = Align(pNewSectHead[iSectionIndex - 1].VirtualAddress + pNewSectHead[iSectionIndex - 1].Misc.VirtualSize, pNewNTHead->OptionalHeader.SectionAlignment);
				pNewSectHead[iSectionIndex].PointerToRawData = Align(pNewSectHead[iSectionIndex - 1].PointerToRawData + pNewSectHead[iSectionIndex - 1].SizeOfRawData, pNewNTHead->OptionalHeader.FileAlignment);

				memset((void*)(pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData), 0, pNewSectHead[iSectionIndex].SizeOfRawData);
				memcpy((void*)(pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData), (void*)(pChOldDos + pOldSectHead[iSectionIndex].PointerToRawData), pNewSectHead[iSectionIndex].SizeOfRawData);
			}
		}
	}
}

void FixDataDirectory(char *pChOldDos, char *pChNewDos)
{
	//old
	IMAGE_DOS_HEADER *pOldDos = (IMAGE_DOS_HEADER*)pChOldDos;
	IMAGE_NT_HEADERS *pOldNTHead = (IMAGE_NT_HEADERS*)((char*)pChOldDos + pOldDos->e_lfanew);
	DWORD dwOldFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pOldNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pOldSectHead = (IMAGE_SECTION_HEADER*)((char*)pOldNTHead + dwOldFullNTSize);

	//new
	IMAGE_DOS_HEADER *pNewDos = (IMAGE_DOS_HEADER*)pChNewDos;
	IMAGE_NT_HEADERS *pNewNTHead = (IMAGE_NT_HEADERS*)((char*)pChNewDos + pNewDos->e_lfanew);
	DWORD dwNewFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pNewNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pNewSectHead = (IMAGE_SECTION_HEADER*)((char*)pNewNTHead + dwNewFullNTSize);

	int iSectionIndex;
	DWORD delta;
	for (int iDataDirectory = 0; iDataDirectory < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; iDataDirectory++)
	{
		IMAGE_DATA_DIRECTORY *imgNew = &pNewNTHead->OptionalHeader.DataDirectory[iDataDirectory];
		if (imgNew->VirtualAddress != 0)
		{
			iSectionIndex = FindSectionByVirAddr(imgNew->VirtualAddress, pOldNTHead, pOldSectHead);
			delta = imgNew->VirtualAddress - pOldSectHead[iSectionIndex].VirtualAddress;
			iSectionIndex = FindSectionByName(FindSectionNameByIndex(iSectionIndex, pOldNTHead, pOldSectHead), pNewNTHead, pNewSectHead);
			imgNew->VirtualAddress = pNewSectHead[iSectionIndex].VirtualAddress + delta;
		}
	}
}

void FixReloc(char *pChOldDos, char *pChNewDos)
{
	//old
	IMAGE_DOS_HEADER *pOldDos = (IMAGE_DOS_HEADER*)pChOldDos;
	IMAGE_NT_HEADERS *pOldNTHead = (IMAGE_NT_HEADERS*)((char*)pChOldDos + pOldDos->e_lfanew);
	DWORD dwOldFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pOldNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pOldSectHead = (IMAGE_SECTION_HEADER*)((char*)pOldNTHead + dwOldFullNTSize);

	//new
	IMAGE_DOS_HEADER *pNewDos = (IMAGE_DOS_HEADER*)pChNewDos;
	IMAGE_NT_HEADERS *pNewNTHead = (IMAGE_NT_HEADERS*)((char*)pChNewDos + pNewDos->e_lfanew);
	DWORD dwNewFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pNewNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pNewSectHead = (IMAGE_SECTION_HEADER*)((char*)pNewNTHead + dwNewFullNTSize);

	IMAGE_DATA_DIRECTORY imgNewDirRelocation = pNewNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	int iSectionIndex = FindSectionByVirAddr(imgNewDirRelocation.VirtualAddress, pNewNTHead, pNewSectHead);
	int remainSize = imgNewDirRelocation.Size;
	IMAGE_BASE_RELOCATION *pNewBaseReloc = (IMAGE_BASE_RELOCATION*)((unsigned char *)pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData + (imgNewDirRelocation.VirtualAddress - pNewSectHead[iSectionIndex].VirtualAddress));

	DWORD delta;
	int iOldSection;
	int iNewSection;
	bool ret = true;
	while (remainSize > 0 && ret)
	{
		iOldSection = FindSectionByVirAddr(pNewBaseReloc[0].VirtualAddress, pOldNTHead, pOldSectHead);
		delta = pNewBaseReloc[0].VirtualAddress - pOldSectHead[iOldSection].VirtualAddress;
		iNewSection = FindSectionByName(FindSectionNameByIndex(iOldSection, pOldNTHead, pOldSectHead), pNewNTHead, pNewSectHead);
		pNewBaseReloc[0].VirtualAddress = pNewSectHead[iNewSection].VirtualAddress + delta;


		WORD *arrRel = (WORD *)&pNewBaseReloc[1];
		int nRel = (pNewBaseReloc[0].SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
		iSectionIndex = FindSectionByVirAddr(pNewBaseReloc[0].VirtualAddress, pNewNTHead, pNewSectHead);
		char *dest = (char*)pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData + (pNewBaseReloc[0].VirtualAddress - pNewSectHead[iSectionIndex].VirtualAddress);

		for (int i = 0; i < nRel; ++i)
		{
			DWORD *patchAddrHL;
#ifdef _WIN64
			ULONGLONG *patchAddr64;
#endif
			int offset = arrRel[i] & 0xfff;
			switch (arrRel[i] >> 12)
			{
			case IMAGE_REL_BASED_ABSOLUTE:
				// skip relocation
				break;

			case IMAGE_REL_BASED_HIGHLOW:
				// change complete 32 bit address
				patchAddrHL = (DWORD *)(dest + offset);
				//if (iSectionIndex >= index)
				//*patchAddrHL += (DWORD)delta;

				iOldSection = FindSectionByVirAddr(*patchAddrHL - pNewNTHead->OptionalHeader.ImageBase, pOldNTHead, pOldSectHead);
				delta = (*patchAddrHL - pNewNTHead->OptionalHeader.ImageBase) - pOldSectHead[iOldSection].VirtualAddress;
				iNewSection = FindSectionByName(FindSectionNameByIndex(iOldSection, pOldNTHead, pOldSectHead), pNewNTHead, pNewSectHead);
				*patchAddrHL = pNewNTHead->OptionalHeader.ImageBase + pNewSectHead[iNewSection].VirtualAddress + delta;

				break;

#ifdef _WIN64
			case IMAGE_REL_BASED_DIR64:
				patchAddr64 = (ULONGLONG *)(dest + offset);
				*patchAddr64 += delta;
				break;
#endif

			default:
				ret = false;
				break;
			}
		}


		if (ret)
		{
			remainSize -= pNewBaseReloc[0].SizeOfBlock;
			pNewBaseReloc = (IMAGE_BASE_RELOCATION *)((char*)pNewBaseReloc + pNewBaseReloc[0].SizeOfBlock);
		}
	}
}

void FixImport(char *pChOldDos, char *pChNewDos)
{
	//old
	IMAGE_DOS_HEADER *pOldDos = (IMAGE_DOS_HEADER*)pChOldDos;
	IMAGE_NT_HEADERS *pOldNTHead = (IMAGE_NT_HEADERS*)((char*)pChOldDos + pOldDos->e_lfanew);
	DWORD dwOldFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pOldNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pOldSectHead = (IMAGE_SECTION_HEADER*)((char*)pOldNTHead + dwOldFullNTSize);

	//new
	IMAGE_DOS_HEADER *pNewDos = (IMAGE_DOS_HEADER*)pChNewDos;
	IMAGE_NT_HEADERS *pNewNTHead = (IMAGE_NT_HEADERS*)((char*)pChNewDos + pNewDos->e_lfanew);
	DWORD dwNewFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pNewNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pNewSectHead = (IMAGE_SECTION_HEADER*)((char*)pNewNTHead + dwNewFullNTSize);

	DWORD delta;
	IMAGE_DATA_DIRECTORY imgNewDirImport = pNewNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	if (imgNewDirImport.VirtualAddress)
	{
		int iSectionIndex = FindSectionByVirAddr(imgNewDirImport.VirtualAddress, pNewNTHead, pNewSectHead);
		IMAGE_IMPORT_DESCRIPTOR *pNewImportDesc = (IMAGE_IMPORT_DESCRIPTOR*)(pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData + (imgNewDirImport.VirtualAddress - pNewSectHead[iSectionIndex].VirtualAddress));

		while (pNewImportDesc[0].Name)
		{
			int iOldSection = FindSectionByVirAddr(pNewImportDesc[0].Name, pOldNTHead, pOldSectHead);
			int iNewSection = FindSectionByName(FindSectionNameByIndex(iOldSection, pOldNTHead, pOldSectHead), pNewNTHead, pNewSectHead);

			if (pNewImportDesc[0].Characteristics)
			{
				delta = pNewImportDesc[0].Characteristics - pOldSectHead[iOldSection].VirtualAddress;
				pNewImportDesc[0].Characteristics = pNewSectHead[iNewSection].VirtualAddress + delta;
			}
			if (pNewImportDesc[0].FirstThunk)
			{
				delta = pNewImportDesc[0].FirstThunk - pOldSectHead[iOldSection].VirtualAddress;
				pNewImportDesc[0].FirstThunk = pNewSectHead[iNewSection].VirtualAddress + delta;
			}
			if (pNewImportDesc[0].ForwarderChain)
			{
				delta = pNewImportDesc[0].ForwarderChain - pOldSectHead[iOldSection].VirtualAddress;
				pNewImportDesc[0].ForwarderChain = pNewSectHead[iNewSection].VirtualAddress + delta;
			}
			if (pNewImportDesc[0].Name)
			{
				delta = pNewImportDesc[0].Name - pOldSectHead[iOldSection].VirtualAddress;
				pNewImportDesc[0].Name = pNewSectHead[iNewSection].VirtualAddress + delta;
			}
			if (pNewImportDesc[0].TimeDateStamp)
			{
				delta = pNewImportDesc[0].TimeDateStamp - pOldSectHead[iOldSection].VirtualAddress;
				pNewImportDesc[0].TimeDateStamp = pNewSectHead[iNewSection].VirtualAddress + delta;
			}

			POINTER_TYPE *thunkRef;
			FARPROC *funcRef;
			if (pNewImportDesc[0].OriginalFirstThunk) {
				int iSection = FindSectionByVirAddr(pNewImportDesc[0].OriginalFirstThunk, pNewNTHead, pNewSectHead);
				thunkRef = (POINTER_TYPE *)(pChNewDos + pNewSectHead[iSection].PointerToRawData + (pNewImportDesc[0].OriginalFirstThunk - pNewSectHead[iSection].VirtualAddress));
				funcRef = (FARPROC *)(pChNewDos + pNewSectHead[iSection].PointerToRawData + (pNewImportDesc[0].FirstThunk - pNewSectHead[iSection].VirtualAddress));
			}
			else {
				// no hint table
				int iSection = FindSectionByVirAddr(pNewImportDesc[0].FirstThunk, pNewNTHead, pNewSectHead);
				thunkRef = (POINTER_TYPE *)(pChNewDos + pNewSectHead[iSection].PointerToRawData + (pNewImportDesc[0].FirstThunk - pNewSectHead[iSection].VirtualAddress));
				funcRef = (FARPROC *)(pChNewDos + pNewSectHead[iSection].PointerToRawData + (pNewImportDesc[0].FirstThunk - pNewSectHead[iSection].VirtualAddress));
			}

			for (; *thunkRef; thunkRef++, funcRef++)
			{
				iOldSection = FindSectionByVirAddr(*thunkRef, pOldNTHead, pOldSectHead);
				delta = *thunkRef - pOldSectHead[iOldSection].VirtualAddress;
				iNewSection = FindSectionByName(FindSectionNameByIndex(iOldSection, pOldNTHead, pOldSectHead), pNewNTHead, pNewSectHead);
				*thunkRef = pNewSectHead[iNewSection].VirtualAddress + delta;

				iOldSection = FindSectionByVirAddr((POINTER_TYPE)(*funcRef), pOldNTHead, pOldSectHead);
				delta = (POINTER_TYPE)(*funcRef) - pOldSectHead[iOldSection].VirtualAddress;
				iNewSection = FindSectionByName(FindSectionNameByIndex(iOldSection, pOldNTHead, pOldSectHead), pNewNTHead, pNewSectHead);
				*funcRef = (FARPROC)(pNewSectHead[iNewSection].VirtualAddress + delta);
			}

			pNewImportDesc++;
		}
	}
}

char *MoveSection(const void *pImg, DWORD sztImg, int old_index, int new_index)
{
	//old
	const IMAGE_DOS_HEADER *pOldDos = (const IMAGE_DOS_HEADER*)pImg;
	char *pChOldDos = (char*)pImg;
	IMAGE_NT_HEADERS *pOldNTHead = (IMAGE_NT_HEADERS*)((char*)pChOldDos + pOldDos->e_lfanew);
	DWORD dwOldFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pOldNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pOldSectHead = (IMAGE_SECTION_HEADER*)((char*)pOldNTHead + dwOldFullNTSize);

	//new
	char *pChNewDos = (char*)calloc(sztImg, 1);
	memcpy(pChNewDos, pChOldDos, sztImg);

	const IMAGE_DOS_HEADER *pNewDos = (const IMAGE_DOS_HEADER*)pChNewDos;

	IMAGE_NT_HEADERS *pNewNTHead = (IMAGE_NT_HEADERS*)((char*)pChNewDos + pNewDos->e_lfanew);
	DWORD dwNewFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pNewNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pNewSectHead = (IMAGE_SECTION_HEADER*)((char*)pNewNTHead + dwNewFullNTSize);

	//Fix Section
	Move_FixSection(pChOldDos, pChNewDos, old_index, new_index);
	
	int iOldSection;
	int iNewSection;
	DWORD delta;
	//fix AddressOfEntrypoint
	iOldSection = FindSectionByVirAddr(pOldNTHead->OptionalHeader.AddressOfEntryPoint, pOldNTHead, pOldSectHead);
	delta = pOldNTHead->OptionalHeader.AddressOfEntryPoint - pOldSectHead[iOldSection].VirtualAddress;
	iNewSection = FindSectionByName(FindSectionNameByIndex(iOldSection, pOldNTHead, pOldSectHead), pNewNTHead, pNewSectHead);
	pNewNTHead->OptionalHeader.AddressOfEntryPoint = pNewSectHead[iNewSection].VirtualAddress + delta;

	//fix BaseOfCode
	iOldSection = FindSectionByVirAddr(pOldNTHead->OptionalHeader.BaseOfCode, pOldNTHead, pOldSectHead);
	delta = pOldNTHead->OptionalHeader.BaseOfCode - pOldSectHead[iOldSection].VirtualAddress;
	iNewSection = FindSectionByName(FindSectionNameByIndex(iOldSection, pOldNTHead, pOldSectHead), pNewNTHead, pNewSectHead);
	pNewNTHead->OptionalHeader.BaseOfCode = pNewSectHead[iNewSection].VirtualAddress + delta;

	//fix BaseOfData
	iOldSection = FindSectionByVirAddr(pOldNTHead->OptionalHeader.BaseOfData, pOldNTHead, pOldSectHead);
	delta = pOldNTHead->OptionalHeader.BaseOfData - pOldSectHead[iOldSection].VirtualAddress;
	iNewSection = FindSectionByName(FindSectionNameByIndex(iOldSection, pOldNTHead, pOldSectHead), pNewNTHead, pNewSectHead);
	pNewNTHead->OptionalHeader.BaseOfData = pNewSectHead[iNewSection].VirtualAddress + delta;

	//fix Data Directories
	FixDataDirectory(pChOldDos, pChNewDos);

	//fix basereloc
	FixReloc(pChOldDos, pChNewDos);

	//fix import table
	FixImport(pChOldDos, pChNewDos);

	return pChNewDos;
}

void Expand_FixSection(char *pChOldDos, char *pChNewDos, void *Data, DWORD dwData, int index)
{
	//old
	IMAGE_DOS_HEADER *pOldDos = (IMAGE_DOS_HEADER*)pChOldDos;
	IMAGE_NT_HEADERS *pOldNTHead = (IMAGE_NT_HEADERS*)((char*)pChOldDos + pOldDos->e_lfanew);
	DWORD dwOldFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pOldNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pOldSectHead = (IMAGE_SECTION_HEADER*)((char*)pOldNTHead + dwOldFullNTSize);

	//new
	IMAGE_DOS_HEADER *pNewDos = (IMAGE_DOS_HEADER*)pChNewDos;
	IMAGE_NT_HEADERS *pNewNTHead = (IMAGE_NT_HEADERS*)((char*)pChNewDos + pNewDos->e_lfanew);
	DWORD dwNewFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pNewNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pNewSectHead = (IMAGE_SECTION_HEADER*)((char*)pNewNTHead + dwNewFullNTSize);

	//fix
	pNewSectHead[index].Misc.VirtualSize = pNewSectHead[index].Misc.VirtualSize + dwData;
	pNewSectHead[index].SizeOfRawData = pNewSectHead[index].SizeOfRawData + Align(dwData, pNewNTHead->OptionalHeader.FileAlignment);

	memset((void*)(pChNewDos + pNewSectHead[index].PointerToRawData + pNewSectHead[index].SizeOfRawData - Align(dwData, pNewNTHead->OptionalHeader.FileAlignment)), 0, Align(dwData, pNewNTHead->OptionalHeader.FileAlignment));
	memcpy((void*)(pChNewDos + pNewSectHead[index].PointerToRawData + pNewSectHead[index].SizeOfRawData - Align(dwData, pNewNTHead->OptionalHeader.FileAlignment)), Data, dwData);

	int iSectionIndex;
	for (iSectionIndex = index + 1; iSectionIndex < pNewNTHead->FileHeader.NumberOfSections; iSectionIndex++)
	{
		pNewSectHead[iSectionIndex].VirtualAddress = Align(pNewSectHead[iSectionIndex - 1].VirtualAddress + pNewSectHead[iSectionIndex - 1].Misc.VirtualSize, pNewNTHead->OptionalHeader.SectionAlignment);
		pNewSectHead[iSectionIndex].PointerToRawData = Align(pNewSectHead[iSectionIndex - 1].PointerToRawData + pNewSectHead[iSectionIndex - 1].SizeOfRawData, pNewNTHead->OptionalHeader.FileAlignment);

		memset((void*)(pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData), 0, pOldSectHead[iSectionIndex].SizeOfRawData);
		memcpy((void*)(pChNewDos + pNewSectHead[iSectionIndex].PointerToRawData), (void*)(pChOldDos + pOldSectHead[iSectionIndex].PointerToRawData), pOldSectHead[iSectionIndex].SizeOfRawData);
	}
}

char *ExpandSection(const void *pImg, DWORD &sztImg, void *Data, DWORD dwData, int index)
{
	//old
	const IMAGE_DOS_HEADER *pOldDos = (const IMAGE_DOS_HEADER*)pImg;
	char *pChOldDos = (char*)pImg;
	IMAGE_NT_HEADERS *pOldNTHead = (IMAGE_NT_HEADERS*)((char*)pChOldDos + pOldDos->e_lfanew);
	DWORD dwOldFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pOldNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pOldSectHead = (IMAGE_SECTION_HEADER*)((char*)pOldNTHead + dwOldFullNTSize);

	//new
	char *pChNewDos = (char*)calloc(sztImg + Align(dwData, pOldNTHead->OptionalHeader.FileAlignment), 1);
	memcpy(pChNewDos, pChOldDos, sztImg);
	sztImg = sztImg + Align(dwData, pOldNTHead->OptionalHeader.FileAlignment);

	const IMAGE_DOS_HEADER *pNewDos = (const IMAGE_DOS_HEADER*)pChNewDos;

	IMAGE_NT_HEADERS *pNewNTHead = (IMAGE_NT_HEADERS*)((char*)pChNewDos + pNewDos->e_lfanew);
	DWORD dwNewFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pNewNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pNewSectHead = (IMAGE_SECTION_HEADER*)((char*)pNewNTHead + dwNewFullNTSize);

	//Fix Section
	Expand_FixSection(pChOldDos, pChNewDos, Data, dwData, index);

	//Fix SizeOfImage
	pNewNTHead->OptionalHeader.SizeOfImage = pNewSectHead[pNewNTHead->FileHeader.NumberOfSections - 1].VirtualAddress + Align(pNewSectHead[pNewNTHead->FileHeader.NumberOfSections - 1].Misc.VirtualSize, pNewNTHead->OptionalHeader.SectionAlignment);

	int iOldSection;
	int iNewSection;
	DWORD delta;
	//fix AddressOfEntrypoint
	iOldSection = FindSectionByVirAddr(pOldNTHead->OptionalHeader.AddressOfEntryPoint, pOldNTHead, pOldSectHead);
	delta = pOldNTHead->OptionalHeader.AddressOfEntryPoint - pOldSectHead[iOldSection].VirtualAddress;
	iNewSection = FindSectionByName(FindSectionNameByIndex(iOldSection, pOldNTHead, pOldSectHead), pNewNTHead, pNewSectHead);
	pNewNTHead->OptionalHeader.AddressOfEntryPoint = pNewSectHead[iNewSection].VirtualAddress + delta;

	//fix BaseOfCode
	iOldSection = FindSectionByVirAddr(pOldNTHead->OptionalHeader.BaseOfCode, pOldNTHead, pOldSectHead);
	delta = pOldNTHead->OptionalHeader.BaseOfCode - pOldSectHead[iOldSection].VirtualAddress;
	iNewSection = FindSectionByName(FindSectionNameByIndex(iOldSection, pOldNTHead, pOldSectHead), pNewNTHead, pNewSectHead);
	pNewNTHead->OptionalHeader.BaseOfCode = pNewSectHead[iNewSection].VirtualAddress + delta;

	//fix BaseOfData
	iOldSection = FindSectionByVirAddr(pOldNTHead->OptionalHeader.BaseOfData, pOldNTHead, pOldSectHead);
	delta = pOldNTHead->OptionalHeader.BaseOfData - pOldSectHead[iOldSection].VirtualAddress;
	iNewSection = FindSectionByName(FindSectionNameByIndex(iOldSection, pOldNTHead, pOldSectHead), pNewNTHead, pNewSectHead);
	pNewNTHead->OptionalHeader.BaseOfData = pNewSectHead[iNewSection].VirtualAddress + delta;

	//fix Data Directories
	FixDataDirectory(pChOldDos, pChNewDos);

	//fix basereloc
	FixReloc(pChOldDos, pChNewDos);

	//fix import table
	FixImport(pChOldDos, pChNewDos);

	return pChNewDos;
}

	
