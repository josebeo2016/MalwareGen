#include "CryptoAPI.h"
#include <Wincrypt.h>


BYTE *AES_Encrypt(BYTE *buf, DWORD &dwSize, std::string Password)
{
	HCRYPTPROV hProv;
	HCRYPTHASH hHash;
	HCRYPTKEY hKey;
	BYTE *block = NULL;
	BYTE *enc_buf = NULL;
	int BLOCK_SIZE = 16;//for AES_256

	block = (BYTE*)calloc(BLOCK_SIZE, 1);
	if (buf)
	{
		if (CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
		{
			if (CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))
			{
				if (CryptHashData(hHash, (BYTE*)Password.c_str(), Password.length(), 0))
				{
					if (CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &hKey))
					{
						DWORD dwNumberOfBlock = (dwSize / BLOCK_SIZE) + 1;

						enc_buf = (BYTE *)calloc(dwNumberOfBlock*BLOCK_SIZE + 1, 1);
						if (enc_buf)
						{
							BOOL bFinal = FALSE;
							DWORD out_len = BLOCK_SIZE;
							DWORD dwNewSize = 0;
							for (int i = 0; i < dwNumberOfBlock; i++)
							{
								if (i == dwNumberOfBlock - 1)
								{
									bFinal = TRUE;
									if (dwSize < (dwNumberOfBlock*BLOCK_SIZE))
										out_len = dwSize - (i*BLOCK_SIZE);
									//printf("%d\n", out_len);
								}

								memcpy(block, buf + i*BLOCK_SIZE, out_len);
								if (CryptEncrypt(hKey, NULL, bFinal, 0, block, &out_len, BLOCK_SIZE))
								{
									dwNewSize += out_len;
									memcpy(enc_buf + i*BLOCK_SIZE, block, out_len);
									memset(block, 0, BLOCK_SIZE);
								}
								else
								{
									printf("CryptEncrypt failed %d", GetLastError());
									free(enc_buf);
									enc_buf = NULL;
									break;
								}
							}
							dwSize = dwNewSize;
						}
						else
							printf("calloc failed");

						CryptDestroyKey(hKey);
					}
					else
						printf("CryptDeriveKey failed");
				}
				else
					printf("CryptHashData failed");

				CryptDestroyHash(hHash);
			}
			else
				printf("CryptCreateHash failed");

			CryptReleaseContext(hProv, 0);
		}
		else
			printf("CryptAcquireContextW failed");

		free(block);
	}
	else
		printf("calloc failed");

	return enc_buf;
}

BYTE *AES_Decrypt(BYTE *buf, DWORD &dwSize, std::string Password)
{
	HCRYPTPROV hProv;
	HCRYPTHASH hHash;
	HCRYPTKEY hKey;
	BYTE *block = NULL;
	BYTE *dec_buf = NULL;
	int BLOCK_SIZE = 16;//for AES_256

	block = (BYTE*)calloc(BLOCK_SIZE, 1);
	if (buf)
	{
		if (CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
		{
			if (CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))
			{
				if (CryptHashData(hHash, (BYTE*)Password.c_str(), Password.length(), 0))
				{
					if (CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &hKey))
					{
						DWORD dwNumberOfBlock = dwSize / BLOCK_SIZE;
						if (dwSize % BLOCK_SIZE != 0)
							dwNumberOfBlock = (dwSize / BLOCK_SIZE) + 1;

						dec_buf = (BYTE *)calloc(dwNumberOfBlock*BLOCK_SIZE + 1, 1);
						if (dec_buf)
						{
							BOOL bFinal = FALSE;
							DWORD out_len = BLOCK_SIZE;
							DWORD dwNewSize = 0;
							for (int i = 0; i < dwNumberOfBlock; i++)
							{
								if (i == dwNumberOfBlock - 1)
								{
									bFinal = TRUE;
									if (dwSize < (dwNumberOfBlock*BLOCK_SIZE))
										out_len = dwSize - (i*BLOCK_SIZE);
									//printf("%d\n", out_len);
								}

								memcpy(block, buf + i*BLOCK_SIZE, out_len);
								if (CryptDecrypt(hKey, NULL, bFinal, 0, block, &out_len))
								{
									dwNewSize += out_len;
									memcpy(dec_buf + i*BLOCK_SIZE, block, out_len);
									memset(block, 0, BLOCK_SIZE);
								}
								else
								{
									printf("CryptEncrypt failed %d", GetLastError());
									free(dec_buf);
									dec_buf = NULL;
									break;
								}
							}
							dwSize = dwNewSize;
						}
						else
							printf("calloc failed");

						CryptDestroyKey(hKey);
					}
					else
						printf("CryptDeriveKey failed");
				}
				else
					printf("CryptHashData failed");

				CryptDestroyHash(hHash);
			}
			else
				printf("CryptCreateHash failed");

			CryptReleaseContext(hProv, 0);
		}
		else
			printf("CryptAcquireContextW failed");

		free(block);
	}
	else
		printf("calloc failed");

	return dec_buf;
}

char *hash(char *data, DWORD len)
{
	char *ret = (char*)calloc(33, 1);
	if (ret)
	{
		HCRYPTPROV hProv;
		HCRYPTHASH hHash;
		if (CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
		{
			if (CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))
			{
				if (CryptHashData(hHash, (BYTE*)data, len, 0))
				{
					DWORD cbHash = 32;
					if (CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)ret, &cbHash, 0))
						return ret;
				}
				CryptDestroyHash(hHash);
			}
			CryptReleaseContext(hProv, 0);
		}
	}


	return NULL;
}