#include "VMWare.h"

/*
Check against VMWare registry key values
*/
VOID vmware_reg_key_value()
{
	/* Array of strings of blacklisted registry key values */
	char *szEntries[][3] = {
		{ "HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0", "Identifier", "VMWARE" },
		{ "HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 1\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0", "Identifier", "VMWARE" },
		{ "HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 2\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0", "Identifier", "VMWARE" },
		{ "SYSTEM\\ControlSet001\\Control\\SystemInformation", "SystemManufacturer", "VMWARE" },
		{ "SYSTEM\\ControlSet001\\Control\\SystemInformation", "SystemProductName", "VMWARE" }
	};

	WORD dwLength = sizeof(szEntries) / sizeof(szEntries[0]);

	for (int i = 0; i < dwLength; i++)
	{
		if (Is_RegKeyValueExists(HKEY_LOCAL_MACHINE, szEntries[i][0], szEntries[i][1], szEntries[i][2]))
			exit(1);
	}
}



/*
Check against VMWare registry keys
*/
VOID vmware_reg_keys()
{
	/* Array of strings of blacklisted registry keys */
	char* szKeys[] = {
		"SOFTWARE\\VMware, Inc.\\VMware Tools"
	};

	WORD dwlength = sizeof(szKeys) / sizeof(szKeys[0]);

	/* Check one by one */
	for (int i = 0; i < dwlength; i++)
	{
		if (Is_RegKeyExists(HKEY_LOCAL_MACHINE, szKeys[i]))
			exit(1);
	}
}


/*
Check against VMWare blacklisted files
*/
VOID vmware_files()
{
	/* Array of strings of blacklisted paths */
	char* szPaths[] = {
		"system32\\drivers\\vmmouse.sys",
		"system32\\drivers\\vmhgfs.sys",
		"system32\\drivers\\vm3dmp.sys",
		"system32\\drivers\\vmci.sys",
		"system32\\drivers\\vmhgfs.sys",
		"system32\\drivers\\vmmemctl.sys",
		"system32\\drivers\\vmmouse.sys",
		"system32\\drivers\\vmrawdsk.sys",
		"system32\\drivers\\vmusbmouse.sys"
	};

	/* Getting Windows Directory */
	WORD dwlength = sizeof(szPaths) / sizeof(szPaths[0]);
	TCHAR szWinDir[MAX_PATH] = "";
	TCHAR szPath[MAX_PATH] = "";
	GetWindowsDirectory(szWinDir, MAX_PATH);

	/* Check one by one */
	for (int i = 0; i < dwlength; i++)
	{
		PathCombine(szPath, szWinDir, szPaths[i]);
		if (is_FileExists(szPath))
			exit(1);
	}
}

/*
Check against VMWare blacklisted directories
*/
BOOL vmware_dir()
{
	TCHAR szProgramFile[MAX_PATH];
	char szPath[MAX_PATH] = "";
	char szTarget[MAX_PATH] = "VMWare\\";

	if (IsWoW64())
		ExpandEnvironmentStrings("%ProgramW6432%", szProgramFile, ARRAYSIZE(szProgramFile));
	else
		SHGetSpecialFolderPath(NULL, szProgramFile, CSIDL_PROGRAM_FILES, FALSE);

	PathCombine(szPath, szProgramFile, szTarget);
	return is_DirectoryExists(szPath);
}


/*
Check VMWare NIC MAC addresses
*/
VOID vmware_mac()
{
	/* VMWre blacklisted mac adr */
	char *szMac[][2] = {
		{"\x00\x05\x69", "00:05:69" }, // VMWare, Inc.
		{"\x00\x0C\x29", "00:0c:29" }, // VMWare, Inc.
		{"\x00\x1C\x14", "00:1C:14" }, // VMWare, Inc.
		{"\x00\x50\x56", "00:50:56" }	// VMWare, Inc.
	};

	WORD dwLength = sizeof(szMac) / sizeof(szMac[0]);

	/* Check one by one */
	for (int i = 0; i < dwLength; i++)
	{
		if (check_mac_addr(szMac[i][0]))
			exit(1);
	}
}


/*
Check against VMWare adapter name
*/
BOOL vmware_adapter_name()
{
	char* szAdapterName = "VMWare";
	if (check_adapter_name(szAdapterName))
		return TRUE;
	else
		return FALSE;
}


/*
Check against VMWare pseaudo-devices
*/
VOID vmware_devices()
{
	char *devices[] = {
		"\\\\.\\HGFS",
		"\\\\.\\vmci"
	};

	WORD iLength = sizeof(devices) / sizeof(devices[0]);
	for (int i = 0; i < iLength; i++)
	{
		HANDLE hFile = CreateFile(devices[i], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

		if (hFile != INVALID_HANDLE_VALUE)
			exit(1);
	}
}


/*
Check for process list
*/

VOID vmware_processes()
{
	char *szProcesses[] = {
		"vmtoolsd.exe",
		"vmwaretray.exe",
		"vmwareuser.exe",
		"VGAuthService.exe",
		"vmacthlp.exe"
	};

	WORD iLength = sizeof(szProcesses) / sizeof(szProcesses[0]);
	for (int i = 0; i < iLength; i++)
	{
		if (GetProcessIdFromName(szProcesses[i]))
			exit(1);
	}
}

/*
Check for SMBIOS firmware
*/
BOOL vmware_firmware_SMBIOS()
{
	BOOL result = FALSE;
	const DWORD Signature = static_cast<DWORD>('RSMB');

	DWORD smbiosSize = 0;
	PBYTE smbios = get_system_firmware(static_cast<DWORD>('RSMB'), 0x0000, &smbiosSize);
	if (smbios != NULL)
	{
		PBYTE vmwareString = (PBYTE)"VMware";
		size_t vmwwareStringLen = 6;

		if (find_str_in_data(vmwareString, vmwwareStringLen, smbios, smbiosSize))
		{
			result = TRUE;
		}

		free(smbios);
	}

	return result;
}

/*
Check for ACPI firmware
*/
BOOL vmware_firmware_ACPI()
{
	BOOL result = FALSE;

	PDWORD tableNames = static_cast<PDWORD>(malloc(4096));
	SecureZeroMemory(tableNames, 4096);
	DWORD tableSize = EnumSystemFirmwareTables(static_cast<DWORD>('ACPI'), tableNames, 4096);
	DWORD tableCount = tableSize / 4;
	if (tableSize < 4 || tableCount == 0)
		result = TRUE;
	else
	{
		for (DWORD i = 0; i < tableCount; i++) {
			DWORD tableSize = 0;
			PBYTE table = get_system_firmware(static_cast<DWORD>('ACPI'), tableNames[i], &tableSize);

			PBYTE vmwareString = (PBYTE)"VMWARE";
			size_t vmwwareStringLen = 6;


			if (find_str_in_data(vmwareString, vmwwareStringLen, table, tableSize)) {
				result = TRUE;
			}

			free(table);
		}
	}

	free(tableNames);
	return result;
}


