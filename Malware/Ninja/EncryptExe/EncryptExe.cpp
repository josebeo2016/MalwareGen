#include "EncryptExe.h"

size_t FindImageBase() {
#ifndef _WIN64
	size_t ImageBase;
	size_t *AddressFunc = (size_t*)&FindImageBase;

	size_t a = (size_t)AddressFunc & 0xffff0000;
	while (*(WORD*)a != 0x5a4d)
	{
		a = a - 0x10000;
	}
	ImageBase = a;
	return ImageBase;
#elif _WIN32
	size_t ImageBase;
	size_t *AddressFunc = (size_t*)&FindImageBase;

	size_t a = (size_t)AddressFunc & 0xffffffffffff0000;
	while (*(WORD*)a != 0x5a4d)
	{
		a = a - 0x10000;
	}
	ImageBase = a;

	return ImageBase;
#endif
}

void EncryptExe(std::string new_exename)
{
	char ExePath[MAX_PATH];
	GetModuleFileNameA(NULL, ExePath, MAX_PATH);
	char* ExeName = PathFindFileNameA(ExePath);
	char *exe = NULL;
	DWORD dwSize = 0;
	exe = ReadFile(ExePath, dwSize);
	if (exe)
	{
		const IMAGE_DOS_HEADER *pDos = (const IMAGE_DOS_HEADER*)exe;
		char *pChDos = (char*)exe;
		IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)((char*)pChDos + pDos->e_lfanew);
		DWORD dwFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pNTHead->FileHeader.SizeOfOptionalHeader);
		IMAGE_SECTION_HEADER *pSectHead = (IMAGE_SECTION_HEADER*)((char*)pNTHead + dwFullNTSize);


		int NumberOfSection = pNTHead->FileHeader.NumberOfSections;


		SectionData *sData = (SectionData*)(exe + pSectHead[NumberOfSection - 1].PointerToRawData);

		DWORD base_size = sData->buf_size;
		char *base_exe = (char*)AES_Decrypt((BYTE*)sData->buf, base_size, ExeName);
		if (base_exe)
		{
			char *hashdata = hash(base_exe, base_size);
			if (!memcmp(sData->hashdata, hashdata, 32))
			{
				DWORD enc_size = base_size;
				char *enc_exe = (char*)AES_Encrypt((BYTE*)base_exe, enc_size, new_exename);
				if (enc_exe)
				{
					memcpy(sData->buf, enc_exe, enc_size);
					sData->buf_size = enc_size;
				}
			}
		}
		std::string NewExePath = (std::string)ExePath;
		NewExePath = NewExePath.substr(0, NewExePath.find_last_of("\\"));
		NewExePath += "\\" + new_exename;
		WriteFile(NewExePath.c_str(), exe, dwSize);

		free(exe);
	}

}