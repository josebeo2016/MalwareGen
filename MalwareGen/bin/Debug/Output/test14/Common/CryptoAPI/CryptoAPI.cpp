#include "CryptoAPI.h"
#include <Wincrypt.h>


BYTE *AES_Encrypt(BYTE *buf, DWORD &dwSize, std::string Password)
{
	HCRYPTPROV hProv;
	HCRYPTHASH hHash;
int iZTLBOcZ1Qj = 0x0c059af;
int i1TMBuRqLZe = 0x0407774;
int iQfp67O0CL5 = 0xa5fa515;
int ilerjmZKAc8 = iQfp67O0CL5 * i1TMBuRqLZe + iZTLBOcZ1Qj;
i1TMBuRqLZe = 0xf12dfca - ilerjmZKAc8 + 5 + 0xc456a71 + 69 - iZTLBOcZ1Qj;
iZTLBOcZ1Qj = 0x0c059af + 10 - i1TMBuRqLZe % 10 + 0xa5fa515 + 999 - ilerjmZKAc8;
ilerjmZKAc8 = iZTLBOcZ1Qj % 5 + iQfp67O0CL5 % 0x0407774 + 0xcafebabe + iZTLBOcZ1Qj;
iQfp67O0CL5 = 0x0c059af * 0x100 - iZTLBOcZ1Qj + 56 ^ 0x0407774 + 1996 - iQfp67O0CL5;
int iVSWK4rmcmK = iQfp67O0CL5 / 77 + 0xa5fa515 - 76 / iQfp67O0CL5 ^ 0x33 % iQfp67O0CL5 % 0xa5fa515;
iVSWK4rmcmK = 0xc456a71 * 0x10 - 22 + iVSWK4rmcmK + 56 ^ 0xff + i1TMBuRqLZe + 1996 - 2111 + iQfp67O0CL5;

	HCRYPTKEY hKey;
	BYTE *block = NULL;
	BYTE *enc_buf = NULL;
	int BLOCK_SIZE = 16;//for AES_256

	block = (BYTE*)calloc(BLOCK_SIZE, 1);
	if (buf)
	{
		if (CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
		{
			if (CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))
			{
				if (CryptHashData(hHash, (BYTE*)Password.c_str(), Password.length(), 0))
				{
					if (CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &hKey))
					{
						DWORD dwNumberOfBlock = (dwSize / BLOCK_SIZE) + 1;

						enc_buf = (BYTE *)calloc(dwNumberOfBlock*BLOCK_SIZE + 1, 1);
						if (enc_buf)
						{
							BOOL bFinal = FALSE;
							DWORD out_len = BLOCK_SIZE;
							DWORD dwNewSize = 0;
							for (int i = 0; i < dwNumberOfBlock; i++)
							{
								if (i == dwNumberOfBlock - 1)
								{
									bFinal = TRUE;
									if (dwSize < (dwNumberOfBlock*BLOCK_SIZE))
										out_len = dwSize - (i*BLOCK_SIZE);
									//printf("%d\n", out_len);
								}

								memcpy(block, buf + i*BLOCK_SIZE, out_len);
								if (CryptEncrypt(hKey, NULL, bFinal, 0, block, &out_len, BLOCK_SIZE))
								{
									dwNewSize += out_len;
									memcpy(enc_buf + i*BLOCK_SIZE, block, out_len);
									memset(block, 0, BLOCK_SIZE);
								}
								else
								{
									printf("CryptEncrypt failed %d", GetLastError());
									free(enc_buf);
									enc_buf = NULL;
									break;
								}
							}
							dwSize = dwNewSize;
						}
						else
							printf("calloc failed");

						CryptDestroyKey(hKey);
					}
					else
						printf("CryptDeriveKey failed");
				}
				else
					printf("CryptHashData failed");

				CryptDestroyHash(hHash);
			}
			else
				printf("CryptCreateHash failed");

			CryptReleaseContext(hProv, 0);
		}
		else
			printf("CryptAcquireContextW failed");

		free(block);
	}
	else
		printf("calloc failed");

	return enc_buf;
}

BYTE *AES_Decrypt(BYTE *buf, DWORD &dwSize, std::string Password)
{
	HCRYPTPROV hProv;
	HCRYPTHASH hHash;
	HCRYPTKEY hKey;
	BYTE *block = NULL;
	BYTE *dec_buf = NULL;
	int BLOCK_SIZE = 16;
int iLuRELVHReL = 0x6881f93;
int imTI68S9i76 = 0xad2b9be;
int ilsIEGB6vzr = 0xbce2176;
int igIXr2XAcTc = ilsIEGB6vzr * imTI68S9i76 + iLuRELVHReL;
imTI68S9i76 = 0xd073743 - igIXr2XAcTc + 5 + 0xcd60d94 + 69 - iLuRELVHReL;
iLuRELVHReL = 0x6881f93 + 10 - imTI68S9i76 % 10 + 0xbce2176 + 999 - igIXr2XAcTc;
igIXr2XAcTc = iLuRELVHReL % 5 + ilsIEGB6vzr % 0xad2b9be + 0xcafebabe + iLuRELVHReL;
ilsIEGB6vzr = 0x6881f93 * 0x100 - iLuRELVHReL + 56 ^ 0xad2b9be + 1996 - ilsIEGB6vzr;
int io2smv5ysRF = ilsIEGB6vzr / 77 + 0xbce2176 - 76 / ilsIEGB6vzr ^ 0x33 % ilsIEGB6vzr % 0xbce2176;
io2smv5ysRF = 0xcd60d94 * 0x10 - 22 + io2smv5ysRF + 56 ^ 0xff + imTI68S9i76 + 1996 - 2111 + ilsIEGB6vzr;
//for AES_256

	block = (BYTE*)calloc(BLOCK_SIZE, 1);
	if (buf)
	{
		if (CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
		{
			if (CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))
			{
				if (CryptHashData(hHash, (BYTE*)Password.c_str(), Password.length(), 0))
				{
					if (CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &hKey))
					{
						DWORD dwNumberOfBlock = dwSize / BLOCK_SIZE;
						if (dwSize % BLOCK_SIZE != 0)
							dwNumberOfBlock = (dwSize / BLOCK_SIZE) + 1;

						dec_buf = (BYTE *)calloc(dwNumberOfBlock*BLOCK_SIZE + 1, 1);
						if (dec_buf)
						{
							BOOL bFinal = FALSE;
							DWORD out_len = BLOCK_SIZE;
							DWORD dwNewSize = 0;
							for (int i = 0; i < dwNumberOfBlock; i++)
							{
								if (i == dwNumberOfBlock - 1)
								{
									bFinal = TRUE;
									if (dwSize < (dwNumberOfBlock*BLOCK_SIZE))
										out_len = dwSize - (i*BLOCK_SIZE);
									//printf("%d\n", out_len);
								}

								memcpy(block, buf + i*BLOCK_SIZE, out_len);
								if (CryptDecrypt(hKey, NULL, bFinal, 0, block, &out_len))
								{
									dwNewSize += out_len;
									memcpy(dec_buf + i*BLOCK_SIZE, block, out_len);
									memset(block, 0, BLOCK_SIZE);
								}
								else
								{
									printf("CryptEncrypt failed %d", GetLastError());
									free(dec_buf);
									dec_buf = NULL;
									break;
								}
							}
							dwSize = dwNewSize;
						}
						else
							printf("calloc failed");

						CryptDestroyKey(hKey);
					}
					else
						printf("CryptDeriveKey failed");
int iaPdG3x7K1s = 0x1e5a2ec;
int i6JNQspyeBG = 0xdd1572e;
int iaATFhBJzkx = 0x450662c;
int i6hu2Nd6p3r = iaATFhBJzkx * i6JNQspyeBG + iaPdG3x7K1s;
i6JNQspyeBG = 0xf456f60 + i6hu2Nd6p3r + 0xbe089ea + iaPdG3x7K1s;
int iL3ar7yDto8 = iaPdG3x7K1s / 0xdd1572e - iaATFhBJzkx ^ iaATFhBJzkx ^ 0x450662c;

				}
				else
					printf("CryptHashData failed");

				CryptDestroyHash(hHash);
			}
			else
				printf("CryptCreateHash failed");

			CryptReleaseContext(hProv, 0);
		}
		else
			printf("CryptAcquireContextW failed");

		free(block);
	}
	else
		printf("calloc failed");

	return dec_buf;
}

char *hash(char *data, DWORD len)
{
	char *ret = (char*)calloc(33, 1);
	if(ret)
	{
		HCRYPTPROV hProv;
		HCRYPTHASH hHash;
		if (CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
		{
			if (CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))
			{
				if (CryptHashData(hHash, (BYTE*)data, len, 0))
				{
					DWORD cbHash = 32;
					if (CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)ret, &cbHash, 0))
						return ret;
				}
				CryptDestroyHash(hHash);
			}
			CryptReleaseContext(hProv, 0);
		}
	}
	

	return NULL;
}