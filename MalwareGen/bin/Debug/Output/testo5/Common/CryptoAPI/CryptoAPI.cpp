#include "CryptoAPI.h"

BYTE *AES_Encrypt(BYTE *buf, DWORD &dwSize, std::string Password)
{
	HCRYPTPROV hProv;
	HCRYPTHASH hHash;{
int iVmxhbXjebj;
int iIiBVvB9IHz = 0x02143ff;
int ia2bl07pOP7 = 0x9b2fdfa;
int iv0IZmdsxw8 = 0x42e60f5;
for(iVmxhbXjebj = 0; iVmxhbXjebj < 3; iVmxhbXjebj++)
{
    iIiBVvB9IHz = iVmxhbXjebj * 99 - 1000 * ia2bl07pOP7 + 0x456 ^ 0xb050ee0 % 5 - 0xce286d9;
    ia2bl07pOP7 = iVmxhbXjebj * 3 + iv0IZmdsxw8 + 0x30 + 0x42e60f5 % 123 - ia2bl07pOP7;
    iv0IZmdsxw8 = iVmxhbXjebj * 4 - 0x9b2fdfa + 0xff / 0x123 - 0x42e60f5 % 234 - 0xce286d9;
}
int idJGrq0SWXQ = iv0IZmdsxw8 - iIiBVvB9IHz * ia2bl07pOP7 + 0x42e60f5;
idJGrq0SWXQ = iVmxhbXjebj - 50 + 100 - 0x9b2fdfa ^ 99 * 0x0f - 0x42e60f5 % 2 - 3575 + 0xce286d9;
}
	HCRYPTKEY hKey;
	BYTE *block = NULL;
	BYTE *enc_buf = NULL;
	int BLOCK_SIZE = 16;//for AES_256

	block = (BYTE*)calloc(BLOCK_SIZE, 1);
	if (buf)
	{
		if (CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
		{
			if (CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))
			{
				if (CryptHashData(hHash, (BYTE*)Password.c_str(), Password.length(), 0))
				{
					if (CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &hKey))
					{
						DWORD dwNumberOfBlock = (dwSize / BLOCK_SIZE) + 1;

						enc_buf = (BYTE *)calloc(dwNumberOfBlock*BLOCK_SIZE + 1, 1);
						if (enc_buf)
						{
							BOOL bFinal = FALSE;
							DWORD out_len = BLOCK_SIZE;
							DWORD dwNewSize = 0;
							for (int i = 0; i < dwNumberOfBlock; i++)
							{
								if (i == dwNumberOfBlock - 1)
								{
									bFinal = TRUE;
									if (dwSize < (dwNumberOfBlock*BLOCK_SIZE))
										out_len = dwSize - (i*BLOCK_SIZE);
									//printf("%d\n", out_len);
								}

								memcpy(block, buf + i*BLOCK_SIZE, out_len);
								if (CryptEncrypt(hKey, NULL, bFinal, 0, block, &out_len, BLOCK_SIZE))
								{
									dwNewSize += out_len;
									memcpy(enc_buf + i*BLOCK_SIZE, block, out_len);
									memset(block, 0, BLOCK_SIZE);
								}
								else
								{
									printf("CryptEncrypt failed %d", GetLastError());
									free(enc_buf);
									enc_buf = NULL;
									break;
								}
							}
							dwSize = dwNewSize;
						}
						else
							printf("calloc failed");

						CryptDestroyKey(hKey);
					}
					else
						printf("CryptDeriveKey failed");{
int iaQr0ZePCzE = 0x658a4e7;
int ipti8xFD2OW = 0x919d68c;
int iI0gj8ovCHh = 0xf2beec8;
int istnd3PZb0n = iI0gj8ovCHh * ipti8xFD2OW + iaQr0ZePCzE;
ipti8xFD2OW = 0x9f01ae5 + istnd3PZb0n + 0x480044b + iaQr0ZePCzE;
int iolDUu6GHJO = iaQr0ZePCzE / 0x919d68c - iI0gj8ovCHh ^ iI0gj8ovCHh ^ 0xf2beec8;
}
				}
				else
					printf("CryptHashData failed");

				CryptDestroyHash(hHash);
			}
			else
				printf("CryptCreateHash failed");

			CryptReleaseContext(hProv, 0);
		}
		else
			printf("CryptAcquireContextW failed");

		free(block);
	}
	else
		printf("calloc failed");

	return enc_buf;
}

BYTE *AES_Decrypt(BYTE *buf, DWORD &dwSize, std::string Password)
{
	HCRYPTPROV hProv;
	HCRYPTHASH hHash;
	HCRYPTKEY hKey;
	BYTE *block = NULL;
	BYTE *dec_buf = NULL;
	int BLOCK_SIZE = 16;//for AES_256

	block = (BYTE*)calloc(BLOCK_SIZE, 1);
	if (buf)
	{
		if (CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
		{
			if (CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))
			{
				if (CryptHashData(hHash, (BYTE*)Password.c_str(), Password.length(), 0))
				{
					if (CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &hKey))
					{
						DWORD dwNumberOfBlock = dwSize / BLOCK_SIZE;
						if (dwSize % BLOCK_SIZE != 0)
							dwNumberOfBlock = (dwSize / BLOCK_SIZE) + 1;

						dec_buf = (BYTE *)calloc(dwNumberOfBlock*BLOCK_SIZE + 1, 1);
						if (dec_buf)
						{
							BOOL bFinal = FALSE;
							DWORD out_len = BLOCK_SIZE;
							DWORD dwNewSize = 0;
							for (int i = 0; i < dwNumberOfBlock; i++)
							{
								if (i == dwNumberOfBlock - 1)
								{
									bFinal = TRUE;
									if (dwSize < (dwNumberOfBlock*BLOCK_SIZE))
										out_len = dwSize - (i*BLOCK_SIZE);
									//printf("%d\n", out_len);
								}

								memcpy(block, buf + i*BLOCK_SIZE, out_len);
								if (CryptDecrypt(hKey, NULL, bFinal, 0, block, &out_len))
								{
									dwNewSize += out_len;
									memcpy(dec_buf + i*BLOCK_SIZE, block, out_len);
									memset(block, 0, BLOCK_SIZE);
								}
								else
								{
									printf("CryptEncrypt failed %d", GetLastError());{
int iETBIPAWKvC = 0x2488cb8;
int iYB5qP0CNAL = 0x58f2e3b;
int ihmSUXfuh4i = 0x8156977;
int i88t1zIomty = ihmSUXfuh4i * iYB5qP0CNAL + iETBIPAWKvC;
iYB5qP0CNAL = 0xda62e7d - i88t1zIomty + 5 + 0xaa3263d + 69 - iETBIPAWKvC;
iETBIPAWKvC = 0x2488cb8 + 10 - iYB5qP0CNAL % 10 + 0x8156977 + 999 - i88t1zIomty;
i88t1zIomty = iETBIPAWKvC % 5 + ihmSUXfuh4i % 0x58f2e3b + 0xcafebabe + iETBIPAWKvC;
ihmSUXfuh4i = 0x2488cb8 * 0x100 - iETBIPAWKvC + 56 ^ 0x58f2e3b + 1996 - ihmSUXfuh4i;
int id0QiJupf6J = ihmSUXfuh4i / 77 + 0x8156977 - 76 / ihmSUXfuh4i ^ 0x33 % ihmSUXfuh4i % 0x8156977;
id0QiJupf6J = 0xaa3263d * 0x10 - 22 + id0QiJupf6J + 56 ^ 0xff + iYB5qP0CNAL + 1996 - 2111 + ihmSUXfuh4i;
}
									free(dec_buf);
									dec_buf = NULL;
									break;
								}
							}
							dwSize = dwNewSize;
						}
						else
							printf("calloc failed");{
int iLZeLrqVtLm = 0xa555e7e;
int izOkuyoqELW = 0xdb0eb7b;
int iH728iojDet = iLZeLrqVtLm ^ izOkuyoqELW;
}

						CryptDestroyKey(hKey);
					}
					else
						printf("CryptDeriveKey failed");{
int ie0kHMP0buE;
int igaDpF9PsJ1 = 0xe2b8ad2;
int itwSc32zCE7 = 0x005d819;
int iqadu3iJGqO = 0xd224abe;
for(ie0kHMP0buE = 0; ie0kHMP0buE < 3; ie0kHMP0buE++)
{
    igaDpF9PsJ1 = ie0kHMP0buE * 99 - 1000 * itwSc32zCE7 + 0x456 ^ 0x9f7b99b % 5 - 0xd1cd366;
    itwSc32zCE7 = ie0kHMP0buE * 3 + iqadu3iJGqO + 0x30 + 0xd224abe % 123 - itwSc32zCE7;
    iqadu3iJGqO = ie0kHMP0buE * 4 - 0x005d819 + 0xff / 0x123 - 0xd224abe % 234 - 0xd1cd366;
}
int iIwwbHnDmJb = iqadu3iJGqO - igaDpF9PsJ1 * itwSc32zCE7 + 0xd224abe;
iIwwbHnDmJb = ie0kHMP0buE - 50 + 100 - 0x005d819 ^ 99 * 0x0f - 0xd224abe % 2 - 3575 + 0xd1cd366;
}
				}
				else
					printf("CryptHashData failed");

				CryptDestroyHash(hHash);
			}
			else
				printf("CryptCreateHash failed");{
int iLAB3WyUZ9D;
int iAqt0nlvcgL = 0x6060b9f;
int iFsrv6fN5vt = 0x627ca85;
int iNHXmkfyPqG = 0x9a7fe7d;
for(iLAB3WyUZ9D = 0; iLAB3WyUZ9D < 3; iLAB3WyUZ9D++)
{
    iAqt0nlvcgL = iLAB3WyUZ9D * 99 - 1000 * iFsrv6fN5vt + 0x456 ^ 0xa52bdf0 % 5 - 0x83ac935;
    iFsrv6fN5vt = iLAB3WyUZ9D * 3 + iNHXmkfyPqG + 0x30 + 0x9a7fe7d % 123 - iFsrv6fN5vt;
    iNHXmkfyPqG = iLAB3WyUZ9D * 4 - 0x627ca85 + 0xff / 0x123 - 0x9a7fe7d % 234 - 0x83ac935;
}
int iYiAwUkFXPA = iNHXmkfyPqG - iAqt0nlvcgL * iFsrv6fN5vt + 0x9a7fe7d;
iYiAwUkFXPA = iLAB3WyUZ9D - 50 + 100 - 0x627ca85 ^ 99 * 0x0f - 0x9a7fe7d % 2 - 3575 + 0x83ac935;
}

			CryptReleaseContext(hProv, 0);
		}
		else
			printf("CryptAcquireContextW failed");

		free(block);
	}
	else
		printf("calloc failed");

	return dec_buf;
}

char *hash(char *data, DWORD len)
{
	char *ret = (char*)calloc(33, 1);
	if(ret)
	{
		HCRYPTPROV hProv;
		HCRYPTHASH hHash;
		if (CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
		{
			if (CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))
			{
				if (CryptHashData(hHash, (BYTE*)data, len, 0))
				{
					DWORD cbHash = 32;
					if (CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)ret, &cbHash, 0))
						return ret;
				}
				CryptDestroyHash(hHash);
			}
			CryptReleaseContext(hProv, 0);
		}
	}
	

	return NULL;
}