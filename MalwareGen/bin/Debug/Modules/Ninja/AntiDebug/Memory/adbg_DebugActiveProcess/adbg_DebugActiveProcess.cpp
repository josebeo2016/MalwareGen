#include "adbg_DebugActiveProcess.h"

/*
* // adbg_DebugActiveProcess()
*
* // How it works:
* ...
*
* // Indication:
* ...
*
* // Bypass:
* ...
*/
void adbg_DebugActiveProcess(const char *cpid)
{
	BOOL found = FALSE;
	STARTUPINFOA si = { 0 };
	PROCESS_INFORMATION pi = { 0 };
	si.cb = sizeof(si);
	TCHAR szPath[MAX_PATH];
	DWORD exitCode = 0;

	CreateMutex(NULL, FALSE, "antidbg");
	if (GetLastError() != ERROR_SUCCESS)
	{
		// If we get here we are in the child process
		if (DebugActiveProcess((DWORD)atoi(cpid)))
		{
			// No debugger found.
			return;
		}
		else
		{
			// Debugger found, exit child with a unique code we can check for.
			exit(555);
		}
	}

	// parent process
	DWORD pid = GetCurrentProcessId();
	GetModuleFileName(NULL, szPath, MAX_PATH);

	char cmdline[MAX_PATH + 1 + sizeof(int)];
	snprintf(cmdline, sizeof(cmdline), "%ws %d", szPath, pid);

	// Start the child process. 
	BOOL success = CreateProcessA(
		NULL,		// path (NULL means use cmdline instead)
		cmdline,	// Command line
		NULL,		// Process handle not inheritable
		NULL,		// Thread handle not inheritable
		FALSE,		// Set handle inheritance to FALSE
		0,			// No creation flags
		NULL,		// Use parent's environment block
		NULL,		// Use parent's starting directory 
		&si,		// Pointer to STARTUPINFO structure
		&pi);		// Pointer to PROCESS_INFORMATION structure

					// Wait until child process exits and get the code
	WaitForSingleObject(pi.hProcess, INFINITE);

	// Check for our unique exit code
	GetExitCodeProcess(pi.hProcess, &exitCode);
	if (exitCode == 555)
	{
		found = TRUE;
	}

	// Close process and thread handles. 
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	if (found)
	{
		printf("Caught by DebugActiveProcess!");
		exit(1);
	}
}