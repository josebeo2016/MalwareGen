#include <Windows.h>
#include "adbg_GetTickCount.h"

#define SHOW_DEBUG_MESSAGES

// =======================================================================
// Debugging helper
// =======================================================================
void DBG_MSG(char* message)
{
#ifdef SHOW_DEBUG_MESSAGES
	printf("[MSG-0x]: %s\n", message);
	printf("GAME OVER!");
#endif
}

// =======================================================================
// Timing Checks
// These checks focus on comparison of time stamps between a portion
// of code which is likely to be analyzed under a debugger. The goal
// is to determine with high probability that a debugger is allowing
// single step control, or that a breakpoint had been hit between
// the time check locations.
// =======================================================================


/*
* // adbg_GetTickCount()
*
* // How it works:
* ...
*
* // Indication:
* ...
*
* // Bypass:
* ...
*/
void adbg_GetTickCount(void)
{
	BOOL found = FALSE;
	DWORD t1;
	DWORD t2;

	t1 = GetTickCount();

	// Junk or legit code.
	_asm
	{
		xor eax, eax;
		push eax;
		push ecx;
		pop eax;
		pop ecx;
		sub ecx, eax;
		shl ecx, 4;
	}

	t2 = GetTickCount();

	// 30 milliseconds is an empirical value
	if ((t2 - t1) > 30)
	{
		found = TRUE;
	}

	if (found)
	{
		DBG_MSG("Caught by GetTickCount!");
		exit(1);
	}
}



// =======================================================================
// Exception Checks
// These checks focus on exceptions that occur when under the control of 
// a debugger. In several cases, there are certain exceptions that will
// be thrown only when running under a debugger.
// =======================================================================

/* 
 * // adbg_CloseHandleException()
 *
 * // How it works:
 * CloseHandle will throw an exception when trying to close an
 * invalid handle, only when running under a debugger. We pass
 * an invalid handle into CloseHandle to force an exception, 
 * where our own exception handler will close the application.
 * 
 * // Indication:
 * Look for possibly invalid handles passed to CloseHandle().
 * The validity of a handle can be difficult to assess, but
 * an application closing shortly after CloseHandle is a great
 * indication.
 *
 * // Bypass:
 * Modify the invalid handle passed into CloseHandle()
 * to be INVALID_HANDLE_VALUE, patch the call, or adjust EIP to
 * skip over the invalid CloseHandle. This may be easier said than
 * done if the CloseHandle is called many times with a mix of
 * valid and invalid handles.
 *
 */
void adbg_CloseHandleException(void)
{
	HANDLE hInvalid = (HANDLE)0xDEADBEEF; // an invalid handle
	DWORD found = FALSE;

	__try
	{
		CloseHandle(hInvalid);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		found = TRUE;
	}
	
	if (found)
	{
		DBG_MSG("Caught by an CloseHandle exception!");
		exit(1);
	}
}


/*
 * // adbg_SingleStepException()
 * 
 * // How it works:
 * ...
 *
 * // Indication:
 * ...
 *
 * // Bypass:
 * ...
 *
 */
void adbg_SingleStepException(void)
{
	DWORD found = TRUE;

	/*
	In this method we force an exception to occur. If it occurs
	outside of a debugger, the __except() handler is called setting
	found to FALSE. If the exception occurs inside of a debugger, the
	__except() will not be called (in certain cases) leading to
	found being TRUE.
	*/

	__try
	{
		_asm 
		{
			pushfd;						// save flag register
			or byte ptr[esp + 1], 1;	// set trap flag in EFlags
			popfd;						// restore flag register
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		found = FALSE;
	}

	if (found)
	{
		DBG_MSG("Caught by a Single Step Exception!");
		exit(1);
	}
}

/*
* // adbg_Int3()
*
* // How it works:
* INT 3 is a standard software breakpoint (opcode 0xCC). When
* you set a breakpoint, your debugger replaces the first opcode
* under the breakpoint location with a 0xCC (INT 3). When the
* debugger hits this opcode it breaks and restores the original
* opcode. We add an exeption handler that switches 'found' from
* true to false. Without a debugger, *something must* handle the
* breakpoint exception (which is our handler). If our handler does
* not get hit, it means a debugger attempted to handle the
* exception itself, an in turn, leaving 'found' marked true.
*
* // Indication:
* Most debuggers go out of their way to hide the fact that they
* have replaced an opcode with 0xCC. In IDA for example, you need
* to specifically set an option to show these replacements. If you
* ever see an INT 3 instruction or a 0xCC (standalone) opcode, 
* red flags should go up.
*
* // Bypass:
* Most debuggers will give you an option when an exception is 
* thrown - either pass the exception to the application (and
* hope it's equipped to handle it), or discard the exception
* and have the debugger handle it instead. Your debugger is 
* perfectly capacble of handling a breakpoint exception, but
* if your debugger handles this exception, 'found' is never
* marked false, and you're busted. When in doubt, pass
* exceptions to the application.
*/
void adbg_Int3(void)
{
	BOOL found = TRUE;

	__try 
	{	
		_asm 
		{
			int 3;	// 0xCC standard software breakpoint
		}
	}

	__except (EXCEPTION_EXECUTE_HANDLER) 
	{
		found = FALSE;
	}

	if (found)
	{
		DBG_MSG( "Caught by a rogue INT 3!");
		exit(1);
	}
}


/*
* // adbg_PrefixHop()
*
* // How it works:
* ...
*
* // Indication:
* ...
*
* // Bypass:
* ...
*
*/
void adbg_PrefixHop(void)
{
	BOOL found = TRUE;

	__try
	{
		_asm 
		{
			__emit 0xF3;	// 0xF3 0x64 is the prefix 'REP'
			__emit 0x64;
			__emit 0xCC;	// this gets skipped over if being debugged
		}
	}

	__except (EXCEPTION_EXECUTE_HANDLER) 
	{
		found = FALSE;
	}

	if (found)
	{
		DBG_MSG("Caught by a Prefix Hop!");
		exit(1);
	}
}


/*
* // adbg_Int2D()
*
* // How it works:
* ...
*
* // Indication:
* ...
*
* // Bypass:
* ...
*
*/
void adbg_Int2D(void)
{
	BOOL found = TRUE;

	__try
	{
		_asm
		{
			int 0x2D;	// kernel breakpoint
		}
	}

	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		found = FALSE;
	}

	if (found)
	{
		DBG_MSG("Caught by a rogue INT 2D!");
		exit(1);
	}
}

int main()
{

	/*
	This sample application calls all included anti-debugging methods
	one after the other. Your goal is to start from the entry point,
	and debug your way to the end without the debugger closing on you.
	
	Good Luck!
	*/

	// -------------------------------------------------------------------
	// -- Memory Checks --------------------------------------------------
	// -------------------------------------------------------------------
	adbg_IsDebuggerPresent();
	adbg_CheckRemoteDebuggerPresent();
	adbg_CheckWindowName();
	adbg_NtQueryInformationProcess();
	adbg_BeingDebuggedPEB();
	adbg_NtGlobalFlagPEB();

	// -------------------------------------------------------------------
	// -- Timing Checks --------------------------------------------------
	// -------------------------------------------------------------------
	adbg_RDTSC();
	adbg_QueryPerformanceCounter();
	adbg_GetTickCount();

	// -------------------------------------------------------------------
	// -- Exception Checks -----------------------------------------------
	// -------------------------------------------------------------------
	adbg_CloseHandleException();
	adbg_SingleStepException();
	adbg_Int3();
	adbg_Int2D();
	adbg_PrefixHop();

	// Your goal is to get here in a debugger without modifying EIP yourself.
	printf("Congratulations! You made it! You Win!");
		return 0;
}
