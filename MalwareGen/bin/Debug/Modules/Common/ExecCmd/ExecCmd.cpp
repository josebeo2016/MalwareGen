#include "ExecCmd.h"

void GetStatus(HANDLE hProcess, HANDLE hStdOutRead, bool &bRead, bool &bWrite, bool &bAlive)
{
	if (hProcess != INVALID_HANDLE_VALUE)
	{
		DWORD dwAvaiableData = 0;
		if (!PeekNamedPipe(hStdOutRead, NULL, 0, NULL, &dwAvaiableData, NULL))
		{
			printf("[GetStatus] PeekNamedPipe failed. err#%d.", GetLastError());
		}
		else
		{
			bRead = dwAvaiableData > 0;

			DWORD dwExitCode;
			BOOL getResult = GetExitCodeProcess(hProcess, &dwExitCode);
			if (getResult != TRUE || dwExitCode != STILL_ACTIVE)
			{
				bWrite = bAlive = false;
			}
			else
			{
				bWrite = bAlive = true;
			}
		}
	}
}

int GetSize(HANDLE hStdOutRead)
{
	DWORD dwAvaiableData = 0;
	if (!PeekNamedPipe(hStdOutRead, NULL, 0, NULL, &dwAvaiableData, NULL))
	{
		printf("[GetSize] PeekNamedPipe failed. err#%d.", GetLastError());
	}

	return dwAvaiableData;
}

int Read(HANDLE hStdOutRead, void *pBuf, int sztBuf)
{
	int ret = 0;
	DWORD dwReadByte = 0;
	if (ReadFile(hStdOutRead, pBuf, sztBuf, &dwReadByte, NULL) != TRUE)
	{
		printf("[Read] Read file pipe failed");
	}
	else
	{
		ret = (int)dwReadByte;
	}

	return ret;
}

std::string ExecCmd(std::string cmd, char *file)
{
	std::string result = "";

	HANDLE hProcess = INVALID_HANDLE_VALUE;
	HANDLE hStdInRead = INVALID_HANDLE_VALUE;
	HANDLE hStdInWrite = INVALID_HANDLE_VALUE;
	HANDLE hStdOutRead = INVALID_HANDLE_VALUE;
	HANDLE hStdOutWrite = INVALID_HANDLE_VALUE;

	SECURITY_ATTRIBUTES SecAttr;
	SecAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
	SecAttr.bInheritHandle = TRUE;
	SecAttr.lpSecurityDescriptor = NULL;

	if (!CreatePipe(&hStdOutRead, &hStdOutWrite, &SecAttr, 0))
		printf("[ExecCmd] StdOut CreatePipe");
	else if(!SetHandleInformation(hStdOutRead, HANDLE_FLAG_INHERIT, 0))
		printf("[ExecCmd] StdOut SetHandleInformation");
	else if(!CreatePipe(&hStdInRead, &hStdInWrite, &SecAttr, 0))
		printf("[ExecCmd] StdIn CreatePipe");
	else if(!SetHandleInformation(hStdInWrite, HANDLE_FLAG_INHERIT, 0))
		printf("[ExecCmd] StdIn SetHandleInformation");
	else
	{
		PROCESS_INFORMATION ProcInfo;
		STARTUPINFOA StartInfo;
		BOOL bSuccess = FALSE;

		ZeroMemory(&ProcInfo, sizeof(PROCESS_INFORMATION));

		ZeroMemory(&StartInfo, sizeof(STARTUPINFOA));
		StartInfo.cb = sizeof(STARTUPINFOA);
		StartInfo.hStdError = hStdOutWrite;
		StartInfo.hStdOutput = hStdOutWrite;
		StartInfo.hStdInput = hStdInRead;
		StartInfo.wShowWindow = SW_HIDE;
		StartInfo.dwFlags |= STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;

		//CHAR szCMDLine[MAX_PATH * 3];
		//lstrcpynA(szCMDLine, cmd.c_str(), MAX_PATH * 3);

		if(file)
			bSuccess = CreateProcessA(file,
				(LPSTR)cmd.c_str(),
				NULL,
				NULL,
				TRUE,
				0,
				NULL,
				NULL,
				&StartInfo,
				&ProcInfo);
		else
			bSuccess = CreateProcessA(NULL,
			(LPSTR)cmd.c_str(),
				NULL,
				NULL,
				TRUE,
				0,
				NULL,
				NULL,
				&StartInfo,
				&ProcInfo);


		if (!bSuccess)
		{
			DWORD er = GetLastError();
			printf("[ExecCmd] CreateProcess with cmd [%s] failed. err#%d.", cmd.c_str(), GetLastError());
		}
		else
		{
			CloseHandle(ProcInfo.hThread);

			bool bAlive = false;
			bool bRead = false;
			bool bWrite = false;
			char buff[10000];

			do 
			{
				GetStatus(ProcInfo.hProcess, hStdOutRead, bRead, bWrite, bAlive);
				if (bRead)
				{
					int r = Read(hStdOutRead, buff, GetSize(hStdOutRead));
					result += std::string(buff, buff + r);
				}
				
			} while (bAlive);		
		}
	}

	return result;
}