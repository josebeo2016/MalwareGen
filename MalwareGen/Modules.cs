using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml;

namespace MalwareGen
{

    public class Modules
    {
        private static Dictionary<String, String> defaultValue = new Dictionary<string, string> {
            { "Spreader","Base64P2P" },
            {"Increaseip","RandomChooseIP_IncreaseIP" },
        };
        public String MName { get; set; }
        public String MType { get; set; }
        //You can define each module as an Child Class of Module. But we
        //had not enough time.
        public String Author { get; set; }
        public String Reference { get; set; }
        public List<String> Files = new List<string>();
        public Dictionary<String,String> Inputs = new Dictionary<String, String>();
        //for debug
        public String Spreader = defaultValue["Spreader"]; //if this module is exploit
        public String Increaseip = defaultValue["Increaseip"];
        public String Header { get; set; }
        public String Info { get; set; }
        public String Path { get; set; }
        public Modules() { }

        public Modules(String path)
        {
            this.Path = path.Replace("info.xml", "");
            //add all file of module
            foreach(String file in Directory.GetFiles(this.Path))
            {
                String c = file.Replace(this.Path,"");
                if(c!="info.xml")
                    Files.Add(c);
            }
            XmlDocument document = new XmlDocument();
            document.Load(path);
            XmlNodeList nodes = document.DocumentElement.ChildNodes;
            foreach (XmlNode childnode in nodes)
            {
                
                if (childnode.Name == "Name")
                {
                    String intext = childnode.InnerText;
                    if (validateInput(ref intext))
                    {
                        this.MName = intext;
                    }
                }
                    
                if (childnode.Name == "Type")
                {
                    String intext = childnode.InnerText;
                    if (validateInput(ref intext))
                    {
                        this.MType = intext;
                    }
                }
                    
                if (childnode.Name == "Author")
                {
                    String intext = childnode.InnerText;
                    if (validateInput(ref intext))
                    {
                        this.Author = intext;
                    }
                }

                if (childnode.Name == "Header")
                {
                    String intext = childnode.InnerText;
                    if (validateInput(ref intext))
                    {
                        this.Header = intext;
                    }
                }

                if (childnode.Name == "Inputs")
                    foreach (XmlNode node in childnode.ChildNodes)
                    {
                        String key = node.InnerText;
                        if (validateInput(ref key))
                        {
                            this.Inputs.Add(key,"");
                        }
                        
                    }
                if (childnode.Name == "Info")
                {
                    String intext = childnode.InnerText;
                    if (validateInput(ref intext))
                    {
                        this.Info = intext;
                    }
                }
                if (childnode.Name == "Reference")
                {
                    String intext = childnode.InnerText;
                    if (validateInput(ref intext))
                    {
                        this.Reference = intext;
                    }
                }

            }
            
        }
        private bool validateInput(ref String ret)
        {
            if((!Regex.IsMatch(ret, @"^[a-zA-Z0-9]|^[_-]*$")) || ret =="" || ret==null)
            {
                return false;
            }
            else
            {
                ret = ret.Trim();
                return true;
            }
            
        }

    }
}
